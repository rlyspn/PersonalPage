From 0a4c56f7e4f7087053970783a8695598a17fbad7 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 12:27:17 -0400
Subject: [PATCH 01/75] -added a simple hello world server that can
 communicate between the emulator and the host.

---
 clfs/Makefile           |   58 ++++++++++++++++++++++++++++++++++++++++
 clfs/clfs_server.c      |   68 +++++++++++++++++++++++++++++++++++++++++++++++
 clfs/clfs_test_client.c |   59 ++++++++++++++++++++++++++++++++++++++++
 3 files changed, 185 insertions(+)
 create mode 100644 clfs/Makefile
 create mode 100644 clfs/clfs_server.c
 create mode 100644 clfs/clfs_test_client.c

diff --git a/clfs/Makefile b/clfs/Makefile
new file mode 100644
index 0000000..40788e6
--- /dev/null
+++ b/clfs/Makefile
@@ -0,0 +1,58 @@
+APP := clfs_test_client
+ROOT:=$(HOME)/repos
+NDK_PLATFORM_VER := 14
+INSTALL_DIR := /data/tmp
+
+ANDROID_SDK_ROOT:=$(ROOT)/adt-bundle-linux-x86_64/sdk
+ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8e
+ANDROID_NDK_HOST:=linux-x86_64
+ANDROID_TARGET:=i686-linux-android
+ANDROID_TARGET_ARCH:=x86
+ANDROID_TOOLCHAIN:=x86-4.4.3
+
+BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
+LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
+INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
+BIN := $(BINDIR)/bin
+
+LOCAL_CC := gcc
+LOCAL_FLAGS := -Wall -lpthread
+SRVR := clfs_server
+
+CPP := $(BIN)/$(ANDROID_TARGET)-g++
+CC := $(BIN)/$(ANDROID_TARGET)-gcc
+CFLAGS := -I$(INCDIR)
+LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
+ 
+all: $(APP) server
+
+server: $(SRVR).c
+	$(LOCAL_CC) $(SRVR).c $(LOCAL_FLAGS) -o $(SRVR)
+	echo "Server Built"
+ 
+OBJS += $(APP).o
+ 
+$(APP): $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $^
+ 
+%.o: %.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+install: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+ 
+shell:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
+ 
+run:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+r: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+clean:
+	@rm -f $(APP).o $(APP) $(SRVR)
+
diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
new file mode 100644
index 0000000..64dcec7
--- /dev/null
+++ b/clfs/clfs_server.c
@@ -0,0 +1,68 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <unistd.h>
+
+#define REQ_SIZE 1024
+#define BLK_SIZE 1024
+#define CLFS_PORT 8888
+#define MAX_CONN 32 /* This is arbitrary. */
+
+void *handle_request(void *client_fd) {
+
+	return 0;
+}
+
+int main()
+{
+	char buf[REQ_SIZE];
+	int servfd, clientfd;
+	struct sockaddr_in s_addr, c_addr;
+	size_t ad_size;
+	ssize_t bytes;
+
+	ad_size = sizeof(s_addr);
+
+	servfd = socket(AF_INET, SOCK_STREAM, 0);
+	if (servfd < 0) {
+		fprintf(stderr, "Error: failed to open socket.\n");
+		exit(1);
+	}
+	
+	memset(&s_addr, 0, ad_size);
+	memset(&c_addr, 0, ad_size);
+	s_addr.sin_family = AF_INET;
+	s_addr.sin_addr.s_addr = INADDR_ANY;
+	s_addr.sin_port = htons(CLFS_PORT);
+
+	bind(servfd, (struct sockaddr *) &s_addr, ad_size);
+
+	if (listen(servfd, 1) < 0) {
+		fprintf(stderr, "Error: Listen on socket failed.\n");
+		exit(1);
+	}
+	fprintf(stdout, "Listening on port: %d\n", CLFS_PORT);
+	while (1) {
+		memset(buf, 0, REQ_SIZE);
+		clientfd = accept(servfd, NULL, NULL);
+		if (clientfd < 0)
+			fprintf(stderr, "Error: failed to accept socket.\n");
+		else
+			fprintf(stdout, "Connected to client.\n");
+		bytes = read(clientfd, buf, REQ_SIZE);	
+		if (bytes == 0)
+			fprintf(stderr, "Error: failed to read from socket.\n");
+		else
+			fprintf(stdout, "Read %d bytes from socket.\n", bytes);
+
+	}
+	
+	close(servfd);
+	close(clientfd);
+
+	return 0;
+}
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
new file mode 100644
index 0000000..719a193
--- /dev/null
+++ b/clfs/clfs_test_client.c
@@ -0,0 +1,59 @@
+#include <stdio.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netdb.h>
+#include <arpa/inet.h>
+
+#define REQ_SIZE 1024
+#define CLFS_PORT 8888
+
+int main()
+{
+	char buffer[REQ_SIZE];
+	char ip_addr[] = "10.0.2.2";
+	char message[] = "hello world";
+	struct sockaddr_in srvaddr;
+	int srv_fd, conn_ret;
+
+
+	memset(&srvaddr, 0, sizeof(srvaddr));
+
+	srvaddr.sin_family = AF_INET;
+	srvaddr.sin_port = htons(CLFS_PORT);
+	srvaddr.sin_addr.s_addr = inet_addr(ip_addr);
+	//if (inet_aton(ip_addr, &srvaddr.sin_addr) == 0) {
+	if (srvaddr.sin_addr.s_addr == -1) {
+		fprintf(stderr, "Error: Failed to fined ip: %s\n", ip_addr);
+		exit(1);
+	} else {
+		fprintf(stdout, "Found correct ip.\n");
+	}
+
+
+	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (srv_fd < 0) {
+		fprintf(stderr, "Error: Failed to create socket.\n");
+		exit(1);
+	} else {
+		fprintf(stdout, "Created socket.\n");
+	}
+	conn_ret = connect(srv_fd, (struct sockaddr *) &srvaddr,
+			sizeof(srvaddr));
+	if (conn_ret < 0) {
+		fprintf(stderr, "Error: Failed to connect socket with error: %d.\n", errno);
+		exit(1);
+	} else {
+		fprintf(stdout, "Conntected to server.\n");
+	}
+
+	int wrote = write(srv_fd, buffer, REQ_SIZE);
+	printf("wrote %d bytes to socket.\n", wrote);
+
+	close(srv_fd);
+	return 0;
+}
-- 
1.7.9.5


From a84dfd30d98ee861b7bdc27fdc3dda223341eb2e Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 13:12:14 -0400
Subject: [PATCH 02/75] -added basic multithreaded handling.

---
 clfs/Makefile      |    1 -
 clfs/clfs_server.c |   55 +++++++++++++++++++++++++++++++++++++---------------
 2 files changed, 39 insertions(+), 17 deletions(-)

diff --git a/clfs/Makefile b/clfs/Makefile
index 40788e6..fbc44be 100644
--- a/clfs/Makefile
+++ b/clfs/Makefile
@@ -29,7 +29,6 @@ all: $(APP) server
 
 server: $(SRVR).c
 	$(LOCAL_CC) $(SRVR).c $(LOCAL_FLAGS) -o $(SRVR)
-	echo "Server Built"
  
 OBJS += $(APP).o
  
diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 64dcec7..0ac6875 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -1,29 +1,50 @@
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <pthread.h>
 #include <stdio.h>
 #include <stdlib.h>
+#include <string.h>
 #include <sys/socket.h>
 #include <sys/types.h>
-#include <arpa/inet.h>
-#include <netinet/in.h>
-#include <string.h>
 #include <unistd.h>
 
+#include "clfs.h"
+
 #define REQ_SIZE 1024
-#define BLK_SIZE 1024
-#define CLFS_PORT 8888
 #define MAX_CONN 32 /* This is arbitrary. */
 
-void *handle_request(void *client_fd) {
+struct clfs_thread_info {
+	struct clfs_req rq;
+	int client_fd;
+};
 
-	return 0;
+void *handle_clfs_request(void *thread_info) {
+	fprintf(stdout, "Handling request.\n");
+	int client_fd;
+	ssize_t bytes;
+	char buf[REQ_SIZE];
+
+	client_fd = (int) thread_info;
+	memset(buf, 0, REQ_SIZE);
+
+	bytes = read(client_fd, buf, REQ_SIZE);
+	if (bytes == 0)
+		fprintf(stderr, "Error: failed to read from socket.\n");
+	else
+		fprintf(stdout, "Read %lu bytes from socket.\n", bytes);
+
+
+	close(client_fd);
+	pthread_exit(NULL);
 }
 
 int main()
 {
 	char buf[REQ_SIZE];
-	int servfd, clientfd;
+	pthread_t thread_info[MAX_CONN];
+	int servfd, clientfd, thread_id;
 	struct sockaddr_in s_addr, c_addr;
 	size_t ad_size;
-	ssize_t bytes;
 
 	ad_size = sizeof(s_addr);
 
@@ -36,7 +57,7 @@ int main()
 	memset(&s_addr, 0, ad_size);
 	memset(&c_addr, 0, ad_size);
 	s_addr.sin_family = AF_INET;
-	s_addr.sin_addr.s_addr = INADDR_ANY;
+	s_addr.sin_addr.s_addr = INADDR_ANY; /*TODO: Change this. */
 	s_addr.sin_port = htons(CLFS_PORT);
 
 	bind(servfd, (struct sockaddr *) &s_addr, ad_size);
@@ -46,6 +67,8 @@ int main()
 		exit(1);
 	}
 	fprintf(stdout, "Listening on port: %d\n", CLFS_PORT);
+
+	thread_id = 0;
 	while (1) {
 		memset(buf, 0, REQ_SIZE);
 		clientfd = accept(servfd, NULL, NULL);
@@ -53,16 +76,16 @@ int main()
 			fprintf(stderr, "Error: failed to accept socket.\n");
 		else
 			fprintf(stdout, "Connected to client.\n");
-		bytes = read(clientfd, buf, REQ_SIZE);	
-		if (bytes == 0)
-			fprintf(stderr, "Error: failed to read from socket.\n");
-		else
-			fprintf(stdout, "Read %d bytes from socket.\n", bytes);
+		pthread_create(&thread_info[thread_id], NULL,
+				handle_clfs_request, (void *) clientfd);
+		thread_id++;
+		thread_id = thread_id % MAX_CONN;
+		fprintf(stdout, "thread_id = %d\n", thread_id);
 
 	}
 	
 	close(servfd);
-	close(clientfd);
 
+	pthread_exit(NULL);
 	return 0;
 }
-- 
1.7.9.5


From 787d19bc829135f6b43eff5953f203a934737bf0 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 13:25:57 -0400
Subject: [PATCH 03/75] -adding functions for handling put, rm, get, and err.

---
 clfs/clfs_server.c |   47 +++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 39 insertions(+), 8 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 0ac6875..911238f 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -13,26 +13,57 @@
 #define REQ_SIZE 1024
 #define MAX_CONN 32 /* This is arbitrary. */
 
-struct clfs_thread_info {
-	struct clfs_req rq;
-	int client_fd;
-};
+enum clfs_status handle_put(struct clfs_req req, char *block){
+
+	return -1;
+}
+enum clfs_status handle_get(struct clfs_req req){
+	return -1;
+}
+enum clfs_status handle_rm(struct clfs_req req){
+	return -1;
+}
+enum clfs_status handle_error(){
+	return CLFS_ERRO;
+}
+
+void *handle_clfs_request(void *thread_fd) {
 
-void *handle_clfs_request(void *thread_info) {
 	fprintf(stdout, "Handling request.\n");
-	int client_fd;
+	int client_fd, response;
+	size_t read_size;
 	ssize_t bytes;
 	char buf[REQ_SIZE];
+	char *block_buf;
+	struct clfs_req req;
 
-	client_fd = (int) thread_info;
+	client_fd = (int) thread_fd;
 	memset(buf, 0, REQ_SIZE);
+	read_size = sizeof(struct clfs_req) + BLK_SIZE;
 
-	bytes = read(client_fd, buf, REQ_SIZE);
+	bytes = read(client_fd, buf, read_size);
 	if (bytes == 0)
 		fprintf(stderr, "Error: failed to read from socket.\n");
 	else
 		fprintf(stdout, "Read %lu bytes from socket.\n", bytes);
 
+	memcpy(&req, buf, sizeof(struct clfs_req));
+	block_buf = buf + sizeof(struct clfs_req);
+	
+	switch (req.type){
+		case CLFS_PUT:
+			response = handle_put(req, block_buf);
+			break;
+		case CLFS_GET:
+			response = handle_get(req);
+			break;
+		case CLFS_RM:
+			response = handle_get(req);
+			break;
+		default:
+			response = handle_error();
+			break; /* Error */
+	}
 
 	close(client_fd);
 	pthread_exit(NULL);
-- 
1.7.9.5


From 92a2f01ceab0425d2ab9adfe4d023681a795cf77 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 14:35:24 -0400
Subject: [PATCH 04/75] -record the client sockaddr.

---
 clfs/clfs_server.c |   17 +++++++++++------
 1 file changed, 11 insertions(+), 6 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 911238f..6f65915 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -13,21 +13,26 @@
 #define REQ_SIZE 1024
 #define MAX_CONN 32 /* This is arbitrary. */
 
-enum clfs_status handle_put(struct clfs_req req, char *block){
+enum clfs_status handle_put(struct clfs_req req, char *block)
+{
 
 	return -1;
 }
-enum clfs_status handle_get(struct clfs_req req){
+enum clfs_status handle_get(struct clfs_req req)
+{
 	return -1;
 }
-enum clfs_status handle_rm(struct clfs_req req){
+enum clfs_status handle_rm(struct clfs_req req)
+{
 	return -1;
 }
-enum clfs_status handle_error(){
+enum clfs_status handle_error()
+{
 	return CLFS_ERRO;
 }
 
-void *handle_clfs_request(void *thread_fd) {
+void *handle_clfs_request(void *thread_fd)
+{
 
 	fprintf(stdout, "Handling request.\n");
 	int client_fd, response;
@@ -102,7 +107,7 @@ int main()
 	thread_id = 0;
 	while (1) {
 		memset(buf, 0, REQ_SIZE);
-		clientfd = accept(servfd, NULL, NULL);
+		clientfd = accept(servfd, (struct sockaddr *) &c_addr, (socklen_t *) &ad_size);
 		if (clientfd < 0)
 			fprintf(stderr, "Error: failed to accept socket.\n");
 		else
-- 
1.7.9.5


From 6c7c05567e96ffaca31e8d0d122c0cf4b75ec660 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 15:16:34 -0400
Subject: [PATCH 05/75] -implemented handle_put.

---
 clfs/clfs_server.c |   47 +++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 45 insertions(+), 2 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 6f65915..728a940 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -1,10 +1,13 @@
 #include <arpa/inet.h>
+#include <errno.h>
+#include <fcntl.h>
 #include <netinet/in.h>
 #include <pthread.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/socket.h>
+#include <sys/stat.h>
 #include <sys/types.h>
 #include <unistd.h>
 
@@ -12,18 +15,45 @@
 
 #define REQ_SIZE 1024
 #define MAX_CONN 32 /* This is arbitrary. */
+#define DIR_NAME "clfs_store/"
+#define FILE_NAME_MAX 256
+
+void create_path(char *dest, int inode, int block)
+{
+	sprintf(dest, "clfs_store/%d_%d", inode, block);
+}
 
 enum clfs_status handle_put(struct clfs_req req, char *block)
 {
+	enum clfs_status ret_status;
+	int path_fd, bytes;
+	char path[FILE_NAME_MAX];
+	create_path(path, req.inode, req.blk_offset);
+	path_fd = open(path, O_CREAT, O_RDONLY| S_IRUSR | S_IWUSR);
+	if (path_fd == -1) {
+		fprintf(stderr, "Failed to open file with error: %d\n", errno);
+		ret_status = EACCES;
 
-	return -1;
+	}
+	bytes = write(path_fd, block, BLK_SIZE);
+	if (bytes != BLK_SIZE) {
+		fprintf(stderr,
+			"Failed to write entire block. Wrote %d bytes.\n",
+			bytes);
+		ret_status = EACCES;
+	}
+	return ret_status;
 }
 enum clfs_status handle_get(struct clfs_req req)
 {
+	char path[FILE_NAME_MAX];
+	create_path(path, req.inode, req.blk_offset);
 	return -1;
 }
 enum clfs_status handle_rm(struct clfs_req req)
 {
+	char path[FILE_NAME_MAX];
+	create_path(path, req.inode, req.blk_offset);
 	return -1;
 }
 enum clfs_status handle_error()
@@ -74,6 +104,17 @@ void *handle_clfs_request(void *thread_fd)
 	pthread_exit(NULL);
 }
 
+int create_environment(){
+	int ret_val;
+	/* Create a user read/write directory. */
+	ret_val = mkdir(DIR_NAME, S_IRUSR | S_IWUSR);
+	if (ret_val == 0 || ret_val == EEXIST)
+		ret_val = 0;
+	else
+		ret_val = -1;
+	return ret_val;
+}
+
 int main()
 {
 	char buf[REQ_SIZE];
@@ -82,8 +123,10 @@ int main()
 	struct sockaddr_in s_addr, c_addr;
 	size_t ad_size;
 
-	ad_size = sizeof(s_addr);
+	if (create_environment()) 
+		fprintf(stderr, "Failed to created directory environment.\n");
 
+	ad_size = sizeof(s_addr);
 	servfd = socket(AF_INET, SOCK_STREAM, 0);
 	if (servfd < 0) {
 		fprintf(stderr, "Error: failed to open socket.\n");
-- 
1.7.9.5


From 796e77730542565d5ef66e273c75faffa38368e6 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 15:25:53 -0400
Subject: [PATCH 06/75] -implemented hangle_get.

---
 clfs/clfs_server.c |   29 +++++++++++++++++++++--------
 1 file changed, 21 insertions(+), 8 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 728a940..2830b60 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -20,6 +20,7 @@
 
 void create_path(char *dest, int inode, int block)
 {
+	memset(dest, 0, FILE_NAME_MAX);
 	sprintf(dest, "clfs_store/%d_%d", inode, block);
 }
 
@@ -31,7 +32,7 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 	create_path(path, req.inode, req.blk_offset);
 	path_fd = open(path, O_CREAT, O_RDONLY| S_IRUSR | S_IWUSR);
 	if (path_fd == -1) {
-		fprintf(stderr, "Failed to open file with error: %d\n", errno);
+		fprintf(stderr, "Failed to open file %s with error: %d\n", path, errno);
 		ret_status = EACCES;
 
 	}
@@ -44,11 +45,24 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 	}
 	return ret_status;
 }
-enum clfs_status handle_get(struct clfs_req req)
+enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 {
+	enum clfs_status ret_status;
+	ssize_t read_bytes;
+	int path_fd;
 	char path[FILE_NAME_MAX];
 	create_path(path, req.inode, req.blk_offset);
-	return -1;
+	path_fd = open(path, 0, O_RDONLY);
+	if (path_fd == -1) {
+		ret_status = CLFS_INVAL;
+		fprintf(stderr, "Failed to open file %s with error: %d\n", path, errno);
+	}
+	read_bytes = read(path_fd, blk_buf, BLK_SIZE);
+	if (read_bytes != BLK_SIZE) {
+		fprintf(stderr, "Read failed.  Read %lu bytes.\n", read_bytes);
+		ret_status = CLFS_ACCESS;
+	}
+	return ret_status;
 }
 enum clfs_status handle_rm(struct clfs_req req)
 {
@@ -58,7 +72,7 @@ enum clfs_status handle_rm(struct clfs_req req)
 }
 enum clfs_status handle_error()
 {
-	return CLFS_ERRO;
+	return CLFS_ERROR;
 }
 
 void *handle_clfs_request(void *thread_fd)
@@ -68,8 +82,7 @@ void *handle_clfs_request(void *thread_fd)
 	int client_fd, response;
 	size_t read_size;
 	ssize_t bytes;
-	char buf[REQ_SIZE];
-	char *block_buf;
+	char buf[REQ_SIZE], ret_buf[BLK_SIZE], *block_buf;
 	struct clfs_req req;
 
 	client_fd = (int) thread_fd;
@@ -90,10 +103,10 @@ void *handle_clfs_request(void *thread_fd)
 			response = handle_put(req, block_buf);
 			break;
 		case CLFS_GET:
-			response = handle_get(req);
+			response = handle_get(req, ret_buf);
 			break;
 		case CLFS_RM:
-			response = handle_get(req);
+			response = handle_rm(req);
 			break;
 		default:
 			response = handle_error();
-- 
1.7.9.5


From 47e63e50ce816b2e5636173c1442046b77176298 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 15:30:17 -0400
Subject: [PATCH 07/75] -implemented handle_rm

---
 clfs/clfs_server.c |   14 +++++++++++++-
 1 file changed, 13 insertions(+), 1 deletion(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 2830b60..ab9554c 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -29,6 +29,8 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 	enum clfs_status ret_status;
 	int path_fd, bytes;
 	char path[FILE_NAME_MAX];
+
+	ret_status = CLFS_OK;
 	create_path(path, req.inode, req.blk_offset);
 	path_fd = open(path, O_CREAT, O_RDONLY| S_IRUSR | S_IWUSR);
 	if (path_fd == -1) {
@@ -51,6 +53,8 @@ enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 	ssize_t read_bytes;
 	int path_fd;
 	char path[FILE_NAME_MAX];
+
+	ret_status = CLFS_OK;
 	create_path(path, req.inode, req.blk_offset);
 	path_fd = open(path, 0, O_RDONLY);
 	if (path_fd == -1) {
@@ -66,9 +70,17 @@ enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 }
 enum clfs_status handle_rm(struct clfs_req req)
 {
+	enum clfs_status ret_status;
 	char path[FILE_NAME_MAX];
+
+	ret_status = CLFS_OK;
 	create_path(path, req.inode, req.blk_offset);
-	return -1;
+	if (remove(path) == -1) {
+		fprintf(stderr, "Failed to remove %s with errno %d\n", path,
+				errno);
+		ret_status = CLFS_INVAL;
+	}
+	return ret_status;
 }
 enum clfs_status handle_error()
 {
-- 
1.7.9.5


From 54593301b9c7c362a211f7f781f2dc30517d84f0 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 16:48:39 -0400
Subject: [PATCH 08/75] -wrote put test in client. -moved to using fopen/fread

---
 clfs/Makefile           |    2 +-
 clfs/clfs_server.c      |   45 +++++++++++++++++++++++++++++++--------------
 clfs/clfs_test_client.c |   37 +++++++++++++++++++++++++++++++------
 3 files changed, 63 insertions(+), 21 deletions(-)

diff --git a/clfs/Makefile b/clfs/Makefile
index fbc44be..9776576 100644
--- a/clfs/Makefile
+++ b/clfs/Makefile
@@ -37,7 +37,7 @@ $(APP): $(OBJS)
  
 %.o: %.c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-install: $(APP)
+install: $(APP) server
 	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
  
diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index ab9554c..2e5c073 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -27,23 +27,34 @@ void create_path(char *dest, int inode, int block)
 enum clfs_status handle_put(struct clfs_req req, char *block)
 {
 	enum clfs_status ret_status;
-	int path_fd, bytes;
+	size_t bytes;
+	FILE *path_fd;
 	char path[FILE_NAME_MAX];
 
+	fprintf(stdout, "Handling CLFS_PUT.\n");
+	printf("Block[0] = %x\n", block[0]);
+
 	ret_status = CLFS_OK;
 	create_path(path, req.inode, req.blk_offset);
-	path_fd = open(path, O_CREAT, O_RDONLY| S_IRUSR | S_IWUSR);
-	if (path_fd == -1) {
+	printf("Writing to path: %s\n", path);
+	path_fd = fopen(path, "w+");
+	if (path_fd == NULL) {
 		fprintf(stderr, "Failed to open file %s with error: %d\n", path, errno);
 		ret_status = EACCES;
-
-	}
-	bytes = write(path_fd, block, BLK_SIZE);
-	if (bytes != BLK_SIZE) {
-		fprintf(stderr,
-			"Failed to write entire block. Wrote %d bytes.\n",
-			bytes);
-		ret_status = EACCES;
+	} else {
+		//bytes = write(path_fd, block, BLK_SIZE);
+		bytes = fwrite(block, sizeof(char), BLK_SIZE, path_fd);
+		if (bytes != BLK_SIZE) {
+			fprintf(stderr,
+				"Failed to write entire block. Wrote %lu bytes with errno %d.\n",
+				bytes, errno);
+			ret_status = EACCES;
+		}
+		if (fclose(path_fd) != 0){
+			fprintf(stderr, "Failed to close %s with errno: %d\n", path, errno);
+			ret_status = EACCES;
+		}
+		fprintf(stderr, "Wrote %lu bytes.\n", bytes);
 	}
 	return ret_status;
 }
@@ -113,15 +124,19 @@ void *handle_clfs_request(void *thread_fd)
 	switch (req.type){
 		case CLFS_PUT:
 			response = handle_put(req, block_buf);
+			write(client_fd, &response, sizeof(response));
 			break;
 		case CLFS_GET:
 			response = handle_get(req, ret_buf);
+			write(client_fd, ret_buf, BLK_SIZE);
 			break;
 		case CLFS_RM:
 			response = handle_rm(req);
+			write(client_fd, &response, sizeof(response));
 			break;
 		default:
 			response = handle_error();
+			write(client_fd, &response, sizeof(response));
 			break; /* Error */
 	}
 
@@ -132,11 +147,13 @@ void *handle_clfs_request(void *thread_fd)
 int create_environment(){
 	int ret_val;
 	/* Create a user read/write directory. */
-	ret_val = mkdir(DIR_NAME, S_IRUSR | S_IWUSR);
-	if (ret_val == 0 || ret_val == EEXIST)
+	ret_val = mkdir(DIR_NAME, S_IRWXU | S_IRWXG | S_IRWXO);
+	if (ret_val == 0 || errno == 17)
 		ret_val = 0;
-	else
+	else {
+		fprintf(stderr, "Failed to create environment with error %d\n", errno);
 		ret_val = -1;
+	}
 	return ret_val;
 }
 
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index 719a193..0daa779 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -9,24 +9,44 @@
 #include <netdb.h>
 #include <arpa/inet.h>
 
-#define REQ_SIZE 1024
+#include "clfs.h"
+
 #define CLFS_PORT 8888
 
 int main()
 {
-	char buffer[REQ_SIZE];
+	size_t req_size;
+	req_size = sizeof(struct clfs_req) + BLK_SIZE;
+
+	char buffer[req_size];
+	char block[BLK_SIZE], ret_block[BLK_SIZE];
 	char ip_addr[] = "10.0.2.2";
 	char message[] = "hello world";
 	struct sockaddr_in srvaddr;
-	int srv_fd, conn_ret;
+	struct clfs_req put_rq, get_rq, rm_rq;
+	int srv_fd, conn_ret, inode, block_offset;
 
+	memset(block, 5, BLK_SIZE);
+	memset(buffer, 0, req_size);
+	inode = 7;
+	block_offset = 22;
+	put_rq.type = CLFS_PUT;
+	put_rq.inode = inode;
+	put_rq.blk_offset = block_offset;
 
-	memset(&srvaddr, 0, sizeof(srvaddr));
+	get_rq.type = CLFS_GET;
+	get_rq.inode = inode;
+	get_rq.blk_offset = block_offset;
 
+	rm_rq.type = CLFS_RM;
+	rm_rq.inode = inode;
+	rm_rq.blk_offset = block_offset;
+	
+	memset(&srvaddr, 0, sizeof(srvaddr));
 	srvaddr.sin_family = AF_INET;
 	srvaddr.sin_port = htons(CLFS_PORT);
 	srvaddr.sin_addr.s_addr = inet_addr(ip_addr);
-	//if (inet_aton(ip_addr, &srvaddr.sin_addr) == 0) {
+
 	if (srvaddr.sin_addr.s_addr == -1) {
 		fprintf(stderr, "Error: Failed to fined ip: %s\n", ip_addr);
 		exit(1);
@@ -51,8 +71,13 @@ int main()
 		fprintf(stdout, "Conntected to server.\n");
 	}
 
-	int wrote = write(srv_fd, buffer, REQ_SIZE);
+	memcpy(buffer, &put_rq, sizeof(put_rq));
+	memcpy(buffer + sizeof(put_rq), block, BLK_SIZE);
+	int wrote = write(srv_fd, buffer, req_size);
 	printf("wrote %d bytes to socket.\n", wrote);
+	memset(buffer, 0, req_size);
+	read(srv_fd, buffer, sizeof(enum clfs_status));
+	printf("CLFS_PUT response: %d\n", *((int *)buffer));
 
 	close(srv_fd);
 	return 0;
-- 
1.7.9.5


From 0ccdafde8431ce153430dda87a8547039dbc511b Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 17:07:34 -0400
Subject: [PATCH 09/75] -wrote tests for correct put and get.

---
 clfs/clfs_test_client.c |   37 +++++++++++++++++++++++++++++++++++++
 1 file changed, 37 insertions(+)

diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index 0daa779..22fdd83 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -55,6 +55,7 @@ int main()
 	}
 
 
+	/* Test CLFS_PUT */
 	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (srv_fd < 0) {
 		fprintf(stderr, "Error: Failed to create socket.\n");
@@ -71,6 +72,7 @@ int main()
 		fprintf(stdout, "Conntected to server.\n");
 	}
 
+	memset(buffer, 0, req_size);
 	memcpy(buffer, &put_rq, sizeof(put_rq));
 	memcpy(buffer + sizeof(put_rq), block, BLK_SIZE);
 	int wrote = write(srv_fd, buffer, req_size);
@@ -78,7 +80,42 @@ int main()
 	memset(buffer, 0, req_size);
 	read(srv_fd, buffer, sizeof(enum clfs_status));
 	printf("CLFS_PUT response: %d\n", *((int *)buffer));
+	close(srv_fd);
+
+	/* TEST CLFS_GET */
+	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (srv_fd < 0) {
+		fprintf(stderr, "Error: Failed to create socket.\n");
+		exit(1);
+	} else {
+		fprintf(stdout, "Created socket.\n");
+	}
+	conn_ret = connect(srv_fd, (struct sockaddr *) &srvaddr,
+			sizeof(srvaddr));
+	if (conn_ret < 0) {
+		fprintf(stderr, "Error: Failed to connect socket with error: %d.\n", errno);
+		exit(1);
+	} else {
+		fprintf(stdout, "Conntected to server.\n");
+	}
+	memset(buffer, 0, req_size);
+	memcpy(buffer, &get_rq, sizeof(get_rq));
+	wrote = write(srv_fd, buffer, req_size);
+	memset(buffer, 0, req_size);
+	read(srv_fd, buffer, BLK_SIZE);
+	int i, count;
+	count = 0;
+	for(i = 0; i < BLK_SIZE; i++) {
+		if (buffer[i] != 5) {
+			fprintf(stderr, "ERROR: expected to equal 5\n");
+			count++;
+		}
+	}
+	if (count == 0)
+		fprintf(stdout, "Correctly returned block.\n");
 
 	close(srv_fd);
+
+
 	return 0;
 }
-- 
1.7.9.5


From 67486c8e99d57e48760a399176adeca19b7ed2d2 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 17:10:52 -0400
Subject: [PATCH 10/75] -wrote test for rm. -get, put, and rm all seem to be
 working.

---
 clfs/clfs_test_client.c |   26 +++++++++++++++++++++++++-
 1 file changed, 25 insertions(+), 1 deletion(-)

diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index 22fdd83..6d37391 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -113,9 +113,33 @@ int main()
 	}
 	if (count == 0)
 		fprintf(stdout, "Correctly returned block.\n");
-
+	else
+		fprintf(stdout, "Failed to return block.\n");
 	close(srv_fd);
 
+	/* TEST CLFS_RM */
+	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
+	if (srv_fd < 0) {
+		fprintf(stderr, "Error: Failed to create socket.\n");
+		exit(1);
+	} else {
+		fprintf(stdout, "Created socket.\n");
+	}
+	conn_ret = connect(srv_fd, (struct sockaddr *) &srvaddr,
+			sizeof(srvaddr));
+	if (conn_ret < 0) {
+		fprintf(stderr, "Error: Failed to connect socket with error: %d.\n", errno);
+		exit(1);
+	} else {
+		fprintf(stdout, "Conntected to server.\n");
+	}
+	memset(buffer, 0, req_size);
+	memcpy(buffer, &rm_rq, sizeof(rm_rq));
+	wrote = write(srv_fd, buffer, req_size);
+	memset(buffer, 0, req_size);
+	read(srv_fd, buffer, sizeof(enum clfs_status));
+	printf("CLFS_RM response: %d\n", *((int *)buffer));
 
+	close(srv_fd);
 	return 0;
 }
-- 
1.7.9.5


From ddb7622bb41a00a6730fc7063ef6c58fc6f44db4 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 21 Apr 2013 22:31:22 -0400
Subject: [PATCH 11/75] -corrected clfs_server for checkpatch.

---
 clfs/clfs_server.c |   65 ++++++++++++++++++++++++++++------------------------
 1 file changed, 35 insertions(+), 30 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 2e5c073..0268dcc 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -39,19 +39,20 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 	printf("Writing to path: %s\n", path);
 	path_fd = fopen(path, "w+");
 	if (path_fd == NULL) {
-		fprintf(stderr, "Failed to open file %s with error: %d\n", path, errno);
+		fprintf(stderr, "Failed to open file %s with error: %d\n",
+				path, errno);
 		ret_status = EACCES;
 	} else {
-		//bytes = write(path_fd, block, BLK_SIZE);
 		bytes = fwrite(block, sizeof(char), BLK_SIZE, path_fd);
 		if (bytes != BLK_SIZE) {
 			fprintf(stderr,
-				"Failed to write entire block. Wrote %lu bytes with errno %d.\n",
+				"Error: Wrote %lu bytes with errno %d.\n",
 				bytes, errno);
 			ret_status = EACCES;
 		}
-		if (fclose(path_fd) != 0){
-			fprintf(stderr, "Failed to close %s with errno: %d\n", path, errno);
+		if (fclose(path_fd) != 0) {
+			fprintf(stderr, "Failed to close %s with errno: %d\n",
+					path, errno);
 			ret_status = EACCES;
 		}
 		fprintf(stderr, "Wrote %lu bytes.\n", bytes);
@@ -70,7 +71,8 @@ enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 	path_fd = open(path, 0, O_RDONLY);
 	if (path_fd == -1) {
 		ret_status = CLFS_INVAL;
-		fprintf(stderr, "Failed to open file %s with error: %d\n", path, errno);
+		fprintf(stderr, "Failed to open file %s with error: %d\n",
+				path, errno);
 	}
 	read_bytes = read(path_fd, blk_buf, BLK_SIZE);
 	if (read_bytes != BLK_SIZE) {
@@ -120,38 +122,40 @@ void *handle_clfs_request(void *thread_fd)
 
 	memcpy(&req, buf, sizeof(struct clfs_req));
 	block_buf = buf + sizeof(struct clfs_req);
-	
-	switch (req.type){
-		case CLFS_PUT:
-			response = handle_put(req, block_buf);
-			write(client_fd, &response, sizeof(response));
-			break;
-		case CLFS_GET:
-			response = handle_get(req, ret_buf);
-			write(client_fd, ret_buf, BLK_SIZE);
-			break;
-		case CLFS_RM:
-			response = handle_rm(req);
-			write(client_fd, &response, sizeof(response));
-			break;
-		default:
-			response = handle_error();
-			write(client_fd, &response, sizeof(response));
-			break; /* Error */
+
+	switch (req.type) {
+	case CLFS_PUT:
+		response = handle_put(req, block_buf);
+		write(client_fd, &response, sizeof(response));
+		break;
+	case CLFS_GET:
+		response = handle_get(req, ret_buf);
+		write(client_fd, ret_buf, BLK_SIZE);
+		break;
+	case CLFS_RM:
+		response = handle_rm(req);
+		write(client_fd, &response, sizeof(response));
+		break;
+	default:
+		response = handle_error();
+		write(client_fd, &response, sizeof(response));
+		break; /* Error */
 	}
 
 	close(client_fd);
 	pthread_exit(NULL);
 }
 
-int create_environment(){
+int create_environment()
+{
 	int ret_val;
 	/* Create a user read/write directory. */
 	ret_val = mkdir(DIR_NAME, S_IRWXU | S_IRWXG | S_IRWXO);
 	if (ret_val == 0 || errno == 17)
 		ret_val = 0;
 	else {
-		fprintf(stderr, "Failed to create environment with error %d\n", errno);
+		fprintf(stderr, "Failed to create environment with error %d\n",
+				errno);
 		ret_val = -1;
 	}
 	return ret_val;
@@ -165,7 +169,7 @@ int main()
 	struct sockaddr_in s_addr, c_addr;
 	size_t ad_size;
 
-	if (create_environment()) 
+	if (create_environment())
 		fprintf(stderr, "Failed to created directory environment.\n");
 
 	ad_size = sizeof(s_addr);
@@ -174,7 +178,7 @@ int main()
 		fprintf(stderr, "Error: failed to open socket.\n");
 		exit(1);
 	}
-	
+
 	memset(&s_addr, 0, ad_size);
 	memset(&c_addr, 0, ad_size);
 	s_addr.sin_family = AF_INET;
@@ -192,7 +196,8 @@ int main()
 	thread_id = 0;
 	while (1) {
 		memset(buf, 0, REQ_SIZE);
-		clientfd = accept(servfd, (struct sockaddr *) &c_addr, (socklen_t *) &ad_size);
+		clientfd = accept(servfd, (struct sockaddr *) &c_addr,
+				(socklen_t *) &ad_size);
 		if (clientfd < 0)
 			fprintf(stderr, "Error: failed to accept socket.\n");
 		else
@@ -204,7 +209,7 @@ int main()
 		fprintf(stdout, "thread_id = %d\n", thread_id);
 
 	}
-	
+
 	close(servfd);
 
 	pthread_exit(NULL);
-- 
1.7.9.5


From 951d6ab14b3d782e63d01ba39cfa05c5331ada18 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Mon, 22 Apr 2013 12:02:43 -0400
Subject: [PATCH 12/75] -moved put to use recv.

---
 clfs/clfs_server.c      |   81 +++++++++++++++++++++++++++++++++++------------
 clfs/clfs_test_client.c |   17 ++++++----
 2 files changed, 71 insertions(+), 27 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 0268dcc..7b33de0 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -18,24 +18,26 @@
 #define DIR_NAME "clfs_store/"
 #define FILE_NAME_MAX 256
 
-void create_path(char *dest, int inode, int block)
+void create_path(char *dest, int inode)
 {
 	memset(dest, 0, FILE_NAME_MAX);
-	sprintf(dest, "clfs_store/%d_%d", inode, block);
+	sprintf(dest, "clfs_store/%d.dat", inode);
 }
 
 enum clfs_status handle_put(struct clfs_req req, char *block)
 {
+	int size;
 	enum clfs_status ret_status;
 	size_t bytes;
 	FILE *path_fd;
 	char path[FILE_NAME_MAX];
 
+	size = req.size;
 	fprintf(stdout, "Handling CLFS_PUT.\n");
 	printf("Block[0] = %x\n", block[0]);
 
 	ret_status = CLFS_OK;
-	create_path(path, req.inode, req.blk_offset);
+	create_path(path, req.inode);
 	printf("Writing to path: %s\n", path);
 	path_fd = fopen(path, "w+");
 	if (path_fd == NULL) {
@@ -43,8 +45,8 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 				path, errno);
 		ret_status = EACCES;
 	} else {
-		bytes = fwrite(block, sizeof(char), BLK_SIZE, path_fd);
-		if (bytes != BLK_SIZE) {
+		bytes = fwrite(block, sizeof(char), size, path_fd);
+		if (bytes != size) {
 			fprintf(stderr,
 				"Error: Wrote %lu bytes with errno %d.\n",
 				bytes, errno);
@@ -59,35 +61,45 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 	}
 	return ret_status;
 }
+
 enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 {
 	enum clfs_status ret_status;
+	int size;
 	ssize_t read_bytes;
 	int path_fd;
 	char path[FILE_NAME_MAX];
 
+	size = req.size;
+	blk_buf = malloc(size);
+	if (blk_buf == NULL){
+		fprintf(stderr, "Out of memory.\n");
+		exit(1);
+	}
 	ret_status = CLFS_OK;
-	create_path(path, req.inode, req.blk_offset);
+	create_path(path, req.inode);
 	path_fd = open(path, 0, O_RDONLY);
 	if (path_fd == -1) {
 		ret_status = CLFS_INVAL;
 		fprintf(stderr, "Failed to open file %s with error: %d\n",
 				path, errno);
 	}
-	read_bytes = read(path_fd, blk_buf, BLK_SIZE);
-	if (read_bytes != BLK_SIZE) {
+	read_bytes = read(path_fd, blk_buf, size);
+	if (read_bytes != size) {
 		fprintf(stderr, "Read failed.  Read %lu bytes.\n", read_bytes);
 		ret_status = CLFS_ACCESS;
 	}
+	fprintf(stdout, "Read %lu bytes from file.\n", read_bytes);
 	return ret_status;
 }
+
 enum clfs_status handle_rm(struct clfs_req req)
 {
 	enum clfs_status ret_status;
 	char path[FILE_NAME_MAX];
 
 	ret_status = CLFS_OK;
-	create_path(path, req.inode, req.blk_offset);
+	create_path(path, req.inode);
 	if (remove(path) == -1) {
 		fprintf(stderr, "Failed to remove %s with errno %d\n", path,
 				errno);
@@ -104,33 +116,60 @@ void *handle_clfs_request(void *thread_fd)
 {
 
 	fprintf(stdout, "Handling request.\n");
-	int client_fd, response;
+	int client_fd, response, read_succeed;
 	size_t read_size;
-	ssize_t bytes;
-	char buf[REQ_SIZE], ret_buf[BLK_SIZE], *block_buf;
+	ssize_t bytes, bytes_remaining, start_byte;
+	char buf[REQ_SIZE], *ret_buf, *block_buf;
 	struct clfs_req req;
 
 	client_fd = (int) thread_fd;
 	memset(buf, 0, REQ_SIZE);
-	read_size = sizeof(struct clfs_req) + BLK_SIZE;
+	read_size = sizeof(struct clfs_req);
 
-	bytes = read(client_fd, buf, read_size);
-	if (bytes == 0)
-		fprintf(stderr, "Error: failed to read from socket.\n");
-	else
+	bytes = recv(client_fd, buf, read_size, 0);
+	if (bytes == read_size)
 		fprintf(stdout, "Read %lu bytes from socket.\n", bytes);
+	else
+		fprintf(stderr, "Error: failed to read from socket.\n");
 
 	memcpy(&req, buf, sizeof(struct clfs_req));
-	block_buf = buf + sizeof(struct clfs_req);
 
 	switch (req.type) {
 	case CLFS_PUT:
-		response = handle_put(req, block_buf);
-		write(client_fd, &response, sizeof(response));
+		bytes_remaining = req.size;
+		printf("size = %d\n", req.size);
+		block_buf = malloc(bytes_remaining);
+		if (block_buf == NULL) {
+			fprintf(stderr, "Out of memory.\n");
+			exit(1);
+		}
+
+		read_succeed = 0;
+		while (bytes_remaining > 0) {
+			start_byte = req.size - bytes_remaining;
+			printf("start byte = %lu\n", start_byte);
+			bytes = recv(client_fd, block_buf + start_byte, req.size, 0);
+			bytes_remaining -= bytes;
+			printf("read %lu bytes.\n", bytes);
+			printf("bytes_remaining = %lu\n", bytes_remaining);
+			if (bytes_remaining == 0)
+				read_succeed = 1;
+		}
+		if (read_succeed)
+		{
+			response = handle_put(req, block_buf);
+			write(client_fd, &response, sizeof(response));
+		} else {
+			fprintf(stderr, "Failed to read buffer from socket %lu, %d.\n", bytes, buf[0]);
+			response = CLFS_ERROR;
+			write(client_fd, &response, sizeof(response));
+		}
+		free(block_buf);
 		break;
 	case CLFS_GET:
 		response = handle_get(req, ret_buf);
-		write(client_fd, ret_buf, BLK_SIZE);
+		write(client_fd, ret_buf, req.size);
+		free(ret_buf);
 		break;
 	case CLFS_RM:
 		response = handle_rm(req);
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index 6d37391..7ff1e71 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -12,6 +12,7 @@
 #include "clfs.h"
 
 #define CLFS_PORT 8888
+#define BLK_SIZE 2048
 
 int main()
 {
@@ -32,15 +33,15 @@ int main()
 	block_offset = 22;
 	put_rq.type = CLFS_PUT;
 	put_rq.inode = inode;
-	put_rq.blk_offset = block_offset;
+	put_rq.size = BLK_SIZE;
 
 	get_rq.type = CLFS_GET;
 	get_rq.inode = inode;
-	get_rq.blk_offset = block_offset;
+	get_rq.size = BLK_SIZE;
 
 	rm_rq.type = CLFS_RM;
 	rm_rq.inode = inode;
-	rm_rq.blk_offset = block_offset;
+	rm_rq.size = BLK_SIZE;
 	
 	memset(&srvaddr, 0, sizeof(srvaddr));
 	srvaddr.sin_family = AF_INET;
@@ -72,9 +73,10 @@ int main()
 		fprintf(stdout, "Conntected to server.\n");
 	}
 
-	memset(buffer, 0, req_size);
 	memcpy(buffer, &put_rq, sizeof(put_rq));
 	memcpy(buffer + sizeof(put_rq), block, BLK_SIZE);
+	printf("req_size = %lu\n", req_size);
+	printf("buffer = %d\n", buffer [sizeof(put_rq)]);
 	int wrote = write(srv_fd, buffer, req_size);
 	printf("wrote %d bytes to socket.\n", wrote);
 	memset(buffer, 0, req_size);
@@ -107,17 +109,19 @@ int main()
 	count = 0;
 	for(i = 0; i < BLK_SIZE; i++) {
 		if (buffer[i] != 5) {
-			fprintf(stderr, "ERROR: expected to equal 5\n");
+			if (count == 0)
+				fprintf(stderr, "ERROR: expected to equal 5 not %d\n", buffer[i]);
 			count++;
 		}
 	}
 	if (count == 0)
 		fprintf(stdout, "Correctly returned block.\n");
 	else
-		fprintf(stdout, "Failed to return block.\n");
+		fprintf(stdout, "Failed to return block %d.\n", count);
 	close(srv_fd);
 
 	/* TEST CLFS_RM */
+	/*
 	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (srv_fd < 0) {
 		fprintf(stderr, "Error: Failed to create socket.\n");
@@ -141,5 +145,6 @@ int main()
 	printf("CLFS_RM response: %d\n", *((int *)buffer));
 
 	close(srv_fd);
+	*/
 	return 0;
 }
-- 
1.7.9.5


From 7c3f5fd2953afed092d50128d93b6ab17c047b4c Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Mon, 22 Apr 2013 13:04:28 -0400
Subject: [PATCH 13/75] -removed unneeded malloc. -should be working for files
 now.

---
 clfs/clfs_server.c      |    6 +++++-
 clfs/clfs_test_client.c |   16 +++++++++++-----
 2 files changed, 16 insertions(+), 6 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index 7b33de0..b5cf53b 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -71,7 +71,6 @@ enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 	char path[FILE_NAME_MAX];
 
 	size = req.size;
-	blk_buf = malloc(size);
 	if (blk_buf == NULL){
 		fprintf(stderr, "Out of memory.\n");
 		exit(1);
@@ -167,6 +166,11 @@ void *handle_clfs_request(void *thread_fd)
 		free(block_buf);
 		break;
 	case CLFS_GET:
+		ret_buf = malloc(req.size);
+		if (ret_buf == NULL){
+			fprintf(stderr, "Out of memory.\n");
+			exit(1);
+		}
 		response = handle_get(req, ret_buf);
 		write(client_fd, ret_buf, req.size);
 		free(ret_buf);
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index 7ff1e71..b0a7a25 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -27,7 +27,7 @@ int main()
 	struct clfs_req put_rq, get_rq, rm_rq;
 	int srv_fd, conn_ret, inode, block_offset;
 
-	memset(block, 5, BLK_SIZE);
+	memset(block, 74, BLK_SIZE);
 	memset(buffer, 0, req_size);
 	inode = 7;
 	block_offset = 22;
@@ -104,11 +104,19 @@ int main()
 	memcpy(buffer, &get_rq, sizeof(get_rq));
 	wrote = write(srv_fd, buffer, req_size);
 	memset(buffer, 0, req_size);
-	read(srv_fd, buffer, BLK_SIZE);
+	int bytes_remaining = BLK_SIZE;
+	int b_rec;
+	while (bytes_remaining > 0) {
+		printf("bytes_remaining = %lu\n", bytes_remaining);
+		int start_byte = BLK_SIZE - bytes_remaining;
+		b_rec = recv(srv_fd, buffer + start_byte, BLK_SIZE, 0);
+		printf("received = %d\n", b_rec);
+		bytes_remaining -= b_rec;
+	}
 	int i, count;
 	count = 0;
 	for(i = 0; i < BLK_SIZE; i++) {
-		if (buffer[i] != 5) {
+		if (buffer[i] != 74) {
 			if (count == 0)
 				fprintf(stderr, "ERROR: expected to equal 5 not %d\n", buffer[i]);
 			count++;
@@ -121,7 +129,6 @@ int main()
 	close(srv_fd);
 
 	/* TEST CLFS_RM */
-	/*
 	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (srv_fd < 0) {
 		fprintf(stderr, "Error: Failed to create socket.\n");
@@ -145,6 +152,5 @@ int main()
 	printf("CLFS_RM response: %d\n", *((int *)buffer));
 
 	close(srv_fd);
-	*/
 	return 0;
 }
-- 
1.7.9.5


From 4de78dc0126e462ff88dd00c360300f48f36b5dc Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Mon, 22 Apr 2013 13:26:47 -0400
Subject: [PATCH 14/75] -corrected checkpatch errors.

---
 clfs/clfs_server.c      |   15 ++++++---------
 clfs/clfs_test_client.c |    2 +-
 2 files changed, 7 insertions(+), 10 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index b5cf53b..ae81891 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -71,7 +71,7 @@ enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 	char path[FILE_NAME_MAX];
 
 	size = req.size;
-	if (blk_buf == NULL){
+	if (blk_buf == NULL) {
 		fprintf(stderr, "Out of memory.\n");
 		exit(1);
 	}
@@ -146,20 +146,17 @@ void *handle_clfs_request(void *thread_fd)
 		read_succeed = 0;
 		while (bytes_remaining > 0) {
 			start_byte = req.size - bytes_remaining;
-			printf("start byte = %lu\n", start_byte);
-			bytes = recv(client_fd, block_buf + start_byte, req.size, 0);
+			bytes = recv(client_fd, block_buf + start_byte,
+					req.size, 0);
 			bytes_remaining -= bytes;
-			printf("read %lu bytes.\n", bytes);
-			printf("bytes_remaining = %lu\n", bytes_remaining);
 			if (bytes_remaining == 0)
 				read_succeed = 1;
 		}
-		if (read_succeed)
-		{
+		if (read_succeed) {
 			response = handle_put(req, block_buf);
 			write(client_fd, &response, sizeof(response));
 		} else {
-			fprintf(stderr, "Failed to read buffer from socket %lu, %d.\n", bytes, buf[0]);
+			fprintf(stderr, "Failed to read buffer from socket.\n");
 			response = CLFS_ERROR;
 			write(client_fd, &response, sizeof(response));
 		}
@@ -167,7 +164,7 @@ void *handle_clfs_request(void *thread_fd)
 		break;
 	case CLFS_GET:
 		ret_buf = malloc(req.size);
-		if (ret_buf == NULL){
+		if (ret_buf == NULL) {
 			fprintf(stderr, "Out of memory.\n");
 			exit(1);
 		}
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index b0a7a25..f5f2cbc 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -12,7 +12,7 @@
 #include "clfs.h"
 
 #define CLFS_PORT 8888
-#define BLK_SIZE 2048
+#define BLK_SIZE 6144
 
 int main()
 {
-- 
1.7.9.5


From 2db234f95d355b54c858d51378b7c33863fdb162 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Wed, 24 Apr 2013 18:50:56 -0400
Subject: [PATCH 15/75] -forgot to add clfs.h

---
 clfs/clfs.h |   19 +++++++++++++++++++
 1 file changed, 19 insertions(+)
 create mode 100644 clfs/clfs.h

diff --git a/clfs/clfs.h b/clfs/clfs.h
new file mode 100644
index 0000000..24257de
--- /dev/null
+++ b/clfs/clfs.h
@@ -0,0 +1,19 @@
+#define CLFS_PORT 8888
+#include <errno.h>
+
+struct clfs_req {
+	enum {
+		CLFS_PUT,
+		CLFS_GET,
+		CLFS_RM
+	} type;
+	int inode;
+	int size;
+};
+
+enum clfs_status {
+	CLFS_OK = 0,
+	CLFS_INVAL = EINVAL,
+	CLFS_ACCESS = EACCES,
+	CLFS_ERROR
+};
-- 
1.7.9.5


From b74aa532a0bd64165df0dad0aa10273c3d13d6cb Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Wed, 24 Apr 2013 20:21:11 -0400
Subject: [PATCH 16/75] -added ext2_evict.c -added ext2 config.  NOTE: This
 may not be correct.

---
 arch/x86/configs/goldfish_ext2_defconfig | 2250 ++++++++++++++++++++++++++++++
 fs/ext2/Makefile                         |    2 +-
 fs/ext2/ext2_evict.c                     |   12 +
 3 files changed, 2263 insertions(+), 1 deletion(-)
 create mode 100644 arch/x86/configs/goldfish_ext2_defconfig
 create mode 100644 fs/ext2/ext2_evict.c

diff --git a/arch/x86/configs/goldfish_ext2_defconfig b/arch/x86/configs/goldfish_ext2_defconfig
new file mode 100644
index 0000000..0a9ed68
--- /dev/null
+++ b/arch/x86/configs/goldfish_ext2_defconfig
@@ -0,0 +1,2250 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.29
+# Wed Apr 24 19:25:24 2013
+#
+# CONFIG_64BIT is not set
+CONFIG_X86_32=y
+# CONFIG_X86_64 is not set
+CONFIG_X86=y
+CONFIG_ARCH_DEFCONFIG="arch/x86/configs/i386_defconfig"
+CONFIG_GENERIC_TIME=y
+CONFIG_GENERIC_CMOS_UPDATE=y
+CONFIG_CLOCKSOURCE_WATCHDOG=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_FAST_CMPXCHG_LOCAL=y
+CONFIG_MMU=y
+CONFIG_ZONE_DMA=y
+CONFIG_GENERIC_ISA_DMA=y
+CONFIG_GENERIC_IOMAP=y
+CONFIG_GENERIC_BUG=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+# CONFIG_RWSEM_GENERIC_SPINLOCK is not set
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_ARCH_HAS_CPU_IDLE_WAIT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+# CONFIG_GENERIC_TIME_VSYSCALL is not set
+CONFIG_ARCH_HAS_CPU_RELAX=y
+CONFIG_ARCH_HAS_DEFAULT_IDLE=y
+CONFIG_ARCH_HAS_CACHE_LINE_SIZE=y
+# CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
+# CONFIG_HAVE_CPUMASK_OF_CPU_MAP is not set
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+# CONFIG_ZONE_DMA32 is not set
+CONFIG_ARCH_POPULATES_NODE_MAP=y
+# CONFIG_AUDIT_ARCH is not set
+CONFIG_ARCH_SUPPORTS_OPTIMIZED_INLINING=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_X86_BIOS_REBOOT=y
+CONFIG_KTIME_SCALAR=y
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_BSD_PROCESS_ACCT=y
+# CONFIG_BSD_PROCESS_ACCT_V3 is not set
+CONFIG_TASKSTATS=y
+CONFIG_TASK_DELAY_ACCT=y
+CONFIG_TASK_XACCT=y
+CONFIG_TASK_IO_ACCOUNTING=y
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_CLASSIC_RCU=y
+# CONFIG_TREE_RCU is not set
+# CONFIG_PREEMPT_RCU is not set
+# CONFIG_TREE_RCU_TRACE is not set
+# CONFIG_PREEMPT_RCU_TRACE is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_HAVE_UNSTABLE_SCHED_CLOCK=y
+CONFIG_GROUP_SCHED=y
+CONFIG_FAIR_GROUP_SCHED=y
+# CONFIG_RT_GROUP_SCHED is not set
+CONFIG_USER_SCHED=y
+# CONFIG_CGROUP_SCHED is not set
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+CONFIG_RELAY=y
+CONFIG_NAMESPACES=y
+CONFIG_UTS_NS=y
+CONFIG_IPC_NS=y
+CONFIG_USER_NS=y
+CONFIG_PID_NS=y
+# CONFIG_NET_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_PANIC_TIMEOUT=0
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+CONFIG_KALLSYMS_EXTRA_PASS=y
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_PCSPKR_PLATFORM=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ASHMEM=y
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_PCI_QUIRKS=y
+CONFIG_SLUB_DEBUG=y
+# CONFIG_COMPAT_BRK is not set
+# CONFIG_SLAB is not set
+CONFIG_SLUB=y
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_TRACEPOINTS=y
+CONFIG_MARKERS=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_KPROBES=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_KRETPROBES=y
+CONFIG_HAVE_IOREMAP_PROT=y
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+# CONFIG_MODULE_FORCE_LOAD is not set
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+# CONFIG_LBD is not set
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_AS is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_FREEZER=y
+
+#
+# Processor type and features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+# CONFIG_SMP is not set
+CONFIG_ARCH_GOLDFISH=y
+# CONFIG_X86_PC is not set
+CONFIG_X86_GOLDFISH=y
+# CONFIG_X86_ELAN is not set
+# CONFIG_X86_VOYAGER is not set
+# CONFIG_X86_GENERICARCH is not set
+# CONFIG_X86_VSMP is not set
+# CONFIG_X86_RDC321X is not set
+CONFIG_SCHED_OMIT_FRAME_POINTER=y
+# CONFIG_PARAVIRT_GUEST is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_M386 is not set
+# CONFIG_M486 is not set
+# CONFIG_M586 is not set
+# CONFIG_M586TSC is not set
+# CONFIG_M586MMX is not set
+# CONFIG_M686 is not set
+# CONFIG_MPENTIUMII is not set
+# CONFIG_MPENTIUMIII is not set
+# CONFIG_MPENTIUMM is not set
+# CONFIG_MPENTIUM4 is not set
+# CONFIG_MK6 is not set
+# CONFIG_MK7 is not set
+# CONFIG_MK8 is not set
+# CONFIG_MCRUSOE is not set
+# CONFIG_MEFFICEON is not set
+# CONFIG_MWINCHIPC6 is not set
+# CONFIG_MWINCHIP3D is not set
+# CONFIG_MGEODEGX1 is not set
+# CONFIG_MGEODE_LX is not set
+# CONFIG_MCYRIXIII is not set
+# CONFIG_MVIAC3_2 is not set
+# CONFIG_MVIAC7 is not set
+# CONFIG_MPSC is not set
+CONFIG_MCORE2=y
+# CONFIG_GENERIC_CPU is not set
+CONFIG_X86_GENERIC=y
+CONFIG_X86_CPU=y
+CONFIG_X86_CMPXCHG=y
+CONFIG_X86_L1_CACHE_SHIFT=7
+CONFIG_X86_XADD=y
+CONFIG_X86_WP_WORKS_OK=y
+CONFIG_X86_INVLPG=y
+CONFIG_X86_BSWAP=y
+CONFIG_X86_POPAD_OK=y
+CONFIG_X86_INTEL_USERCOPY=y
+CONFIG_X86_USE_PPRO_CHECKSUM=y
+CONFIG_X86_TSC=y
+CONFIG_X86_CMOV=y
+CONFIG_X86_MINIMUM_CPU_FAMILY=4
+CONFIG_X86_DEBUGCTLMSR=y
+CONFIG_CPU_SUP_INTEL=y
+CONFIG_CPU_SUP_CYRIX_32=y
+CONFIG_CPU_SUP_AMD=y
+CONFIG_CPU_SUP_CENTAUR_32=y
+CONFIG_CPU_SUP_TRANSMETA_32=y
+CONFIG_CPU_SUP_UMC_32=y
+# CONFIG_X86_DS is not set
+# CONFIG_X86_PTRACE_BTS is not set
+CONFIG_HPET_TIMER=y
+CONFIG_HPET_EMULATE_RTC=y
+CONFIG_DMI=y
+# CONFIG_IOMMU_HELPER is not set
+# CONFIG_IOMMU_API is not set
+CONFIG_NR_CPUS=1
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+# CONFIG_X86_UP_APIC is not set
+# CONFIG_X86_MCE is not set
+CONFIG_VM86=y
+# CONFIG_TOSHIBA is not set
+# CONFIG_I8K is not set
+CONFIG_X86_REBOOTFIXUPS=y
+# CONFIG_MICROCODE is not set
+CONFIG_X86_MSR=y
+CONFIG_X86_CPUID=y
+CONFIG_NOHIGHMEM=y
+# CONFIG_HIGHMEM4G is not set
+# CONFIG_HIGHMEM64G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_X86_PAE is not set
+# CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=1
+CONFIG_BOUNCE=y
+CONFIG_VIRT_TO_BUS=y
+CONFIG_UNEVICTABLE_LRU=y
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+# CONFIG_X86_CHECK_BIOS_CORRUPTION is not set
+CONFIG_X86_RESERVE_LOW_64K=y
+# CONFIG_MATH_EMULATION is not set
+CONFIG_MTRR=y
+# CONFIG_MTRR_SANITIZER is not set
+CONFIG_X86_PAT=y
+# CONFIG_EFI is not set
+CONFIG_SECCOMP=y
+CONFIG_HZ_100=y
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
+# CONFIG_KEXEC is not set
+CONFIG_PHYSICAL_START=0x100000
+# CONFIG_RELOCATABLE is not set
+CONFIG_PHYSICAL_ALIGN=0x200000
+# CONFIG_COMPAT_VDSO is not set
+# CONFIG_CMDLINE_BOOL is not set
+
+#
+# Power management and ACPI options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_HAS_WAKELOCK=y
+CONFIG_HAS_EARLYSUSPEND=y
+CONFIG_WAKELOCK=y
+CONFIG_WAKELOCK_STAT=y
+CONFIG_USER_WAKELOCK=y
+CONFIG_EARLYSUSPEND=y
+# CONFIG_NO_USER_SPACE_SCREEN_ACCESS_CONTROL is not set
+# CONFIG_CONSOLE_EARLYSUSPEND is not set
+CONFIG_FB_EARLYSUSPEND=y
+# CONFIG_HIBERNATION is not set
+CONFIG_ACPI=y
+CONFIG_ACPI_SLEEP=y
+# CONFIG_ACPI_PROCFS is not set
+CONFIG_ACPI_PROCFS_POWER=y
+CONFIG_ACPI_SYSFS_POWER=y
+CONFIG_ACPI_PROC_EVENT=y
+CONFIG_ACPI_AC=y
+CONFIG_ACPI_BATTERY=y
+CONFIG_ACPI_BUTTON=y
+CONFIG_ACPI_FAN=y
+CONFIG_ACPI_DOCK=y
+CONFIG_ACPI_PROCESSOR=y
+CONFIG_ACPI_THERMAL=y
+# CONFIG_ACPI_CUSTOM_DSDT is not set
+CONFIG_ACPI_BLACKLIST_YEAR=0
+# CONFIG_ACPI_DEBUG is not set
+# CONFIG_ACPI_PCI_SLOT is not set
+CONFIG_X86_PM_TIMER=y
+# CONFIG_ACPI_CONTAINER is not set
+# CONFIG_ACPI_SBS is not set
+# CONFIG_APM is not set
+
+#
+# CPU Frequency scaling
+#
+CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_TABLE=y
+CONFIG_CPU_FREQ_DEBUG=y
+# CONFIG_CPU_FREQ_STAT is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_GOV_POWERSAVE is not set
+CONFIG_CPU_FREQ_GOV_USERSPACE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
+# CONFIG_CPU_FREQ_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_MIN_TICKS=10
+CONFIG_CPU_FREQ_SAMPLING_LATENCY_MULTIPLIER=1000
+
+#
+# CPUFreq processor drivers
+#
+# CONFIG_X86_ACPI_CPUFREQ is not set
+# CONFIG_X86_POWERNOW_K6 is not set
+# CONFIG_X86_POWERNOW_K7 is not set
+# CONFIG_X86_POWERNOW_K8 is not set
+# CONFIG_X86_GX_SUSPMOD is not set
+# CONFIG_X86_SPEEDSTEP_CENTRINO is not set
+# CONFIG_X86_SPEEDSTEP_ICH is not set
+# CONFIG_X86_SPEEDSTEP_SMI is not set
+# CONFIG_X86_P4_CLOCKMOD is not set
+# CONFIG_X86_CPUFREQ_NFORCE2 is not set
+# CONFIG_X86_LONGRUN is not set
+# CONFIG_X86_LONGHAUL is not set
+# CONFIG_X86_E_POWERSAVER is not set
+
+#
+# shared options
+#
+# CONFIG_X86_SPEEDSTEP_LIB is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Bus options (PCI etc.)
+#
+CONFIG_PCI=y
+# CONFIG_PCI_GOBIOS is not set
+# CONFIG_PCI_GOMMCONFIG is not set
+# CONFIG_PCI_GODIRECT is not set
+# CONFIG_PCI_GOOLPC is not set
+CONFIG_PCI_GOANY=y
+CONFIG_PCI_BIOS=y
+CONFIG_PCI_DIRECT=y
+CONFIG_PCI_MMCONFIG=y
+CONFIG_PCI_DOMAINS=y
+CONFIG_PCIEPORTBUS=y
+# CONFIG_HOTPLUG_PCI_PCIE is not set
+CONFIG_PCIEAER=y
+# CONFIG_PCIEASPM is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCI_LEGACY is not set
+# CONFIG_PCI_STUB is not set
+CONFIG_ISA_DMA_API=y
+# CONFIG_ISA is not set
+# CONFIG_MCA is not set
+# CONFIG_SCx200 is not set
+# CONFIG_OLPC is not set
+CONFIG_K8_NB=y
+CONFIG_PCCARD=y
+# CONFIG_PCMCIA_DEBUG is not set
+CONFIG_PCMCIA=y
+CONFIG_PCMCIA_LOAD_CIS=y
+CONFIG_PCMCIA_IOCTL=y
+CONFIG_CARDBUS=y
+
+#
+# PC-card bridges
+#
+CONFIG_YENTA=y
+CONFIG_YENTA_O2=y
+CONFIG_YENTA_RICOH=y
+CONFIG_YENTA_TI=y
+CONFIG_YENTA_ENE_TUNE=y
+CONFIG_YENTA_TOSHIBA=y
+# CONFIG_PD6729 is not set
+# CONFIG_I82092 is not set
+CONFIG_PCCARD_NONSTATIC=y
+CONFIG_HOTPLUG_PCI=y
+# CONFIG_HOTPLUG_PCI_FAKE is not set
+# CONFIG_HOTPLUG_PCI_ACPI is not set
+# CONFIG_HOTPLUG_PCI_CPCI is not set
+# CONFIG_HOTPLUG_PCI_SHPC is not set
+
+#
+# Executable file formats / Emulations
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+CONFIG_BINFMT_MISC=y
+CONFIG_HAVE_ATOMIC_IOMAP=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_COMPAT_NET_DEV_OPS=y
+CONFIG_PACKET=y
+CONFIG_PACKET_MMAP=y
+CONFIG_UNIX=y
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+CONFIG_NET_KEY=y
+# CONFIG_NET_KEY_MIGRATE is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_ASK_IP_FIB_HASH=y
+# CONFIG_IP_FIB_TRIE is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_ROUTE_VERBOSE=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+CONFIG_IP_MROUTE=y
+CONFIG_IP_PIMSM_V1=y
+CONFIG_IP_PIMSM_V2=y
+# CONFIG_ARPD is not set
+CONFIG_SYN_COOKIES=y
+# CONFIG_INET_AH is not set
+CONFIG_INET_ESP=y
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+# CONFIG_INET_XFRM_MODE_BEET is not set
+CONFIG_INET_LRO=y
+# CONFIG_INET_DIAG is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_PRIVACY is not set
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+# CONFIG_INET6_XFRM_TUNNEL is not set
+# CONFIG_INET6_TUNNEL is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+CONFIG_IPV6_SIT=y
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+CONFIG_NETLABEL=y
+CONFIG_ANDROID_PARANOID_NETWORK=y
+CONFIG_NETWORK_SECMARK=y
+CONFIG_NETFILTER=y
+# CONFIG_NETFILTER_DEBUG is not set
+# CONFIG_NETFILTER_ADVANCED is not set
+
+#
+# Core Netfilter Configuration
+#
+CONFIG_NETFILTER_NETLINK=y
+CONFIG_NETFILTER_NETLINK_LOG=y
+CONFIG_NF_CONNTRACK=y
+CONFIG_NF_CONNTRACK_SECMARK=y
+CONFIG_NF_CONNTRACK_FTP=y
+CONFIG_NF_CONNTRACK_IRC=y
+CONFIG_NF_CONNTRACK_SIP=y
+CONFIG_NF_CT_NETLINK=y
+CONFIG_NETFILTER_XTABLES=y
+CONFIG_NETFILTER_XT_TARGET_CONNSECMARK=y
+CONFIG_NETFILTER_XT_TARGET_MARK=y
+CONFIG_NETFILTER_XT_TARGET_NFLOG=y
+CONFIG_NETFILTER_XT_TARGET_SECMARK=y
+CONFIG_NETFILTER_XT_TARGET_TCPMSS=y
+CONFIG_NETFILTER_XT_MATCH_CONNTRACK=y
+CONFIG_NETFILTER_XT_MATCH_MARK=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=m
+CONFIG_NETFILTER_XT_MATCH_STATE=y
+# CONFIG_IP_VS is not set
+
+#
+# IP: Netfilter Configuration
+#
+CONFIG_NF_DEFRAG_IPV4=y
+CONFIG_NF_CONNTRACK_IPV4=y
+CONFIG_NF_CONNTRACK_PROC_COMPAT=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_TARGET_LOG=y
+CONFIG_IP_NF_TARGET_ULOG=y
+CONFIG_NF_NAT=y
+CONFIG_NF_NAT_NEEDED=y
+CONFIG_IP_NF_TARGET_MASQUERADE=y
+CONFIG_NF_NAT_FTP=y
+CONFIG_NF_NAT_IRC=y
+# CONFIG_NF_NAT_TFTP is not set
+# CONFIG_NF_NAT_AMANDA is not set
+# CONFIG_NF_NAT_PPTP is not set
+# CONFIG_NF_NAT_H323 is not set
+CONFIG_NF_NAT_SIP=y
+CONFIG_IP_NF_MANGLE=y
+
+#
+# IPv6: Netfilter Configuration
+#
+CONFIG_NF_CONNTRACK_IPV6=m
+CONFIG_IP6_NF_IPTABLES=m
+CONFIG_IP6_NF_MATCH_IPV6HEADER=m
+CONFIG_IP6_NF_TARGET_LOG=m
+CONFIG_IP6_NF_FILTER=m
+CONFIG_IP6_NF_TARGET_REJECT=m
+CONFIG_IP6_NF_MANGLE=m
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+CONFIG_LLC=y
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NET_TCPPROBE is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_PHONET is not set
+CONFIG_FIB_RULES=y
+CONFIG_WIRELESS=y
+CONFIG_CFG80211=y
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_NL80211=y
+CONFIG_WIRELESS_OLD_REGULATORY=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+# CONFIG_LIB80211 is not set
+CONFIG_MAC80211=y
+
+#
+# Rate control algorithm selection
+#
+CONFIG_MAC80211_RC_MINSTREL=y
+# CONFIG_MAC80211_RC_DEFAULT_PID is not set
+CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+CONFIG_MAC80211_RC_DEFAULT="minstrel"
+# CONFIG_MAC80211_MESH is not set
+CONFIG_MAC80211_LEDS=y
+# CONFIG_MAC80211_DEBUGFS is not set
+# CONFIG_MAC80211_DEBUG_MENU is not set
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+CONFIG_CONNECTOR=y
+CONFIG_PROC_EVENTS=y
+CONFIG_MTD=y
+CONFIG_MTD_DEBUG=y
+CONFIG_MTD_DEBUG_VERBOSE=0
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_TESTS is not set
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+# CONFIG_MTD_CHAR is not set
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+CONFIG_NFTL=y
+# CONFIG_NFTL_RW is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_TS5500 is not set
+# CONFIG_MTD_INTEL_VR_NOR is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_PMC551 is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_GOLDFISH_NAND=y
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_NAND_ECC_SMC is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+# CONFIG_MTD_NAND_CAFE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+CONFIG_MTD_NAND_PLATFORM=y
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+# CONFIG_MTD_UBI is not set
+# CONFIG_PARPORT is not set
+CONFIG_PNP=y
+CONFIG_PNP_DEBUG_MESSAGES=y
+
+#
+# Protocols
+#
+CONFIG_PNPACPI=y
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_SX8 is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=16
+CONFIG_BLK_DEV_RAM_SIZE=16384
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_HD is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_ANDROID_PMEM is not set
+# CONFIG_IBM_ASM is not set
+# CONFIG_PHANTOM is not set
+# CONFIG_SGI_IOC4 is not set
+# CONFIG_TIFM_CORE is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_KERNEL_DEBUGGER_CORE is not set
+# CONFIG_HP_ILO is not set
+# CONFIG_UID_STAT is not set
+# CONFIG_QEMU_TRACE is not set
+CONFIG_QEMU_PIPE=y
+# CONFIG_APANIC is not set
+CONFIG_APANIC_PLABEL="kpanic"
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_93CX6 is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=y
+CONFIG_BLK_DEV_SR_VENDOR=y
+CONFIG_CHR_DEV_SG=y
+# CONFIG_CHR_DEV_SCH is not set
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+# CONFIG_SCSI_MULTI_LUN is not set
+CONFIG_SCSI_CONSTANTS=y
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+CONFIG_SCSI_SPI_ATTRS=y
+# CONFIG_SCSI_FC_ATTRS is not set
+CONFIG_SCSI_ISCSI_ATTRS=y
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_LOWLEVEL_PCMCIA is not set
+# CONFIG_SCSI_DH is not set
+CONFIG_ATA=y
+# CONFIG_ATA_NONSTANDARD is not set
+CONFIG_ATA_ACPI=y
+CONFIG_SATA_PMP=y
+CONFIG_SATA_AHCI=y
+# CONFIG_SATA_SIL24 is not set
+CONFIG_ATA_SFF=y
+# CONFIG_SATA_SVW is not set
+CONFIG_ATA_PIIX=y
+# CONFIG_SATA_MV is not set
+# CONFIG_SATA_NV is not set
+# CONFIG_PDC_ADMA is not set
+# CONFIG_SATA_QSTOR is not set
+# CONFIG_SATA_PROMISE is not set
+# CONFIG_SATA_SX4 is not set
+# CONFIG_SATA_SIL is not set
+# CONFIG_SATA_SIS is not set
+# CONFIG_SATA_ULI is not set
+# CONFIG_SATA_VIA is not set
+# CONFIG_SATA_VITESSE is not set
+# CONFIG_SATA_INIC162X is not set
+# CONFIG_PATA_ACPI is not set
+# CONFIG_PATA_ALI is not set
+CONFIG_PATA_AMD=y
+# CONFIG_PATA_ARTOP is not set
+# CONFIG_PATA_ATIIXP is not set
+# CONFIG_PATA_CMD640_PCI is not set
+# CONFIG_PATA_CMD64X is not set
+# CONFIG_PATA_CS5520 is not set
+# CONFIG_PATA_CS5530 is not set
+# CONFIG_PATA_CS5535 is not set
+# CONFIG_PATA_CS5536 is not set
+# CONFIG_PATA_CYPRESS is not set
+# CONFIG_PATA_EFAR is not set
+CONFIG_ATA_GENERIC=y
+# CONFIG_PATA_HPT366 is not set
+# CONFIG_PATA_HPT37X is not set
+# CONFIG_PATA_HPT3X2N is not set
+# CONFIG_PATA_HPT3X3 is not set
+# CONFIG_PATA_IT821X is not set
+# CONFIG_PATA_IT8213 is not set
+# CONFIG_PATA_JMICRON is not set
+# CONFIG_PATA_TRIFLEX is not set
+# CONFIG_PATA_MARVELL is not set
+CONFIG_PATA_MPIIX=y
+CONFIG_PATA_OLDPIIX=y
+# CONFIG_PATA_NETCELL is not set
+# CONFIG_PATA_NINJA32 is not set
+# CONFIG_PATA_NS87410 is not set
+# CONFIG_PATA_NS87415 is not set
+# CONFIG_PATA_OPTI is not set
+# CONFIG_PATA_OPTIDMA is not set
+# CONFIG_PATA_PCMCIA is not set
+# CONFIG_PATA_PDC_OLD is not set
+# CONFIG_PATA_RADISYS is not set
+# CONFIG_PATA_RZ1000 is not set
+# CONFIG_PATA_SC1200 is not set
+# CONFIG_PATA_SERVERWORKS is not set
+# CONFIG_PATA_PDC2027X is not set
+# CONFIG_PATA_SIL680 is not set
+# CONFIG_PATA_SIS is not set
+# CONFIG_PATA_VIA is not set
+# CONFIG_PATA_WINBOND is not set
+CONFIG_PATA_SCH=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_MD=y
+CONFIG_MD_AUTODETECT=y
+# CONFIG_MD_LINEAR is not set
+# CONFIG_MD_RAID0 is not set
+# CONFIG_MD_RAID1 is not set
+# CONFIG_MD_RAID10 is not set
+# CONFIG_MD_RAID456 is not set
+# CONFIG_MD_MULTIPATH is not set
+# CONFIG_MD_FAULTY is not set
+CONFIG_BLK_DEV_DM=y
+# CONFIG_DM_DEBUG is not set
+# CONFIG_DM_CRYPT is not set
+# CONFIG_DM_SNAPSHOT is not set
+CONFIG_DM_MIRROR=y
+CONFIG_DM_ZERO=y
+# CONFIG_DM_MULTIPATH is not set
+# CONFIG_DM_DELAY is not set
+# CONFIG_DM_UEVENT is not set
+# CONFIG_FUSION is not set
+
+#
+# IEEE 1394 (FireWire) support
+#
+
+#
+# Enable only one of the two stacks, unless you know what you are doing
+#
+# CONFIG_FIREWIRE is not set
+# CONFIG_IEEE1394 is not set
+# CONFIG_I2O is not set
+# CONFIG_MACINTOSH_DRIVERS is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+CONFIG_TUN=y
+# CONFIG_VETH is not set
+# CONFIG_NET_SB1000 is not set
+# CONFIG_ARCNET is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_CASSINI is not set
+CONFIG_NET_VENDOR_3COM=y
+# CONFIG_VORTEX is not set
+# CONFIG_TYPHOON is not set
+# CONFIG_DNET is not set
+CONFIG_NET_TULIP=y
+# CONFIG_DE2104X is not set
+# CONFIG_TULIP is not set
+# CONFIG_DE4X5 is not set
+# CONFIG_WINBOND_840 is not set
+# CONFIG_DM9102 is not set
+# CONFIG_ULI526X is not set
+# CONFIG_PCMCIA_XIRCOM is not set
+# CONFIG_HP100 is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+CONFIG_NET_PCI=y
+# CONFIG_PCNET32 is not set
+# CONFIG_AMD8111_ETH is not set
+# CONFIG_ADAPTEC_STARFIRE is not set
+# CONFIG_B44 is not set
+CONFIG_FORCEDETH=y
+# CONFIG_FORCEDETH_NAPI is not set
+CONFIG_E100=y
+# CONFIG_FEALNX is not set
+# CONFIG_NATSEMI is not set
+CONFIG_NE2K_PCI=y
+# CONFIG_8139CP is not set
+CONFIG_8139TOO=y
+# CONFIG_8139TOO_PIO is not set
+# CONFIG_8139TOO_TUNE_TWISTER is not set
+# CONFIG_8139TOO_8129 is not set
+# CONFIG_8139_OLD_RX_RESET is not set
+# CONFIG_R6040 is not set
+# CONFIG_SIS900 is not set
+# CONFIG_EPIC100 is not set
+# CONFIG_SMSC9420 is not set
+# CONFIG_SUNDANCE is not set
+# CONFIG_TLAN is not set
+# CONFIG_VIA_RHINE is not set
+# CONFIG_SC92031 is not set
+# CONFIG_ATL2 is not set
+CONFIG_NETDEV_1000=y
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+CONFIG_E1000=y
+CONFIG_E1000E=y
+# CONFIG_IP1000 is not set
+# CONFIG_IGB is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+CONFIG_R8169=y
+# CONFIG_SIS190 is not set
+# CONFIG_SKGE is not set
+CONFIG_SKY2=y
+# CONFIG_SKY2_DEBUG is not set
+# CONFIG_VIA_VELOCITY is not set
+CONFIG_TIGON3=y
+CONFIG_BNX2=y
+# CONFIG_QLA3XXX is not set
+# CONFIG_ATL1 is not set
+# CONFIG_ATL1E is not set
+# CONFIG_ATL1C is not set
+# CONFIG_JME is not set
+CONFIG_NETDEV_10000=y
+# CONFIG_CHELSIO_T1 is not set
+CONFIG_CHELSIO_T3_DEPENDS=y
+# CONFIG_CHELSIO_T3 is not set
+# CONFIG_ENIC is not set
+# CONFIG_IXGBE is not set
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+# CONFIG_MYRI10GE is not set
+# CONFIG_NETXEN_NIC is not set
+# CONFIG_NIU is not set
+# CONFIG_MLX4_EN is not set
+# CONFIG_MLX4_CORE is not set
+# CONFIG_TEHUTI is not set
+# CONFIG_BNX2X is not set
+# CONFIG_QLGE is not set
+# CONFIG_SFC is not set
+# CONFIG_BE2NET is not set
+CONFIG_TR=y
+# CONFIG_IBMOL is not set
+# CONFIG_IBMLS is not set
+# CONFIG_3C359 is not set
+# CONFIG_TMS380TR is not set
+
+#
+# Wireless LAN
+#
+# CONFIG_WLAN_PRE80211 is not set
+CONFIG_WLAN_80211=y
+# CONFIG_PCMCIA_RAYCS is not set
+# CONFIG_LIBERTAS is not set
+# CONFIG_LIBERTAS_THINFIRM is not set
+# CONFIG_AIRO is not set
+# CONFIG_HERMES is not set
+# CONFIG_ATMEL is not set
+# CONFIG_AIRO_CS is not set
+# CONFIG_PCMCIA_WL3501 is not set
+# CONFIG_PRISM54 is not set
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_RTL8180 is not set
+# CONFIG_RTL8187 is not set
+# CONFIG_ADM8211 is not set
+# CONFIG_MAC80211_HWSIM is not set
+# CONFIG_P54_COMMON is not set
+CONFIG_ATH5K=y
+# CONFIG_ATH5K_DEBUG is not set
+# CONFIG_ATH9K is not set
+# CONFIG_IPW2100 is not set
+# CONFIG_IPW2200 is not set
+# CONFIG_IWLCORE is not set
+# CONFIG_IWLWIFI_LEDS is not set
+# CONFIG_IWLAGN is not set
+# CONFIG_IWL3945 is not set
+# CONFIG_HOSTAP is not set
+# CONFIG_B43 is not set
+# CONFIG_B43LEGACY is not set
+# CONFIG_ZD1211RW is not set
+# CONFIG_RT2X00 is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+CONFIG_NET_PCMCIA=y
+# CONFIG_PCMCIA_3C589 is not set
+# CONFIG_PCMCIA_3C574 is not set
+# CONFIG_PCMCIA_FMVJ18X is not set
+# CONFIG_PCMCIA_PCNET is not set
+# CONFIG_PCMCIA_NMCLAN is not set
+# CONFIG_PCMCIA_SMC91C92 is not set
+# CONFIG_PCMCIA_XIRC2PS is not set
+# CONFIG_PCMCIA_AXNET is not set
+# CONFIG_PCMCIA_IBMTR is not set
+# CONFIG_WAN is not set
+CONFIG_FDDI=y
+# CONFIG_DEFXX is not set
+# CONFIG_SKFP is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NET_FC is not set
+CONFIG_NETCONSOLE=y
+# CONFIG_NETCONSOLE_DYNAMIC is not set
+CONFIG_NETPOLL=y
+# CONFIG_NETPOLL_TRAP is not set
+CONFIG_NET_POLL_CONTROLLER=y
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_FF_MEMLESS=y
+CONFIG_INPUT_POLLDEV=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+# CONFIG_INPUT_KEYRESET is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+CONFIG_KEYBOARD_ATKBD=y
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+CONFIG_KEYBOARD_GOLDFISH_EVENTS=y
+# CONFIG_INPUT_MOUSE is not set
+CONFIG_INPUT_JOYSTICK=y
+# CONFIG_JOYSTICK_ANALOG is not set
+# CONFIG_JOYSTICK_A3D is not set
+# CONFIG_JOYSTICK_ADI is not set
+# CONFIG_JOYSTICK_COBRA is not set
+# CONFIG_JOYSTICK_GF2K is not set
+# CONFIG_JOYSTICK_GRIP is not set
+# CONFIG_JOYSTICK_GRIP_MP is not set
+# CONFIG_JOYSTICK_GUILLEMOT is not set
+# CONFIG_JOYSTICK_INTERACT is not set
+# CONFIG_JOYSTICK_SIDEWINDER is not set
+# CONFIG_JOYSTICK_TMDC is not set
+# CONFIG_JOYSTICK_IFORCE is not set
+# CONFIG_JOYSTICK_WARRIOR is not set
+# CONFIG_JOYSTICK_MAGELLAN is not set
+# CONFIG_JOYSTICK_SPACEORB is not set
+# CONFIG_JOYSTICK_SPACEBALL is not set
+# CONFIG_JOYSTICK_STINGER is not set
+# CONFIG_JOYSTICK_TWIDJOY is not set
+# CONFIG_JOYSTICK_ZHENHUA is not set
+# CONFIG_JOYSTICK_JOYDUMP is not set
+# CONFIG_JOYSTICK_XPAD is not set
+CONFIG_INPUT_TABLET=y
+# CONFIG_TABLET_USB_ACECAD is not set
+# CONFIG_TABLET_USB_AIPTEK is not set
+# CONFIG_TABLET_USB_GTCO is not set
+# CONFIG_TABLET_USB_KBTAB is not set
+# CONFIG_TABLET_USB_WACOM is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_SYNAPTICS_I2C_RMI is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_PCSPKR is not set
+# CONFIG_INPUT_APANEL is not set
+# CONFIG_INPUT_WISTRON_BTNS is not set
+# CONFIG_INPUT_ATLAS_BTNS is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_GPIO is not set
+# CONFIG_INPUT_KEYCHORD is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+CONFIG_SERIO_LIBPS2=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVMEM=y
+CONFIG_DEVKMEM=y
+CONFIG_SERIAL_NONSTANDARD=y
+# CONFIG_COMPUTONE is not set
+# CONFIG_ROCKETPORT is not set
+# CONFIG_CYCLADES is not set
+# CONFIG_DIGIEPCA is not set
+# CONFIG_MOXA_INTELLIO is not set
+# CONFIG_MOXA_SMARTIO is not set
+# CONFIG_ISI is not set
+# CONFIG_SYNCLINK is not set
+# CONFIG_SYNCLINKMP is not set
+# CONFIG_SYNCLINK_GT is not set
+# CONFIG_N_HDLC is not set
+# CONFIG_RISCOM8 is not set
+# CONFIG_SPECIALIX is not set
+# CONFIG_SX is not set
+# CONFIG_RIO is not set
+# CONFIG_STALDRV is not set
+# CONFIG_NOZOMI is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+CONFIG_FIX_EARLYCON_MEM=y
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_JSM is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+# CONFIG_LEGACY_PTYS is not set
+# CONFIG_IPMI_HANDLER is not set
+CONFIG_HW_RANDOM=y
+CONFIG_HW_RANDOM_INTEL=y
+CONFIG_HW_RANDOM_AMD=y
+CONFIG_HW_RANDOM_GEODE=y
+CONFIG_HW_RANDOM_VIA=y
+CONFIG_NVRAM=y
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+# CONFIG_SONYPI is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_CARDMAN_4000 is not set
+# CONFIG_CARDMAN_4040 is not set
+# CONFIG_IPWIRELESS is not set
+# CONFIG_MWAVE is not set
+# CONFIG_PC8736x_GPIO is not set
+# CONFIG_NSC_GPIO is not set
+# CONFIG_CS5535_GPIO is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_HPET is not set
+# CONFIG_HANGCHECK_TIMER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_TELCLOCK is not set
+CONFIG_DEVPORT=y
+CONFIG_GOLDFISH_TTY=y
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# PC SMBus host controller drivers
+#
+# CONFIG_I2C_ALI1535 is not set
+# CONFIG_I2C_ALI1563 is not set
+# CONFIG_I2C_ALI15X3 is not set
+# CONFIG_I2C_AMD756 is not set
+# CONFIG_I2C_AMD8111 is not set
+CONFIG_I2C_I801=y
+# CONFIG_I2C_ISCH is not set
+# CONFIG_I2C_PIIX4 is not set
+# CONFIG_I2C_NFORCE2 is not set
+# CONFIG_I2C_SIS5595 is not set
+# CONFIG_I2C_SIS630 is not set
+# CONFIG_I2C_SIS96X is not set
+# CONFIG_I2C_VIA is not set
+# CONFIG_I2C_VIAPRO is not set
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_SIMTEC is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Graphics adapter I2C/DDC channel drivers
+#
+# CONFIG_I2C_VOODOO3 is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_STUB is not set
+# CONFIG_SCx200_ACB is not set
+
+#
+# Miscellaneous I2C Chip support
+#
+# CONFIG_DS1682 is not set
+# CONFIG_SENSORS_PCF8574 is not set
+# CONFIG_PCF8575 is not set
+# CONFIG_SENSORS_PCA9539 is not set
+# CONFIG_SENSORS_PCF8591 is not set
+# CONFIG_SENSORS_MAX6875 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_PCA963X is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_I2C_DEBUG_CHIP is not set
+# CONFIG_SPI is not set
+CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+# CONFIG_GPIOLIB is not set
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+CONFIG_BATTERY_GOLDFISH=y
+# CONFIG_HWMON is not set
+CONFIG_THERMAL=y
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_ACQUIRE_WDT is not set
+# CONFIG_ADVANTECH_WDT is not set
+# CONFIG_ALIM1535_WDT is not set
+# CONFIG_ALIM7101_WDT is not set
+# CONFIG_SC520_WDT is not set
+# CONFIG_EUROTECH_WDT is not set
+# CONFIG_IB700_WDT is not set
+# CONFIG_IBMASR is not set
+# CONFIG_WAFER_WDT is not set
+# CONFIG_I6300ESB_WDT is not set
+# CONFIG_ITCO_WDT is not set
+# CONFIG_IT8712F_WDT is not set
+# CONFIG_IT87_WDT is not set
+# CONFIG_HP_WATCHDOG is not set
+# CONFIG_SC1200_WDT is not set
+# CONFIG_PC87413_WDT is not set
+# CONFIG_60XX_WDT is not set
+# CONFIG_SBC8360_WDT is not set
+# CONFIG_SBC7240_WDT is not set
+# CONFIG_CPU5_WDT is not set
+# CONFIG_SMSC_SCH311X_WDT is not set
+# CONFIG_SMSC37B787_WDT is not set
+# CONFIG_W83627HF_WDT is not set
+# CONFIG_W83697HF_WDT is not set
+# CONFIG_W83697UG_WDT is not set
+# CONFIG_W83877F_WDT is not set
+# CONFIG_W83977F_WDT is not set
+# CONFIG_MACHZ_WDT is not set
+# CONFIG_SBC_EPX_C3_WATCHDOG is not set
+
+#
+# PCI-based Watchdog Cards
+#
+# CONFIG_PCIPCWATCHDOG is not set
+# CONFIG_WDTPCI is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+
+#
+# Multifunction device drivers
+#
+# CONFIG_MFD_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_MFD_TMIO is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_REGULATOR is not set
+
+#
+# Multimedia devices
+#
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+CONFIG_DAB=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+CONFIG_AGP=y
+# CONFIG_AGP_ALI is not set
+# CONFIG_AGP_ATI is not set
+# CONFIG_AGP_AMD is not set
+CONFIG_AGP_AMD64=y
+CONFIG_AGP_INTEL=y
+# CONFIG_AGP_NVIDIA is not set
+# CONFIG_AGP_SIS is not set
+# CONFIG_AGP_SWORKS is not set
+# CONFIG_AGP_VIA is not set
+# CONFIG_AGP_EFFICEON is not set
+CONFIG_DRM=y
+# CONFIG_DRM_TDFX is not set
+# CONFIG_DRM_R128 is not set
+# CONFIG_DRM_RADEON is not set
+# CONFIG_DRM_I810 is not set
+# CONFIG_DRM_I830 is not set
+CONFIG_DRM_I915=y
+# CONFIG_DRM_I915_KMS is not set
+# CONFIG_DRM_MGA is not set
+# CONFIG_DRM_SIS is not set
+# CONFIG_DRM_VIA is not set
+# CONFIG_DRM_SAVAGE is not set
+# CONFIG_VGASTATE is not set
+# CONFIG_VIDEO_OUTPUT_CONTROL is not set
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_CIRRUS is not set
+# CONFIG_FB_PM2 is not set
+# CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ARC is not set
+# CONFIG_FB_ASILIANT is not set
+# CONFIG_FB_IMSTT is not set
+# CONFIG_FB_VGA16 is not set
+# CONFIG_FB_UVESA is not set
+# CONFIG_FB_VESA is not set
+# CONFIG_FB_N411 is not set
+# CONFIG_FB_HGA is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_NVIDIA is not set
+# CONFIG_FB_RIVA is not set
+# CONFIG_FB_I810 is not set
+# CONFIG_FB_LE80578 is not set
+# CONFIG_FB_INTEL is not set
+# CONFIG_FB_MATROX is not set
+# CONFIG_FB_RADEON is not set
+# CONFIG_FB_ATY128 is not set
+# CONFIG_FB_ATY is not set
+# CONFIG_FB_S3 is not set
+# CONFIG_FB_SAVAGE is not set
+# CONFIG_FB_SIS is not set
+# CONFIG_FB_VIA is not set
+# CONFIG_FB_NEOMAGIC is not set
+# CONFIG_FB_KYRO is not set
+# CONFIG_FB_3DFX is not set
+# CONFIG_FB_VOODOO1 is not set
+# CONFIG_FB_VT8623 is not set
+# CONFIG_FB_CYBLA is not set
+# CONFIG_FB_TRIDENT is not set
+# CONFIG_FB_ARK is not set
+# CONFIG_FB_PM3 is not set
+# CONFIG_FB_CARMINE is not set
+# CONFIG_FB_GEODE is not set
+CONFIG_FB_GOLDFISH=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+# CONFIG_LCD_CLASS_DEVICE is not set
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_GENERIC=y
+# CONFIG_BACKLIGHT_PROGEAR is not set
+# CONFIG_BACKLIGHT_MBP_NVIDIA is not set
+# CONFIG_BACKLIGHT_SAHARA is not set
+
+#
+# Display device support
+#
+# CONFIG_DISPLAY_SUPPORT is not set
+
+#
+# Console display driver support
+#
+CONFIG_VGA_CONSOLE=y
+CONFIG_VGACON_SOFT_SCROLLBACK=y
+CONFIG_VGACON_SOFT_SCROLLBACK_SIZE=64
+CONFIG_DUMMY_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE is not set
+CONFIG_LOGO=y
+# CONFIG_LOGO_LINUX_MONO is not set
+# CONFIG_LOGO_LINUX_VGA16 is not set
+CONFIG_LOGO_LINUX_CLUT224=y
+# CONFIG_SOUND is not set
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+CONFIG_HID_DEBUG=y
+CONFIG_HIDRAW=y
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+CONFIG_HID_PID=y
+CONFIG_USB_HIDDEV=y
+
+#
+# Special HID drivers
+#
+CONFIG_HID_COMPAT=y
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+CONFIG_HID_CYPRESS=y
+CONFIG_HID_EZKEY=y
+CONFIG_HID_GYRATION=y
+CONFIG_HID_LOGITECH=y
+CONFIG_LOGITECH_FF=y
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+CONFIG_HID_MICROSOFT=y
+CONFIG_HID_MONTEREY=y
+CONFIG_HID_NTRIG=y
+CONFIG_HID_PANTHERLORD=y
+CONFIG_PANTHERLORD_FF=y
+CONFIG_HID_PETALYNX=y
+CONFIG_HID_SAMSUNG=y
+CONFIG_HID_SONY=y
+CONFIG_HID_SUNPLUS=y
+# CONFIG_GREENASIA_FF is not set
+CONFIG_HID_TOPSEED=y
+CONFIG_THRUSTMASTER_FF=y
+CONFIG_ZEROPLUS_FF=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+CONFIG_USB_DEBUG=y
+CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEVICEFS=y
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_SUSPEND is not set
+# CONFIG_USB_OTG is not set
+CONFIG_USB_MON=y
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_UHCI_HCD=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_WHCI_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+CONFIG_USB_PRINTER=y
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may also be needed;
+#
+
+#
+# see USB_STORAGE Help for more information
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+CONFIG_USB_LIBUSUAL=y
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_BERRY_CHARGE is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_PHIDGET is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_VST is not set
+# CONFIG_USB_GADGET is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_UWB is not set
+CONFIG_MMC=y
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_UNSAFE_RESUME is not set
+# CONFIG_MMC_EMBEDDED_SDIO is not set
+# CONFIG_MMC_PARANOID_SD_INIT is not set
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_MMC_BLOCK_DEFERRED_RESUME is not set
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_WBSD is not set
+# CONFIG_MMC_TIFM_SD is not set
+CONFIG_MMC_GOLDFISH=y
+# CONFIG_MMC_SDRICOH_CS is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_ALIX2 is not set
+# CONFIG_LEDS_PCA9532 is not set
+# CONFIG_LEDS_CLEVO_MAIL is not set
+# CONFIG_LEDS_PCA955X is not set
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGERS=y
+# CONFIG_LEDS_TRIGGER_TIMER is not set
+# CONFIG_LEDS_TRIGGER_HEARTBEAT is not set
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+# CONFIG_LEDS_TRIGGER_SLEEP is not set
+# CONFIG_SWITCH is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC=y
+
+#
+# Reporting subsystems
+#
+# CONFIG_EDAC_DEBUG is not set
+# CONFIG_EDAC_MM_EDAC is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+# CONFIG_RTC_HCTOSYS is not set
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_INTF_ALARM is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+CONFIG_RTC_DRV_CMOS=y
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+# CONFIG_RTC_DRV_GOLDFISH is not set
+CONFIG_DMADEVICES=y
+
+#
+# DMA Devices
+#
+# CONFIG_INTEL_IOATDMA is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_ET131X is not set
+# CONFIG_SLICOSS is not set
+# CONFIG_SXG is not set
+# CONFIG_ME4000 is not set
+# CONFIG_MEILHAUS is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_W35UND is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_USB_ATMEL is not set
+# CONFIG_AGNX is not set
+# CONFIG_OTUS is not set
+# CONFIG_RT2860 is not set
+# CONFIG_RT2870 is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_ALTERA_PCIE_CHDMA is not set
+# CONFIG_RTL8187SE is not set
+# CONFIG_INPUT_MIMIO is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_EPL is not set
+
+#
+# Android
+#
+CONFIG_ANDROID=y
+CONFIG_ANDROID_BINDER_IPC=y
+CONFIG_ANDROID_LOGGER=y
+# CONFIG_ANDROID_RAM_CONSOLE is not set
+CONFIG_ANDROID_TIMED_OUTPUT=y
+# CONFIG_ANDROID_LOW_MEMORY_KILLER is not set
+CONFIG_X86_PLATFORM_DEVICES=y
+# CONFIG_ASUS_LAPTOP is not set
+# CONFIG_FUJITSU_LAPTOP is not set
+# CONFIG_TC1100_WMI is not set
+# CONFIG_MSI_LAPTOP is not set
+# CONFIG_PANASONIC_LAPTOP is not set
+# CONFIG_COMPAL_LAPTOP is not set
+# CONFIG_SONY_LAPTOP is not set
+# CONFIG_THINKPAD_ACPI is not set
+# CONFIG_INTEL_MENLOW is not set
+# CONFIG_EEEPC_LAPTOP is not set
+# CONFIG_ACPI_WMI is not set
+# CONFIG_ACPI_ASUS is not set
+# CONFIG_ACPI_TOSHIBA is not set
+
+#
+# Firmware Drivers
+#
+# CONFIG_EDD is not set
+CONFIG_FIRMWARE_MEMMAP=y
+# CONFIG_DELL_RBU is not set
+# CONFIG_DCDBAS is not set
+CONFIG_DMIID=y
+CONFIG_ISCSI_IBFT_FIND=y
+CONFIG_ISCSI_IBFT=y
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=m
+CONFIG_EXT2_FS_XATTR=y
+# CONFIG_EXT2_FS_POSIX_ACL is not set
+# CONFIG_EXT2_FS_SECURITY is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+CONFIG_FS_MBCACHE=m
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+CONFIG_FILE_LOCKING=y
+# CONFIG_XFS_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+CONFIG_DNOTIFY=y
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+CONFIG_QUOTA=y
+CONFIG_QUOTA_NETLINK_INTERFACE=y
+# CONFIG_PRINT_QUOTA_WARNING is not set
+# CONFIG_QFMT_V1 is not set
+# CONFIG_QFMT_V2 is not set
+CONFIG_QUOTACTL=y
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+CONFIG_GENERIC_ACL=y
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+CONFIG_JOLIET=y
+CONFIG_ZISOFS=y
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_HUGETLBFS=y
+CONFIG_HUGETLB_PAGE=y
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_YAFFS_FS=y
+CONFIG_YAFFS_YAFFS1=y
+# CONFIG_YAFFS_9BYTE_TAGS is not set
+# CONFIG_YAFFS_DOES_ECC is not set
+CONFIG_YAFFS_YAFFS2=y
+CONFIG_YAFFS_AUTO_YAFFS2=y
+# CONFIG_YAFFS_DISABLE_LAZY_LOAD is not set
+# CONFIG_YAFFS_DISABLE_WIDE_TNODES is not set
+# CONFIG_YAFFS_ALWAYS_CHECK_CHUNK_ERASED is not set
+CONFIG_YAFFS_SHORT_NAMES_IN_RAM=y
+# CONFIG_JFFS2_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+# CONFIG_NETWORK_FILESYSTEMS is not set
+
+#
+# Partition Types
+#
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_ACORN_PARTITION is not set
+CONFIG_OSF_PARTITION=y
+CONFIG_AMIGA_PARTITION=y
+# CONFIG_ATARI_PARTITION is not set
+CONFIG_MAC_PARTITION=y
+CONFIG_MSDOS_PARTITION=y
+CONFIG_BSD_DISKLABEL=y
+CONFIG_MINIX_SUBPARTITION=y
+CONFIG_SOLARIS_X86_PARTITION=y
+CONFIG_UNIXWARE_DISKLABEL=y
+# CONFIG_LDM_PARTITION is not set
+CONFIG_SGI_PARTITION=y
+# CONFIG_ULTRIX_PARTITION is not set
+CONFIG_SUN_PARTITION=y
+CONFIG_KARMA_PARTITION=y
+CONFIG_EFI_PARTITION=y
+# CONFIG_SYSV68_PARTITION is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="utf8"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+CONFIG_NLS_ASCII=y
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_PRINTK_TIME=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=2048
+CONFIG_MAGIC_SYSRQ=y
+# CONFIG_UNUSED_SYMBOLS is not set
+CONFIG_DEBUG_FS=y
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_SLUB_DEBUG_ON is not set
+# CONFIG_SLUB_STATS is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_ARCH_WANT_FRAME_POINTERS=y
+CONFIG_FRAME_POINTER=y
+# CONFIG_RCU_CPU_STALL_DETECTOR is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_SYSCTL_SYSCALL_CHECK=y
+CONFIG_USER_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+CONFIG_HAVE_FUNCTION_TRACE_MCOUNT_TEST=y
+CONFIG_HAVE_DYNAMIC_FTRACE=y
+CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+
+#
+# Tracers
+#
+# CONFIG_SYSPROF_TRACER is not set
+CONFIG_PROVIDE_OHCI1394_DMA_INIT=y
+# CONFIG_DYNAMIC_PRINTK_DEBUG is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_STRICT_DEVMEM is not set
+CONFIG_X86_VERBOSE_BOOTUP=y
+CONFIG_EARLY_PRINTK=y
+# CONFIG_EARLY_PRINTK_DBGP is not set
+# CONFIG_4KSTACKS is not set
+CONFIG_DOUBLEFAULT=y
+CONFIG_HAVE_MMIOTRACE_SUPPORT=y
+CONFIG_IO_DELAY_TYPE_0X80=0
+CONFIG_IO_DELAY_TYPE_0XED=1
+CONFIG_IO_DELAY_TYPE_UDELAY=2
+CONFIG_IO_DELAY_TYPE_NONE=3
+CONFIG_IO_DELAY_0X80=y
+# CONFIG_IO_DELAY_0XED is not set
+# CONFIG_IO_DELAY_UDELAY is not set
+# CONFIG_IO_DELAY_NONE is not set
+CONFIG_DEFAULT_IO_DELAY_TYPE=0
+# CONFIG_OPTIMIZE_INLINING is not set
+
+#
+# Security options
+#
+CONFIG_KEYS=y
+CONFIG_KEYS_DEBUG_PROC_KEYS=y
+CONFIG_SECURITY=y
+# CONFIG_SECURITYFS is not set
+CONFIG_SECURITY_NETWORK=y
+# CONFIG_SECURITY_NETWORK_XFRM is not set
+# CONFIG_SECURITY_PATH is not set
+CONFIG_SECURITY_FILE_CAPABILITIES=y
+# CONFIG_SECURITY_ROOTPLUG is not set
+# CONFIG_SECURITY_SMACK is not set
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+# CONFIG_CRYPTO_CRYPTD is not set
+CONFIG_CRYPTO_AUTHENC=y
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32C_INTEL is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+CONFIG_CRYPTO_SHA1=y
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+CONFIG_CRYPTO_AES_586=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SALSA20_586 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+# CONFIG_CRYPTO_TWOFISH_586 is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_PADLOCK is not set
+# CONFIG_CRYPTO_DEV_GEODE is not set
+# CONFIG_CRYPTO_DEV_HIFN_795X is not set
+CONFIG_HAVE_KVM=y
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_FIRST_BIT=y
+CONFIG_GENERIC_FIND_NEXT_BIT=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+CONFIG_CRC_T10DIF=y
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_PLIST=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
diff --git a/fs/ext2/Makefile b/fs/ext2/Makefile
index e0b2b43..d4e7cb7 100644
--- a/fs/ext2/Makefile
+++ b/fs/ext2/Makefile
@@ -5,7 +5,7 @@
 obj-$(CONFIG_EXT2_FS) += ext2.o
 
 ext2-y := balloc.o dir.o file.o fsync.o ialloc.o inode.o \
-	  ioctl.o namei.o super.o symlink.o
+	  ioctl.o namei.o super.o symlink.o ext2_evict.o
 
 ext2-$(CONFIG_EXT2_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
 ext2-$(CONFIG_EXT2_FS_POSIX_ACL) += acl.o
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
new file mode 100644
index 0000000..8926e3b
--- /dev/null
+++ b/fs/ext2/ext2_evict.c
@@ -0,0 +1,12 @@
+#include <linux/fs.h>
+
+/*
+ * Evict file to the server.
+ */
+int ext2_evict(struct inode *i_node)
+{
+}
+
+int ext2_fetch(struct inode *i_node)
+{
+}
-- 
1.7.9.5


From 6318ed1d8c876ccaa14c16d066bad8bb89b6503a Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 25 Apr 2013 14:02:35 -0400
Subject: [PATCH 17/75] -corrected config file to include ext2 not as a
 module.

---
 arch/x86/configs/goldfish_ext2_defconfig |    6 +++---
 fs/ext2/Makefile                         |    4 ++--
 fs/ext2/ext2_evict.c                     |    2 ++
 3 files changed, 7 insertions(+), 5 deletions(-)

diff --git a/arch/x86/configs/goldfish_ext2_defconfig b/arch/x86/configs/goldfish_ext2_defconfig
index 0a9ed68..8b3b80c 100644
--- a/arch/x86/configs/goldfish_ext2_defconfig
+++ b/arch/x86/configs/goldfish_ext2_defconfig
@@ -1,7 +1,7 @@
 #
 # Automatically generated make config: don't edit
 # Linux kernel version: 2.6.29
-# Wed Apr 24 19:25:24 2013
+# Thu Apr 25 13:54:15 2013
 #
 # CONFIG_64BIT is not set
 CONFIG_X86_32=y
@@ -1902,14 +1902,14 @@ CONFIG_ISCSI_IBFT=y
 #
 # File systems
 #
-CONFIG_EXT2_FS=m
+CONFIG_EXT2_FS=y
 CONFIG_EXT2_FS_XATTR=y
 # CONFIG_EXT2_FS_POSIX_ACL is not set
 # CONFIG_EXT2_FS_SECURITY is not set
 # CONFIG_EXT2_FS_XIP is not set
 # CONFIG_EXT3_FS is not set
 # CONFIG_EXT4_FS is not set
-CONFIG_FS_MBCACHE=m
+CONFIG_FS_MBCACHE=y
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
diff --git a/fs/ext2/Makefile b/fs/ext2/Makefile
index d4e7cb7..1f7ba36 100644
--- a/fs/ext2/Makefile
+++ b/fs/ext2/Makefile
@@ -4,8 +4,8 @@
 
 obj-$(CONFIG_EXT2_FS) += ext2.o
 
-ext2-y := balloc.o dir.o file.o fsync.o ialloc.o inode.o \
-	  ioctl.o namei.o super.o symlink.o ext2_evict.o
+ext2-y := balloc.o dir.o ext2_evict.o file.o fsync.o ialloc.o inode.o \
+	  ioctl.o namei.o super.o symlink.o
 
 ext2-$(CONFIG_EXT2_FS_XATTR)	 += xattr.o xattr_user.o xattr_trusted.o
 ext2-$(CONFIG_EXT2_FS_POSIX_ACL) += acl.o
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 8926e3b..ef49b00 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -5,8 +5,10 @@
  */
 int ext2_evict(struct inode *i_node)
 {
+	return 0;
 }
 
 int ext2_fetch(struct inode *i_node)
 {
+	return 1;
 }
-- 
1.7.9.5


From 3f1a907ae6501cfd319b690b7676adb449c25567 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 25 Apr 2013 16:02:34 -0400
Subject: [PATCH 18/75] -added parse arguments to fs/ext2/super.c

---
 fs/ext2/ext2_evict.c |   15 ++++++++++++++-
 fs/ext2/super.c      |   30 +++++++++++++++++++++++++++++-
 2 files changed, 43 insertions(+), 2 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index ef49b00..487a3e4 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,14 +1,27 @@
 #include <linux/fs.h>
 
 /*
- * Evict file to the server.
+ * Evict's the blocks associated with the inode to the server.
  */
 int ext2_evict(struct inode *i_node)
 {
 	return 0;
 }
 
+/*
+ * Retrieves the associated blocks from the server and writes them to disk.
+ */
 int ext2_fetch(struct inode *i_node)
 {
 	return 1;
 }
+
+/*
+ * Implements the clock algorithm.
+ * Called:
+ *	When new disk blocks are allocated.
+ *	From eviction daemon
+ */
+void ext2_evict_fs(struct super_block *super)
+{
+}
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 7c6e360..dd20be3 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -385,13 +385,21 @@ static unsigned long get_sb_block(void **data)
 	return sb_block;
 }
 
+/*
+ * Added:
+ *	srv - server_name_or_ip:port
+ *	wh - upper limit for eviction
+ *	wl - lower limit for eviction, run daemon when above this.
+ *	evict - leave the disk evict utilized
+ */
 enum {
 	Opt_bsd_df, Opt_minix_df, Opt_grpid, Opt_nogrpid,
 	Opt_resgid, Opt_resuid, Opt_sb, Opt_err_cont, Opt_err_panic,
 	Opt_err_ro, Opt_nouid32, Opt_nocheck, Opt_debug,
 	Opt_oldalloc, Opt_orlov, Opt_nobh, Opt_user_xattr, Opt_nouser_xattr,
 	Opt_acl, Opt_noacl, Opt_xip, Opt_ignore, Opt_err, Opt_quota,
-	Opt_usrquota, Opt_grpquota, Opt_reservation, Opt_noreservation
+	Opt_usrquota, Opt_grpquota, Opt_reservation, Opt_noreservation,
+	Opt_srv, Opt_wh, Opt_wl, Opt_evict
 };
 
 static const match_table_t tokens = {
@@ -425,7 +433,14 @@ static const match_table_t tokens = {
 	{Opt_usrquota, "usrquota"},
 	{Opt_reservation, "reservation"},
 	{Opt_noreservation, "noreservation"},
+
+	{Opt_srv, "srv=%s"},
+	{Opt_wh, "wh=%u"},
+	{Opt_wl, "wl=%u"},
+	{Opt_evict, "evict=%u"},
+
 	{Opt_err, NULL}
+
 };
 
 static int parse_options (char * options,
@@ -567,6 +582,19 @@ static int parse_options (char * options,
 			break;
 		case Opt_ignore:
 			break;
+
+		case Opt_srv:
+			/* TODO */
+			break;
+		case Opt_wh:
+			/* TODO */
+			break;
+		case Opt_wl:
+			/* TODO */
+			break;
+		case Opt_evict:
+			/* TODO */
+			break;
 		default:
 			return 0;
 		}
-- 
1.7.9.5


From cdd185d7816a908dc2cee814f41d42c34ae255cb Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 27 Apr 2013 09:07:46 -0400
Subject: [PATCH 19/75] -wrote first draft of kernel networking code. -Need to
 write some sort of test syscall.

---
 fs/ext2/ext2_evict.c |   67 ++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 67 insertions(+)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 487a3e4..48a59e4 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,10 +1,77 @@
 #include <linux/fs.h>
+#include <linux/semaphore.h>
+#include <linux/socket.h>
+#include <net/sock.h>
+
+#include "clfs.h"
 
 /*
  * Evict's the blocks associated with the inode to the server.
  */
 int ext2_evict(struct inode *i_node)
 {
+	/* Used temporarily */
+	uint32_t temp_ip;
+	int temp_port;
+
+	int ret, bytes;
+	struct clfs_req req;
+	struct sockaddr_in s_addr;
+	struct socket *sock;
+	enum clfs_status status;
+
+	struct msghdr msg;
+	struct iovec iov;
+
+
+	temp_ip = 0xa000202; /*10.0.2.2*/
+	temp_port = 8888;
+
+	down_read(&i_node->i_alloc_sem);
+	req.inode = i_node->i_ino;
+	req.size = i_node->i_size;
+	req.type = CLFS_PUT;
+	down_read(&i_node->i_alloc_sem);
+
+	ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
+	if (ret) {
+		printk(KERN_DEBUG "Failed to create socket.\n");
+		return -1;
+	}
+	memset(&s_addr, 0, sizeof(s_addr));
+	s_addr.sin_family = AF_INET;
+	s_addr.sin_port = htons(temp_port);
+	s_addr.sin_addr.s_addr = htons(temp_ip);
+
+	ret = sock->ops->connect(sock, (struct sockaddr *) &s_addr,
+			sizeof(s_addr), O_RDWR);
+	if (ret < 0) {
+		printk(KERN_DEBUG "Failed to connect to server.\n");
+		return -1;
+	}
+
+	msg.msg_name = 0;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = NULL;
+	msg.msg_flags = 0;
+
+	msg.msg_iov->iov_len = sizeof(req);
+	msg.msg_iov->iov_base = &req;
+
+	get_fs();
+	set_fs(KERNEL_DS);
+
+	bytes = sock_sendmsg(sock, &msg, sizeof(req));
+
+	msg.msg_iov->iov_len = sizeof(enum clfs_status);
+	msg.msg_iov->iov_base = &status;
+	bytes = sock_recvmsg(sock, &msg, sizeof(req), 0);
+
+
+
 	return 0;
 }
 
-- 
1.7.9.5


From e8e254dd0c17978a645bd69b4410ea5675c1b59e Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 27 Apr 2013 10:09:23 -0400
Subject: [PATCH 20/75] -added hw4test system call.

---
 arch/x86/include/asm/unistd_32.h   |    2 ++
 arch/x86/kernel/syscall_table_32.S |    1 +
 fs/ext2/ext2_evict.c               |   22 ++++++++++++++++++----
 include/linux/syscalls.h           |    3 +++
 4 files changed, 24 insertions(+), 4 deletions(-)

diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index f2bba78..76053f8 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -338,6 +338,8 @@
 #define __NR_dup3		330
 #define __NR_pipe2		331
 #define __NR_inotify_init1	332
+/* Added to test hw4 networking. */
+#define __hw4test		333
 
 #ifdef __KERNEL__
 
diff --git a/arch/x86/kernel/syscall_table_32.S b/arch/x86/kernel/syscall_table_32.S
index e2e86a0..161c3bd 100644
--- a/arch/x86/kernel/syscall_table_32.S
+++ b/arch/x86/kernel/syscall_table_32.S
@@ -332,3 +332,4 @@ ENTRY(sys_call_table)
 	.long sys_dup3			/* 330 */
 	.long sys_pipe2
 	.long sys_inotify_init1
+	.long hw4test /* Added to test hw4 networking*/
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 48a59e4..b19667e 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -22,7 +22,7 @@ int ext2_evict(struct inode *i_node)
 
 	struct msghdr msg;
 	struct iovec iov;
-
+	mm_segment_t mm_test;
 
 	temp_ip = 0xa000202; /*10.0.2.2*/
 	temp_port = 8888;
@@ -61,8 +61,9 @@ int ext2_evict(struct inode *i_node)
 	msg.msg_iov->iov_len = sizeof(req);
 	msg.msg_iov->iov_base = &req;
 
-	get_fs();
+	mm_test = get_fs();
 	set_fs(KERNEL_DS);
+	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
 
 	bytes = sock_sendmsg(sock, &msg, sizeof(req));
 
@@ -70,8 +71,6 @@ int ext2_evict(struct inode *i_node)
 	msg.msg_iov->iov_base = &status;
 	bytes = sock_recvmsg(sock, &msg, sizeof(req), 0);
 
-
-
 	return 0;
 }
 
@@ -92,3 +91,18 @@ int ext2_fetch(struct inode *i_node)
 void ext2_evict_fs(struct super_block *super)
 {
 }
+
+asmlinkage long hw4test(){
+	int inode_num, ret_val;
+	struct inode i_node;
+	
+	inode_num = 1;
+	i_node.i_ino = inode_num;
+	i_node.i_size = 0;
+
+	ret_val = ext2_evict(&i_node);
+	return ret_val;
+}
+
+
+
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index f9f900c..fc2edca 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -692,6 +692,9 @@ asmlinkage long sys_ppoll(struct pollfd __user *, unsigned int,
 asmlinkage long sys_pipe2(int __user *, int);
 asmlinkage long sys_pipe(int __user *);
 
+/* Added to test hw4 networking. */
+asmlinkage long hw4test(void);
+
 int kernel_execve(const char *filename, char *const argv[], char *const envp[]);
 
 #endif
-- 
1.7.9.5


From c5085b0c30d19004809c78e502669353699f7688 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 27 Apr 2013 10:11:21 -0400
Subject: [PATCH 21/75] -corrected checkpatch errors.

---
 fs/ext2/ext2_evict.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index b19667e..38622b3 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -92,10 +92,11 @@ void ext2_evict_fs(struct super_block *super)
 {
 }
 
-asmlinkage long hw4test(){
+asmlinkage long hw4test()
+{
 	int inode_num, ret_val;
 	struct inode i_node;
-	
+
 	inode_num = 1;
 	i_node.i_ino = inode_num;
 	i_node.i_size = 0;
-- 
1.7.9.5


From 15f32107cd78994664129f69d8798a7b06e2809a Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 27 Apr 2013 11:59:28 -0400
Subject: [PATCH 22/75] -kernel can connect out to the server.

---
 clfs/Makefile        |   14 +++++++++++---
 clfs/clfs_server.c   |    6 ++++--
 clfs/evict_test.c    |   14 ++++++++++++++
 fs/ext2/clfs.h       |   18 ++++++++++++++++++
 fs/ext2/ext2_evict.c |   15 ++++++++++-----
 5 files changed, 57 insertions(+), 10 deletions(-)
 create mode 100644 clfs/evict_test.c
 create mode 100644 fs/ext2/clfs.h

diff --git a/clfs/Makefile b/clfs/Makefile
index 9776576..4b19f72 100644
--- a/clfs/Makefile
+++ b/clfs/Makefile
@@ -1,4 +1,5 @@
 APP := clfs_test_client
+EVICT := evict_test
 ROOT:=$(HOME)/repos
 NDK_PLATFORM_VER := 14
 INSTALL_DIR := /data/tmp
@@ -25,11 +26,16 @@ CFLAGS := -I$(INCDIR)
 LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
 LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
  
-all: $(APP) server
+all: $(APP) server evict
 
 server: $(SRVR).c
 	$(LOCAL_CC) $(SRVR).c $(LOCAL_FLAGS) -o $(SRVR)
  
+evict: $(EVICT).c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $(EVICT).c -o $(EVICT).o
+	$(CC) $(LDFLAGS) -o $(EVICT) $(EVICT).o
+	
+
 OBJS += $(APP).o
  
 $(APP): $(OBJS)
@@ -37,9 +43,11 @@ $(APP): $(OBJS)
  
 %.o: %.c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-install: $(APP) server
+install: $(APP) evict server
 	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(EVICT) $(INSTALL_DIR)/$(EVICT) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(EVICT)
  
 shell:
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
@@ -53,5 +61,5 @@ r: $(APP)
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
  
 clean:
-	@rm -f $(APP).o $(APP) $(SRVR)
+	@rm -f *.o $(APP) $(SRVR) $(EVICT)
 
diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index ae81891..d138718 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -142,8 +142,10 @@ void *handle_clfs_request(void *thread_fd)
 			fprintf(stderr, "Out of memory.\n");
 			exit(1);
 		}
-
-		read_succeed = 0;
+		if (bytes_remaining == 0)
+			read_succeed = 1;
+		else
+			read_succeed = 0;
 		while (bytes_remaining > 0) {
 			start_byte = req.size - bytes_remaining;
 			bytes = recv(client_fd, block_buf + start_byte,
diff --git a/clfs/evict_test.c b/clfs/evict_test.c
new file mode 100644
index 0000000..aadf6d3
--- /dev/null
+++ b/clfs/evict_test.c
@@ -0,0 +1,14 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+#define __hw4_test 333
+
+int main()
+{
+	int ret_val;
+	printf("Calling print_test\n");
+	ret_val = syscall(__hw4_test);
+	printf("Called print test.\n");
+}
diff --git a/fs/ext2/clfs.h b/fs/ext2/clfs.h
new file mode 100644
index 0000000..5d3a868
--- /dev/null
+++ b/fs/ext2/clfs.h
@@ -0,0 +1,18 @@
+#define CLFS_PORT 8888
+
+struct clfs_req {
+	enum {
+		CLFS_PUT,
+		CLFS_GET,
+		CLFS_RM
+	} type;
+	int inode;
+	int size;
+};
+
+enum clfs_status {
+	CLFS_OK = 0,
+	CLFS_INVAL = EINVAL,
+	CLFS_ACCESS = EACCES,
+	CLFS_ERROR
+};
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 38622b3..198d0ad 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -33,22 +33,24 @@ int ext2_evict(struct inode *i_node)
 	req.type = CLFS_PUT;
 	down_read(&i_node->i_alloc_sem);
 
+	memset(&s_addr, 0, sizeof(s_addr));
 	ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
 	if (ret) {
 		printk(KERN_DEBUG "Failed to create socket.\n");
 		return -1;
-	}
-	memset(&s_addr, 0, sizeof(s_addr));
+	} else
+		printk(KERN_DEBUG "Created socket.\n");
 	s_addr.sin_family = AF_INET;
 	s_addr.sin_port = htons(temp_port);
-	s_addr.sin_addr.s_addr = htons(temp_ip);
+	s_addr.sin_addr.s_addr = htonl(temp_ip);
 
 	ret = sock->ops->connect(sock, (struct sockaddr *) &s_addr,
 			sizeof(s_addr), O_RDWR);
 	if (ret < 0) {
 		printk(KERN_DEBUG "Failed to connect to server.\n");
 		return -1;
-	}
+	} else
+		printk(KERN_DEBUG "Connected to server.\n");
 
 	msg.msg_name = 0;
 	msg.msg_namelen = 0;
@@ -69,7 +71,9 @@ int ext2_evict(struct inode *i_node)
 
 	msg.msg_iov->iov_len = sizeof(enum clfs_status);
 	msg.msg_iov->iov_base = &status;
-	bytes = sock_recvmsg(sock, &msg, sizeof(req), 0);
+	bytes = sock_recvmsg(sock, &msg, sizeof(enum clfs_status), 0);
+	printk(KERN_DEBUG "response = %d\n", status);
+
 
 	return 0;
 }
@@ -97,6 +101,7 @@ asmlinkage long hw4test()
 	int inode_num, ret_val;
 	struct inode i_node;
 
+	init_rwsem(&i_node.i_alloc_sem);
 	inode_num = 1;
 	i_node.i_ino = inode_num;
 	i_node.i_size = 0;
-- 
1.7.9.5


From 218418252a4337340dca8bc9d63ab1ca423c5318 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 27 Apr 2013 12:29:11 -0400
Subject: [PATCH 23/75] -refactored out client network code to own function.
 -maybe should refactor further.

---
 fs/ext2/ext2_evict.c |   47 ++++++++++++++++++++++++++++-------------------
 1 file changed, 28 insertions(+), 19 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 198d0ad..2ac65ff 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -5,17 +5,9 @@
 
 #include "clfs.h"
 
-/*
- * Evict's the blocks associated with the inode to the server.
- */
-int ext2_evict(struct inode *i_node)
+int evict_buffer(size_t buff_size, void *buffer)
 {
-	/* Used temporarily */
-	uint32_t temp_ip;
-	int temp_port;
-
 	int ret, bytes;
-	struct clfs_req req;
 	struct sockaddr_in s_addr;
 	struct socket *sock;
 	enum clfs_status status;
@@ -24,15 +16,13 @@ int ext2_evict(struct inode *i_node)
 	struct iovec iov;
 	mm_segment_t mm_test;
 
+	/* Used temporarily */
+	uint32_t temp_ip;
+	int temp_port;
+
 	temp_ip = 0xa000202; /*10.0.2.2*/
 	temp_port = 8888;
 
-	down_read(&i_node->i_alloc_sem);
-	req.inode = i_node->i_ino;
-	req.size = i_node->i_size;
-	req.type = CLFS_PUT;
-	down_read(&i_node->i_alloc_sem);
-
 	memset(&s_addr, 0, sizeof(s_addr));
 	ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
 	if (ret) {
@@ -60,25 +50,44 @@ int ext2_evict(struct inode *i_node)
 	msg.msg_controllen = NULL;
 	msg.msg_flags = 0;
 
-	msg.msg_iov->iov_len = sizeof(req);
-	msg.msg_iov->iov_base = &req;
+	msg.msg_iov->iov_len = buff_size;
+	msg.msg_iov->iov_base = buffer;
 
 	mm_test = get_fs();
 	set_fs(KERNEL_DS);
 	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
 
-	bytes = sock_sendmsg(sock, &msg, sizeof(req));
+	bytes = sock_sendmsg(sock, &msg, buff_size);
 
 	msg.msg_iov->iov_len = sizeof(enum clfs_status);
 	msg.msg_iov->iov_base = &status;
 	bytes = sock_recvmsg(sock, &msg, sizeof(enum clfs_status), 0);
 	printk(KERN_DEBUG "response = %d\n", status);
 
-
 	return 0;
 }
 
 /*
+ * Evict's the blocks associated with the inode to the server.
+ * TODO: actually read blocks from disk.
+ */
+int ext2_evict(struct inode *i_node)
+{
+	int ret_value;
+	struct clfs_req req;
+
+	down_read(&i_node->i_alloc_sem);
+	req.inode = i_node->i_ino;
+	req.size = i_node->i_size;
+	req.type = CLFS_PUT;
+	down_read(&i_node->i_alloc_sem);
+
+	ret_value = evict_buffer(sizeof(req), &req);
+
+	return ret_value;
+}
+
+/*
  * Retrieves the associated blocks from the server and writes them to disk.
  */
 int ext2_fetch(struct inode *i_node)
-- 
1.7.9.5


From 68b5f84a348a99d87d54802ccca9f674fc635154 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Sat, 27 Apr 2013 14:29:29 -0400
Subject: [PATCH 24/75] Handle some mount options

---
 fs/ext2/ext2.h             |    3 +++
 fs/ext2/super.c            |   16 +++++++++++++---
 include/linux/ext2_fs_sb.h |    4 ++++
 include/linux/fs.h         |    1 +
 4 files changed, 21 insertions(+), 3 deletions(-)

diff --git a/fs/ext2/ext2.h b/fs/ext2/ext2.h
index 3203042..b1b32fb 100644
--- a/fs/ext2/ext2.h
+++ b/fs/ext2/ext2.h
@@ -179,6 +179,9 @@ extern const struct inode_operations ext2_special_inode_operations;
 extern const struct inode_operations ext2_fast_symlink_inode_operations;
 extern const struct inode_operations ext2_symlink_inode_operations;
 
+/* ext2_evict.c */
+extern void ext2_evict_fs(struct super_block *);
+
 static inline ext2_fsblk_t
 ext2_group_first_block_no(struct super_block *sb, unsigned long group_no)
 {
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index dd20be3..84db213 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -312,6 +312,7 @@ static const struct super_operations ext2_sops = {
 	.quota_read	= ext2_quota_read,
 	.quota_write	= ext2_quota_write,
 #endif
+	.evict_fs       = ext2_evict_fs,
 };
 
 static struct inode *ext2_nfs_get_inode(struct super_block *sb,
@@ -587,13 +588,19 @@ static int parse_options (char * options,
 			/* TODO */
 			break;
 		case Opt_wh:
-			/* TODO */
+			if (match_int(&args[0], &option) || option < 0 || option > 100)
+				return 0;
+			sbi->wh = option;
 			break;
 		case Opt_wl:
-			/* TODO */
+			if (match_int(&args[0], &option) || option < 0 || option > sbi->wh)
+				return 0;
+			sbi->wl = option;
 			break;
 		case Opt_evict:
-			/* TODO */
+			if (match_int(&args[0], &option) || option < 0 || option > sbi->wl)
+				return 0;
+			sbi->evict = option;
 			break;
 		default:
 			return 0;
@@ -835,6 +842,9 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 		goto cantfind_ext2;
 
 	/* Set defaults before we parse the mount options */
+	sbi->wh = 95;
+	sbi->wl = 85;
+	sbi->evict = 70;
 	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
 	if (def_mount_opts & EXT2_DEFM_DEBUG)
 		set_opt(sbi->s_mount_opt, DEBUG);
diff --git a/include/linux/ext2_fs_sb.h b/include/linux/ext2_fs_sb.h
index 1cdb663..d534234 100644
--- a/include/linux/ext2_fs_sb.h
+++ b/include/linux/ext2_fs_sb.h
@@ -106,6 +106,10 @@ struct ext2_sb_info {
 	spinlock_t s_rsv_window_lock;
 	struct rb_root s_rsv_window_root;
 	struct ext2_reserve_window_node s_rsv_window_head;
+	
+	int wh;
+	int wl;
+	int evict;
 };
 
 static inline spinlock_t *
diff --git a/include/linux/fs.h b/include/linux/fs.h
index 92734c0..1e21684 100644
--- a/include/linux/fs.h
+++ b/include/linux/fs.h
@@ -1404,6 +1404,7 @@ struct super_operations {
 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
 #endif
 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);
+	int (*evict_fs)(struct super_block *);	
 };
 
 /*
-- 
1.7.9.5


From 88e7fc2f23fd7950fa7f63f816cc21eeac95206f Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Sat, 27 Apr 2013 22:10:26 -0400
Subject: [PATCH 25/75] added testing system call for fetching with stub test
 program. Fleshed out fetch call and planned out
 necessary server/disk interactions with comments.

---
 arch/x86/include/asm/unistd_32.h   |    1 +
 arch/x86/kernel/syscall_table_32.S |    1 +
 clfs/clfs_test_client.c            |    3 ++-
 clfs/fetch_test.c                  |   14 +++++++++++
 fs/ext2/ext2_evict.c               |   45 +++++++++++++++++++++++++++++++++++-
 5 files changed, 62 insertions(+), 2 deletions(-)
 create mode 100644 clfs/fetch_test.c

diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index 76053f8..dd3bc9b 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -340,6 +340,7 @@
 #define __NR_inotify_init1	332
 /* Added to test hw4 networking. */
 #define __hw4test		333
+#define __hw4_fetch_test	334
 
 #ifdef __KERNEL__
 
diff --git a/arch/x86/kernel/syscall_table_32.S b/arch/x86/kernel/syscall_table_32.S
index 161c3bd..37d219f 100644
--- a/arch/x86/kernel/syscall_table_32.S
+++ b/arch/x86/kernel/syscall_table_32.S
@@ -333,3 +333,4 @@ ENTRY(sys_call_table)
 	.long sys_pipe2
 	.long sys_inotify_init1
 	.long hw4test /* Added to test hw4 networking*/
+	.long hw4_fetch_test
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index f5f2cbc..8d8fdda 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -21,7 +21,8 @@ int main()
 
 	char buffer[req_size];
 	char block[BLK_SIZE], ret_block[BLK_SIZE];
-	char ip_addr[] = "10.0.2.2";
+	//char ip_addr[] = "10.0.2.2";
+	char ip_addr[] = "172.16.244.130";
 	char message[] = "hello world";
 	struct sockaddr_in srvaddr;
 	struct clfs_req put_rq, get_rq, rm_rq;
diff --git a/clfs/fetch_test.c b/clfs/fetch_test.c
new file mode 100644
index 0000000..3fcfe2c
--- /dev/null
+++ b/clfs/fetch_test.c
@@ -0,0 +1,14 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+#define __hw4_fetch_test 334
+
+
+int main() {
+	int ret_val;
+	printf("Calling fetch_test\n");
+	ret_val = syscall(__hw4_fetch_test);
+	printf("Called fetch_test, ret_val: %d\n", ret_val);
+}
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 2ac65ff..64298d4 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -67,6 +67,14 @@ int evict_buffer(size_t buff_size, void *buffer)
 	return 0;
 }
 
+// figure out how to identify correct file on server.
+int fetch_blocks() {
+
+
+
+	return 0;
+}
+
 /*
  * Evict's the blocks associated with the inode to the server.
  * TODO: actually read blocks from disk.
@@ -92,7 +100,23 @@ int ext2_evict(struct inode *i_node)
  */
 int ext2_fetch(struct inode *i_node)
 {
-	return 1;
+	int ret_value;
+	struct clfs_req req;
+
+	down_write(&i_node->i_alloc_sem);
+	req.inode = i_node->i_ino;
+	req.size = i_node->i_size;
+	req.type = CLFS_GET;
+	down_write(&i_node->i_alloc_sem);
+
+	// server should give me the right inode
+	// that i can allocate on the fs
+	ret_value = fetch_blocks();
+
+	// now write blocks to disk.
+	// here.
+
+	return ret_value;
 }
 
 /*
@@ -119,5 +143,24 @@ asmlinkage long hw4test()
 	return ret_val;
 }
 
+asmlinkage long hw4_fetch_test()
+{
+	int inode_num, ret_val;
+	struct inode i_node;
+
+	init_rwsem(&i_node.i_alloc_sem);
+	inode_num = 1;
+	i_node.i_ino = inode_num;
+	i_node.i_size = 0;
+
+	ret_val = ext2_fetch(&i_node);
+	return ret_val;
+}
+
+
+
+
+
+
 
 
-- 
1.7.9.5


From 46075e780bc35a2bbaf7af434fd2740a80434398 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Sun, 28 Apr 2013 00:53:48 -0400
Subject: [PATCH 26/75] Some work on eviction policy.

---
 fs/ext2/ext2_evict.c       |   22 +++++++++++++++++++++-
 fs/ext2/inode.c            |   16 ++++++++++++++++
 include/linux/ext2_fs_sb.h |    6 +++---
 3 files changed, 40 insertions(+), 4 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 64298d4..14e3f8f 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -2,8 +2,10 @@
 #include <linux/semaphore.h>
 #include <linux/socket.h>
 #include <net/sock.h>
-
 #include "clfs.h"
+#include <linux/xattr.h>
+#include <linux/ext2_fs.h>
+#include <asm/div64.h>
 
 int evict_buffer(size_t buff_size, void *buffer)
 {
@@ -127,6 +129,24 @@ int ext2_fetch(struct inode *i_node)
  */
 void ext2_evict_fs(struct super_block *super)
 {
+	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
+	struct ext2_super_block *sb = sbi->s_es;	
+	struct inode *root =  super->s_root->d_inode;
+	int clock = 0;
+	ssize_t size = root->i_op->getxattr(super->s_root, "clock", &clock, sizeof(int));
+
+	if(size < 0) {
+		size = root->i_op->setxattr(super->s_root, "clock", &clock, sizeof(int), XATTR_CREATE);
+	}
+
+	uint64_t free = (uint64_t)sb->s_free_blocks_count;
+	uint32_t total = (uint32_t)sb->s_blocks_count;
+	uint64_t usage = (total - free)*100;
+	uint64_t rem = do_div(usage, total);
+	
+	if (usage > sbi->wl) {
+		return;
+	}
 }
 
 asmlinkage long hw4test()
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 23fff2f..771fc92 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -36,6 +36,8 @@
 #include "ext2.h"
 #include "acl.h"
 #include "xip.h"
+#include <linux/list.h>
+#include <asm/div64.h>
 
 MODULE_AUTHOR("Remy Card and others");
 MODULE_DESCRIPTION("Second Extended Filesystem");
@@ -491,6 +493,20 @@ static int ext2_alloc_branch(struct inode *inode,
 			sync_dirty_buffer(bh);
 	}
 	*blks = num;
+	
+	struct super_block *super = inode->i_sb;
+	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
+	struct ext2_super_block *sb = sbi->s_es;
+
+	uint64_t free = (uint64_t)sb->s_free_blocks_count;
+	uint32_t total = (uint32_t)sb->s_blocks_count;
+	uint64_t usage = (total - free)*100;
+	uint64_t rem = do_div(usage, total);
+
+	if (usage > sbi->wh) {
+		super->s_op->evict_fs(super);
+	}
+
 	return err;
 }
 
diff --git a/include/linux/ext2_fs_sb.h b/include/linux/ext2_fs_sb.h
index d534234..526d18a 100644
--- a/include/linux/ext2_fs_sb.h
+++ b/include/linux/ext2_fs_sb.h
@@ -107,9 +107,9 @@ struct ext2_sb_info {
 	struct rb_root s_rsv_window_root;
 	struct ext2_reserve_window_node s_rsv_window_head;
 	
-	int wh;
-	int wl;
-	int evict;
+	unsigned long wh;
+	unsigned long wl;
+	unsigned long evict;
 };
 
 static inline spinlock_t *
-- 
1.7.9.5


From ac3d456261e57063c295032ea80576fcceb8cd03 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 28 Apr 2013 14:41:51 -0400
Subject: [PATCH 27/75] -corrected locking to use mutex rather than the
 weirdly name rwsemaphore.

---
 fs/ext2/ext2_evict.c |   32 ++++++++++++++++++++++++--------
 1 file changed, 24 insertions(+), 8 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 14e3f8f..95b4f66 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -7,6 +7,10 @@
 #include <linux/ext2_fs.h>
 #include <asm/div64.h>
 
+/*
+ * TODO: Make this a general exchange with arbitrarily sized request and
+ * response buffers so it can be used for both evict and fetch.
+ */
 int evict_buffer(size_t buff_size, void *buffer)
 {
 	int ret, bytes;
@@ -86,13 +90,25 @@ int ext2_evict(struct inode *i_node)
 	int ret_value;
 	struct clfs_req req;
 
-	down_read(&i_node->i_alloc_sem);
-	req.inode = i_node->i_ino;
-	req.size = i_node->i_size;
-	req.type = CLFS_PUT;
-	down_read(&i_node->i_alloc_sem);
-
-	ret_value = evict_buffer(sizeof(req), &req);
+	ret_value = 0;
+
+	/*
+	 * This mutex is used while opening a file in the namei.do_filp_open
+	 * function.
+	 */
+	mutex_lock(&i_node->i_mutex);
+	/* Test if the inode is currently being accessed. */
+	if (atomic_read(&i_node->i_count) > 0) {
+		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
+		ret_value = -1;
+	} else {
+		req.inode = i_node->i_ino;
+		req.size = i_node->i_size;
+		req.type = CLFS_PUT;
+
+		ret_value = evict_buffer(sizeof(req), &req);
+	}
+	mutex_unlock(&i_node->i_mutex);
 
 	return ret_value;
 }
@@ -154,7 +170,7 @@ asmlinkage long hw4test()
 	int inode_num, ret_val;
 	struct inode i_node;
 
-	init_rwsem(&i_node.i_alloc_sem);
+	init_MUTEX(&i_node.i_mutex);
 	inode_num = 1;
 	i_node.i_ino = inode_num;
 	i_node.i_size = 0;
-- 
1.7.9.5


From e1b4010f2c6fce5d5e1c26f99e22fa25473ae631 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sun, 28 Apr 2013 17:56:01 -0400
Subject: [PATCH 28/75] -added a function to fs/ext2/inode.c that will remove
 datablocks from disk without updating metadata.
 -added header to fs/ext2/ext2.h -Functions is based
 on truncate_ext2.

---
 fs/ext2/ext2.h       |    3 ++
 fs/ext2/ext2_evict.c |   19 ++++++++++---
 fs/ext2/inode.c      |   74 ++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 92 insertions(+), 4 deletions(-)

diff --git a/fs/ext2/ext2.h b/fs/ext2/ext2.h
index b1b32fb..e21cff0 100644
--- a/fs/ext2/ext2.h
+++ b/fs/ext2/ext2.h
@@ -138,6 +138,9 @@ extern int ext2_fiemap(struct inode *inode, struct fiemap_extent_info *fieinfo,
 int __ext2_write_begin(struct file *file, struct address_space *mapping,
 		loff_t pos, unsigned len, unsigned flags,
 		struct page **pagep, void **fsdata);
+/* Added by Riley Spahn */
+extern int clear_data_blocks(struct inode *i_node);
+
 
 /* ioctl.c */
 extern long ext2_ioctl(struct file *, unsigned int, unsigned long);
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 95b4f66..9bd3e5c 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,10 +1,15 @@
+//#include <linux/ext2_fs.h>
 #include <linux/fs.h>
+#include <linux/namei.h>
 #include <linux/semaphore.h>
 #include <linux/socket.h>
+#include <linux/xattr.h>
 #include <net/sock.h>
+
+#include "ext2.h"
+#include "acl.h"
+#include "xip.h"
 #include "clfs.h"
-#include <linux/xattr.h>
-#include <linux/ext2_fs.h>
 #include <asm/div64.h>
 
 /*
@@ -73,11 +78,12 @@ int evict_buffer(size_t buff_size, void *buffer)
 	return 0;
 }
 
+
+
 // figure out how to identify correct file on server.
 int fetch_blocks() {
 
 
-
 	return 0;
 }
 
@@ -102,10 +108,14 @@ int ext2_evict(struct inode *i_node)
 		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
 		ret_value = -1;
 	} else {
+		/* Read the blocks into a buffer. */
+
+		ret_value = clear_data_blocks(i_node);
+
 		req.inode = i_node->i_ino;
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
-
+		ret_value = clear_data_blocks(i_node);
 		ret_value = evict_buffer(sizeof(req), &req);
 	}
 	mutex_unlock(&i_node->i_mutex);
@@ -169,6 +179,7 @@ asmlinkage long hw4test()
 {
 	int inode_num, ret_val;
 	struct inode i_node;
+	char test_file[] = "/mnt/sdcard/test_file.txt";
 
 	init_MUTEX(&i_node.i_mutex);
 	inode_num = 1;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 771fc92..d9b8dc0 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -1050,6 +1050,9 @@ void ext2_truncate(struct inode *inode)
 		block_truncate_page(inode->i_mapping,
 				inode->i_size, ext2_get_block);
 
+	/* n is the path length and offsets[n] is the offset of pointer
+	 * to (n+1)th node in the nth one.
+	 */
 	n = ext2_block_to_path(inode, iblock, offsets, NULL);
 	if (n == 0)
 		return;
@@ -1469,3 +1472,74 @@ int ext2_setattr(struct dentry *dentry, struct iattr *iattr)
 		error = ext2_acl_chmod(inode);
 	return error;
 }
+
+/*
+ * Clears the data blocks associated with the i_node from disk without touching
+ * modifiation or access times.
+ *
+ * Note: I wonder if we could just save the size and timestamps, just
+ * use the truncate function and then restore the data that would be changed
+ * by trucation.
+ */
+int clear_data_blocks(struct inode *i_node)
+{
+	/*
+	 * offsets index:
+	 * 0 - direct
+	 * 1 - indirect
+	 * 2 - double indirect
+	 * 3 - triple indirect
+	 */
+	int offsets[4], new_size, ret_val, n;
+	__le32 *i_data, temp_data;
+	unsigned blocksize;
+	long iblock;
+	struct ext2_inode_info *in_info = EXT2_I(i_node);
+
+	ret_val = 0;
+	i_data = EXT2_I(i_node)->i_data;
+	new_size = 0;
+	blocksize = i_node->i_sb->s_blocksize;
+	/* Will be zero */
+	iblock = (new_size + blocksize-1)
+					>> EXT2_BLOCK_SIZE_BITS(i_node->i_sb);
+	n = ext2_block_to_path(i_node, iblock, offsets, NULL);
+
+	mutex_lock(&in_info->truncate_mutex);
+	/* 
+	 * Clear out the direct 12 blocks. 
+	 * i_data + offsets[0] - should be 0
+	 * i_data + EXT2_NDIR_BLOCKS - end of direct blocks
+	 */
+	ext2_free_data(i_node, i_data + offsets[0], i_data + EXT2_NDIR_BLOCKS);
+
+	/* Clear out the indirect blocks. */
+	if (i_data[EXT2_IND_BLOCK] != 0) {
+		temp_data = i_data[EXT2_IND_BLOCK];
+		i_data[EXT2_IND_BLOCK] = 0;
+		if (temp_data != 0) {
+			ext2_free_branches(i_node, &temp_data, &temp_data + 1,
+					1);
+		}
+	}
+	/* Clear out the double indirect blocks. */
+	if (i_data[EXT2_DIND_BLOCK] != 0) {
+		temp_data = i_data[EXT2_DIND_BLOCK];
+		i_data[EXT2_DIND_BLOCK] = 0;
+		if (temp_data != 0) {
+			ext2_free_branches(i_node, &temp_data, &temp_data + 1,
+					2);
+		}
+	}
+	/* Clear out the triple indirect blocks. */
+	if (i_data[EXT2_TIND_BLOCK] != 0) {
+		temp_data = i_data[EXT2_TIND_BLOCK];
+		i_data[EXT2_TIND_BLOCK] = 0;
+		if (temp_data != 0) {
+			ext2_free_branches(i_node, &temp_data, &temp_data + 1,
+					3);
+		}
+	}
+	mutex_unlock(&in_info->truncate_mutex);
+	return ret_val;
+}
-- 
1.7.9.5


From 12b5c6abad9d1e1a6c05f0c6d6ab2decc6875532 Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Mon, 29 Apr 2013 00:58:57 -0400
Subject: [PATCH 29/75] added allocation of memory for fetched inode, added
 request for the inode from server.

---
 fs/ext2/ext2_evict.c |   63 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 61 insertions(+), 2 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 95b4f66..00707cc 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -74,8 +74,66 @@ int evict_buffer(size_t buff_size, void *buffer)
 }
 
 // figure out how to identify correct file on server.
-int fetch_blocks() {
+// merge this with function above, evict_buffer.
+int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer) {
+	int ret, bytes;
+	struct sockaddr_in s_addr;
+	struct socket *sock;
+	enum clfs_status status;
+
+	struct msghdr msg;
+	struct iovec iov;
+	mm_segment_t mm_test;
+
+	/* Used temporarily */
+	uint32_t temp_ip;
+	int temp_port;
+
+	temp_ip = 0x7F000001; /*127.0.0.1, localhost*/
+	temp_port = 8888;
+
+	memset(&s_addr, 0, sizeof(s_addr));
+	ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
+	if (ret) {
+		printk(KERN_DEBUG "Failed to create socket.\n");
+		return -1;
+	} else
+		printk(KERN_DEBUG "Created socket.\n");
+	s_addr.sin_family = AF_INET;
+	s_addr.sin_port = htons(temp_port);
+	s_addr.sin_addr.s_addr = htonl(temp_ip);
 
+	ret = sock->ops->connect(sock, (struct sockaddr *) &s_addr,
+			sizeof(s_addr), O_RDWR);
+	if (ret < 0) {
+		printk(KERN_DEBUG "Failed to connect to server.\n");
+		return -1;
+	} else
+		printk(KERN_DEBUG "Connected to server.\n");
+
+	msg.msg_name = 0;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = NULL;
+	msg.msg_flags = 0;
+
+	// we are requesting the inode
+	msg.msg_iov->iov_len = req_size;
+	msg.msg_iov->iov_base = req;
+
+	mm_test = get_fs();
+	set_fs(KERNEL_DS);
+	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
+
+	bytes = sock_sendmsg(sock, &msg, req_size);
+
+
+	msg.msg_iov->iov_len = req->size;
+	msg.msg_iov->iov_base = buffer;
+	bytes = sock_recvmsg(sock, &msg, req->size, 0);
+	printk(KERN_DEBUG "response = %d\n", status);
 
 
 	return 0;
@@ -120,6 +178,7 @@ int ext2_fetch(struct inode *i_node)
 {
 	int ret_value;
 	struct clfs_req req;
+	void *data = kmalloc(i_node->i_size, GFP_KERNEL); // TODO: double check that this is in bytes...
 
 	down_write(&i_node->i_alloc_sem);
 	req.inode = i_node->i_ino;
@@ -129,7 +188,7 @@ int ext2_fetch(struct inode *i_node)
 
 	// server should give me the right inode
 	// that i can allocate on the fs
-	ret_value = fetch_blocks();
+	ret_value = fetch_blocks(sizeof(req), &req, data);
 
 	// now write blocks to disk.
 	// here.
-- 
1.7.9.5


From 5652e79b23849b4369f65b7c67446af708db774e Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Mon, 29 Apr 2013 06:51:59 -0400
Subject: [PATCH 30/75] commenting stuff out while having troubles with ext2
 sdcard..

---
 fs/ext2/ext2_evict.c |   29 +++++++++++++++++++++--------
 1 file changed, 21 insertions(+), 8 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 6f9c1bb..e04062c 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -401,11 +401,15 @@ int ext2_fetch(struct inode *i_node)
         void *file_data;
 
 	//mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
-        mutex_lock(&i_node->i_mutex);
+
+        /*
+	mutex_lock(&i_node->i_mutex);
 	req.inode = i_node->i_ino;
 	req.size = i_node->i_size;
 	req.type = CLFS_GET;
         mutex_unlock(&i_node->i_mutex);
+	*/
+
 	//mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 
 	// server should give me the right inode
@@ -414,16 +418,23 @@ int ext2_fetch(struct inode *i_node)
         
         // using test file data for now, while server doesn't have real file data on it.
         // need to see if I can write this out to blocks and attach those blocks to an inode.
-        file_data = vmalloc(4096);
+        file_data = kmalloc(4096, GFP_KERNEL);
         memset(file_data, '6', 4096);
 
-        printk(KERN_ERR "file_data: %s", (char *)file_data);
+	/* // DEBUG REMOVE ME
+	char *file_data_str = (char *)file_data;
+	file_data_str[4095] = '\n';
+
+        printk(KERN_ERR "file_data: %s", file_data_str);
+	*/
 
 	// now write blocks to disk.
 	// here.
         //mutex_lock_nested(&i_node->i_mutex, I_MUTEX_DATA);
+	mutex_lock(&i_node->i_mutex);
         //write_blocks(i_node, file_data, i_node->i_size);
         //printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
+	mutex_unlock(&i_node->i_mutex);
         //mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_DATA);
 
 	return ret_value;
@@ -543,14 +554,16 @@ asmlinkage long hw4test()
 asmlinkage long hw4_fetch_test()
 {
 	int inode_num, ret_val;
-	struct inode i_node;
+	struct inode *i_node;
+	char test_file[] = "/mnt/sdcard/test_file.txt";
+	struct nameidata nd;
 
-	init_rwsem(&i_node.i_alloc_sem);
-	inode_num = 1;
-	i_node.i_ino = inode_num;
-	i_node.i_size = 0;
+	ret_val = path_lookup(test_file, 0, &nd);
+	i_node = nd.path.dentry->d_inode;
+	hack_inode_closed(i_node);
 
 	ret_val = ext2_fetch(&i_node);
+
 	return ret_val;
 }
 
-- 
1.7.9.5


From a41282d9da60e13c57c2664281b8edfbbfb6c6aa Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Mon, 29 Apr 2013 23:35:48 -0400
Subject: [PATCH 31/75] -added checks that the inode being evicted is a file.
 -added in xattr marking.

---
 fs/ext2/ext2_evict.c |   15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 9bd3e5c..aed3f93 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -3,6 +3,7 @@
 #include <linux/namei.h>
 #include <linux/semaphore.h>
 #include <linux/socket.h>
+#include <linux/stat.h>
 #include <linux/xattr.h>
 #include <net/sock.h>
 
@@ -12,6 +13,7 @@
 #include "clfs.h"
 #include <asm/div64.h>
 
+
 /*
  * TODO: Make this a general exchange with arbitrarily sized request and
  * response buffers so it can be used for both evict and fetch.
@@ -90,11 +92,21 @@ int fetch_blocks() {
 /*
  * Evict's the blocks associated with the inode to the server.
  * TODO: actually read blocks from disk.
+ * TODO: Handle accounting for free blocks.
  */
 int ext2_evict(struct inode *i_node)
 {
+	char evict_label[] = "evicted";
+	int evicted = 1;
 	int ret_value;
 	struct clfs_req req;
+	struct dentry *i_dentry;
+
+	if (S_ISREG(i_node->i_mode) == 0) {
+		printk(KERN_DEBUG "Error: can only evict regular files.\n");
+		return -1;
+	}
+
 
 	ret_value = 0;
 
@@ -104,6 +116,8 @@ int ext2_evict(struct inode *i_node)
 	 */
 	mutex_lock(&i_node->i_mutex);
 	/* Test if the inode is currently being accessed. */
+	i_dentry = container_of(&i_node->i_dentry, struct dentry, d_alias);
+	i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
 	if (atomic_read(&i_node->i_count) > 0) {
 		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
 		ret_value = -1;
@@ -111,7 +125,6 @@ int ext2_evict(struct inode *i_node)
 		/* Read the blocks into a buffer. */
 
 		ret_value = clear_data_blocks(i_node);
-
 		req.inode = i_node->i_ino;
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
-- 
1.7.9.5


From ca076ae482935e37714191a469e27e94004cc043 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 30 Apr 2013 09:56:23 -0400
Subject: [PATCH 32/75] -added calls to clear reserved blocks and to clear the
 page cache to clear_data_blocks.

---
 fs/ext2/ext2_evict.c |   11 ++++++++++-
 fs/ext2/inode.c      |   13 +++++++++++++
 2 files changed, 23 insertions(+), 1 deletion(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index aed3f93..aaf7e52 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -122,9 +122,18 @@ int ext2_evict(struct inode *i_node)
 		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
 		ret_value = -1;
 	} else {
-		/* Read the blocks into a buffer. */
+		/*
+		 * Read the blocks into a buffer.
+		 * I think that I may be able to use do_sync_read for this
+		 * if it does not update access time metadata.
+		 * It looks like it does not update access times so it might
+		 * work.
+		 */
 
 		ret_value = clear_data_blocks(i_node);
+		/* Must clear the cache of pages. */
+
+
 		req.inode = i_node->i_ino;
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index d9b8dc0..e25dc67 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -1480,6 +1480,10 @@ int ext2_setattr(struct dentry *dentry, struct iattr *iattr)
  * Note: I wonder if we could just save the size and timestamps, just
  * use the truncate function and then restore the data that would be changed
  * by trucation.
+ *
+ * Note: I think that I may be able to use truncate_inode_pages to
+ * remove the pages from the cache.  It looks like it does not modify 
+ * any of the metadata.
  */
 int clear_data_blocks(struct inode *i_node)
 {
@@ -1505,6 +1509,9 @@ int clear_data_blocks(struct inode *i_node)
 					>> EXT2_BLOCK_SIZE_BITS(i_node->i_sb);
 	n = ext2_block_to_path(i_node, iblock, offsets, NULL);
 
+	/* I think that this should clear out the page cache. */
+	truncate_inode_pages(&i_node->i_data, 0);
+
 	mutex_lock(&in_info->truncate_mutex);
 	/* 
 	 * Clear out the direct 12 blocks. 
@@ -1540,6 +1547,12 @@ int clear_data_blocks(struct inode *i_node)
 					3);
 		}
 	}
+
+	/* 
+	 * This may not be needed since we are not including reserved
+	 * blocks as part of the usage accounting.
+	 */
+	ext2_discard_reservation(i_node);
 	mutex_unlock(&in_info->truncate_mutex);
 	return ret_val;
 }
-- 
1.7.9.5


From 7a8e3af18a9b11dfbbce52d881edeaea0ba5e9ab Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Wed, 1 May 2013 12:25:50 -0400
Subject: [PATCH 33/75] -added read_blocks function -added locking around
 setting the xattr.

---
 fs/ext2/ext2_evict.c |   29 ++++++++++++++++++++++++++++-
 1 file changed, 28 insertions(+), 1 deletion(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index aaf7e52..1720803 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -80,6 +80,26 @@ int evict_buffer(size_t buff_size, void *buffer)
 	return 0;
 }
 
+/**
+ * reads the data from the disk associated with the inode.
+ */
+int read_blocks(struct inode *i_node)
+{
+
+	/*
+	 * for each index:
+	 *	test if the page is in the cache
+	 *	no:
+	 *		allocate a page
+	 *		add_to_page_cache_lru()
+	 *		set page mapping.
+	 *		set page index
+	 *		increment mapping page count
+	 *	readpage: like mpage_readpages -> do_mpage_readpage
+	 *
+	 *	I think I can just call do_mpage_readpage
+	 */
+}
 
 
 // figure out how to identify correct file on server.
@@ -101,6 +121,7 @@ int ext2_evict(struct inode *i_node)
 	int ret_value;
 	struct clfs_req req;
 	struct dentry *i_dentry;
+	struct ext2_inode_info *in_info;
 
 	if (S_ISREG(i_node->i_mode) == 0) {
 		printk(KERN_DEBUG "Error: can only evict regular files.\n");
@@ -117,7 +138,13 @@ int ext2_evict(struct inode *i_node)
 	mutex_lock(&i_node->i_mutex);
 	/* Test if the inode is currently being accessed. */
 	i_dentry = container_of(&i_node->i_dentry, struct dentry, d_alias);
+	
+	in_info = EXT2_I(i_node);
+
+	down_read(&in_info->xattr_sem);
 	i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
+	up_read(&in_info->xattr_sem);
+
 	if (atomic_read(&i_node->i_count) > 0) {
 		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
 		ret_value = -1;
@@ -129,7 +156,7 @@ int ext2_evict(struct inode *i_node)
 		 * It looks like it does not update access times so it might
 		 * work.
 		 */
-
+		
 		ret_value = clear_data_blocks(i_node);
 		/* Must clear the cache of pages. */
 
-- 
1.7.9.5


From 6036ed65944d8d8427e9449299e898ee5e8616ee Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Wed, 1 May 2013 21:11:13 -0400
Subject: [PATCH 34/75] -added functions that will probably incorrectly read
 files with changing metadata.

---
 fs/ext2/ext2_evict.c |   22 +++++++++++++++++++++-
 1 file changed, 21 insertions(+), 1 deletion(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 1720803..9f47ef3 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,10 +1,12 @@
 //#include <linux/ext2_fs.h>
 #include <linux/fs.h>
+#include <linux/mpage.h>
 #include <linux/namei.h>
 #include <linux/semaphore.h>
 #include <linux/socket.h>
 #include <linux/stat.h>
 #include <linux/xattr.h>
+#include <linux/vmalloc.h>
 #include <net/sock.h>
 
 #include "ext2.h"
@@ -83,7 +85,7 @@ int evict_buffer(size_t buff_size, void *buffer)
 /**
  * reads the data from the disk associated with the inode.
  */
-int read_blocks(struct inode *i_node)
+void *read_blocks(struct inode *i_node)
 {
 
 	/*
@@ -99,6 +101,24 @@ int read_blocks(struct inode *i_node)
 	 *
 	 *	I think I can just call do_mpage_readpage
 	 */
+	
+	void *file_buffer, *curr_addr;
+	unsigned long pages, size;
+	struct page *curr_page;
+
+	size = i_node->i_size;
+	file_buffer = vmalloc(i_node->i_size);
+	if (file_buffer) {
+		while (curr_addr < file_buffer + size) {
+			curr_page = vmalloc_to_page(curr_addr);	
+			curr_addr += PAGE_SIZE;
+			mpage_readpage(curr_page, ext2_get_block);
+		}
+	} else {
+		printk(KERN_DEBUG "Failed to allocate memory to read file.\n");
+		return NULL;
+	}
+	return file_buffer;	
 }
 
 
-- 
1.7.9.5


From bc3e5d11a0c58fba521e72f73c2c33f6c11bec91 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 2 May 2013 16:07:45 -0400
Subject: [PATCH 35/75] -debugging xattr.

---
 fs/ext2/ext2_evict.c |   96 ++++++++++++++------------------------------------
 1 file changed, 26 insertions(+), 70 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index b3b316a..cb68427 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -123,66 +123,8 @@ void *read_blocks(struct inode *i_node)
 
 
 // figure out how to identify correct file on server.
-// merge this with function above, evict_buffer.
-int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer) {
-	int ret, bytes;
-	struct sockaddr_in s_addr;
-	struct socket *sock;
-	enum clfs_status status;
-
-	struct msghdr msg;
-	struct iovec iov;
-	mm_segment_t mm_test;
-
-	/* Used temporarily */
-	uint32_t temp_ip;
-	int temp_port;
-
-	temp_ip = 0x7F000001; /*127.0.0.1, localhost*/
-	temp_port = 8888;
-
-	memset(&s_addr, 0, sizeof(s_addr));
-	ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
-	if (ret) {
-		printk(KERN_DEBUG "Failed to create socket.\n");
-		return -1;
-	} else
-		printk(KERN_DEBUG "Created socket.\n");
-	s_addr.sin_family = AF_INET;
-	s_addr.sin_port = htons(temp_port);
-	s_addr.sin_addr.s_addr = htonl(temp_ip);
+int fetch_blocks() {
 
-	ret = sock->ops->connect(sock, (struct sockaddr *) &s_addr,
-			sizeof(s_addr), O_RDWR);
-	if (ret < 0) {
-		printk(KERN_DEBUG "Failed to connect to server.\n");
-		return -1;
-	} else
-		printk(KERN_DEBUG "Connected to server.\n");
-
-	msg.msg_name = 0;
-	msg.msg_namelen = 0;
-	msg.msg_iov = &iov;
-	msg.msg_iovlen = 1;
-	msg.msg_control = NULL;
-	msg.msg_controllen = NULL;
-	msg.msg_flags = 0;
-
-	// we are requesting the inode
-	msg.msg_iov->iov_len = req_size;
-	msg.msg_iov->iov_base = req;
-
-	mm_test = get_fs();
-	set_fs(KERNEL_DS);
-	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
-
-	bytes = sock_sendmsg(sock, &msg, req_size);
-
-
-	msg.msg_iov->iov_len = req->size;
-	msg.msg_iov->iov_base = buffer;
-	bytes = sock_recvmsg(sock, &msg, req->size, 0);
-	printk(KERN_DEBUG "response = %d\n", status);
 
 	return 0;
 }
@@ -200,13 +142,12 @@ int ext2_evict(struct inode *i_node)
 	struct clfs_req req;
 	struct dentry *i_dentry;
 	struct ext2_inode_info *in_info;
+	void *blocks_buffer;
 
 	if (S_ISREG(i_node->i_mode) == 0) {
 		printk(KERN_DEBUG "Error: can only evict regular files.\n");
 		return -1;
 	}
-
-
 	ret_value = 0;
 
 	/*
@@ -220,9 +161,16 @@ int ext2_evict(struct inode *i_node)
 	in_info = EXT2_I(i_node);
 
 	down_read(&in_info->xattr_sem);
+	
+	if (!i_dentry) {
+		printk(KERN_DEBUG "i_dentry is NULL\n");
+		return -1;
+	}
+
 	i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
 	up_read(&in_info->xattr_sem);
 
+	return -1;
 	if (atomic_read(&i_node->i_count) > 0) {
 		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
 		ret_value = -1;
@@ -235,7 +183,14 @@ int ext2_evict(struct inode *i_node)
 		 * work.
 		 */
 		
-		ret_value = clear_data_blocks(i_node);
+		blocks_buffer = read_blocks(i_node);
+		if (blocks_buffer) {
+			printk(KERN_DEBUG "Blocks_buffer != null: %s", blocks_buffer);
+			return 0;
+		} else {
+			printk(KERN_DEBUG "Blocks_buffer == null");
+			return -1;
+		}
 		/* Must clear the cache of pages. */
 
 
@@ -257,7 +212,6 @@ int ext2_fetch(struct inode *i_node)
 {
 	int ret_value;
 	struct clfs_req req;
-	void *data = kmalloc(i_node->i_size, GFP_KERNEL); // TODO: double check that this is in bytes...
 
 	down_write(&i_node->i_alloc_sem);
 	req.inode = i_node->i_ino;
@@ -267,7 +221,7 @@ int ext2_fetch(struct inode *i_node)
 
 	// server should give me the right inode
 	// that i can allocate on the fs
-	ret_value = fetch_blocks(sizeof(req), &req, data);
+	ret_value = fetch_blocks();
 
 	// now write blocks to disk.
 	// here.
@@ -306,15 +260,17 @@ void ext2_evict_fs(struct super_block *super)
 asmlinkage long hw4test()
 {
 	int inode_num, ret_val;
-	struct inode i_node;
+	struct inode *i_node;
 	char test_file[] = "/mnt/sdcard/test_file.txt";
+	struct nameidata nd;
 
-	init_MUTEX(&i_node.i_mutex);
-	inode_num = 1;
-	i_node.i_ino = inode_num;
-	i_node.i_size = 0;
+	ret_val = path_lookup(test_file, LOOKUP_OPEN, &nd);
+	i_node = nd.path.dentry->d_inode;
+	printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
+	printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
+
+	ret_val = ext2_evict(i_node);
 
-	ret_val = ext2_evict(&i_node);
 	return ret_val;
 }
 
-- 
1.7.9.5


From 58c87ec29c22d8a9ebfdb684d0e996df2a1d3f50 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 2 May 2013 18:57:25 -0400
Subject: [PATCH 36/75] -added correct code to check if file is open.

---
 fs/ext2/ext2_evict.c |   57 +++++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 47 insertions(+), 10 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index cb68427..d2835ca 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -106,11 +106,12 @@ void *read_blocks(struct inode *i_node)
 	unsigned long pages, size;
 	struct page *curr_page;
 
-	size = i_node->i_size;
+	size =i_size_read( i_node->i_size);
 	file_buffer = vmalloc(i_node->i_size);
 	if (file_buffer) {
 		while (curr_addr < file_buffer + size) {
 			curr_page = vmalloc_to_page(curr_addr);	
+			return NULL;
 			curr_addr += PAGE_SIZE;
 			mpage_readpage(curr_page, ext2_get_block);
 		}
@@ -129,6 +130,23 @@ int fetch_blocks() {
 	return 0;
 }
 
+int is_inode_open(struct inode *i_node)
+{
+	int open;
+	struct list_head *dentry_node;
+	struct dentry *curr_dentry;
+
+	open = 0;
+	list_for_each(dentry_node, &i_node->i_dentry) {
+		curr_dentry = list_entry(dentry_node, struct dentry, d_alias);
+		if (atomic_read(&curr_dentry->d_count) > 0) {
+			printk(KERN_DEBUG "Dentry is open. %d\n", atomic_read(&curr_dentry->d_count));
+			open = 1;
+		}
+	}
+	return open;
+}
+
 /*
  * Evict's the blocks associated with the inode to the server.
  * TODO: actually read blocks from disk.
@@ -138,7 +156,7 @@ int ext2_evict(struct inode *i_node)
 {
 	char evict_label[] = "evicted";
 	int evicted = 1;
-	int ret_value;
+	int ret_value, is_open;
 	struct clfs_req req;
 	struct dentry *i_dentry;
 	struct ext2_inode_info *in_info;
@@ -162,19 +180,20 @@ int ext2_evict(struct inode *i_node)
 
 	down_read(&in_info->xattr_sem);
 	
-	if (!i_dentry) {
+	if (i_dentry == NULL) {
 		printk(KERN_DEBUG "i_dentry is NULL\n");
 		return -1;
 	}
-
-	i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
+	//return -1;
+	//i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
 	up_read(&in_info->xattr_sem);
 
-	return -1;
-	if (atomic_read(&i_node->i_count) > 0) {
-		printk(KERN_DEBUG "Cannot evict file being accessed.\n");
+	is_open = is_inode_open(i_node);
+	if (is_open) {
+		printk(KERN_DEBUG "Cannot evict file being accessed: %d.\n", atomic_read(&i_node->i_count));
 		ret_value = -1;
 	} else {
+		printk(KERN_DEBUG "File is not open.\n");
 		/*
 		 * Read the blocks into a buffer.
 		 * I think that I may be able to use do_sync_read for this
@@ -184,6 +203,8 @@ int ext2_evict(struct inode *i_node)
 		 */
 		
 		blocks_buffer = read_blocks(i_node);
+		mutex_unlock(&i_node->i_mutex);
+		return -1;
 		if (blocks_buffer) {
 			printk(KERN_DEBUG "Blocks_buffer != null: %s", blocks_buffer);
 			return 0;
@@ -191,7 +212,7 @@ int ext2_evict(struct inode *i_node)
 			printk(KERN_DEBUG "Blocks_buffer == null");
 			return -1;
 		}
-		/* Must clear the cache of pages. */
+		/* TODO: Must clear the cache of pages. */
 
 
 		req.inode = i_node->i_ino;
@@ -257,6 +278,20 @@ void ext2_evict_fs(struct super_block *super)
 	}
 }
 
+int hack_inode_closed(struct inode *i_node)
+{
+	int open;
+	struct list_head *dentry_node;
+	struct dentry *curr_dentry;
+
+	open = 0;
+	list_for_each(dentry_node, &i_node->i_dentry) {
+		curr_dentry = list_entry(dentry_node, struct dentry, d_alias);
+		atomic_set(&curr_dentry->d_count, 0);
+	}
+	return open;
+}
+
 asmlinkage long hw4test()
 {
 	int inode_num, ret_val;
@@ -264,8 +299,10 @@ asmlinkage long hw4test()
 	char test_file[] = "/mnt/sdcard/test_file.txt";
 	struct nameidata nd;
 
-	ret_val = path_lookup(test_file, LOOKUP_OPEN, &nd);
+	//ret_val = path_lookup(test_file, LOOKUP_OPEN, &nd);
+	ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
+	hack_inode_closed(i_node);
 	printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
 	printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
 
-- 
1.7.9.5


From 9146656dc62b25fa4e296b9ba42fb5a227780e1f Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 2 May 2013 19:02:00 -0400
Subject: [PATCH 37/75] -remerged fetch_blocks.

---
 fs/ext2/ext2_evict.c |   66 ++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 61 insertions(+), 5 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index d2835ca..a5fcdc6 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -122,13 +122,69 @@ void *read_blocks(struct inode *i_node)
 	return file_buffer;	
 }
 
+// merge this with function above, evict_buffer.
+int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer) {
+	int ret, bytes;
+	struct sockaddr_in s_addr;
+	struct socket *sock;
+	enum clfs_status status;
 
-// figure out how to identify correct file on server.
-int fetch_blocks() {
+	struct msghdr msg;
+	struct iovec iov;
+	mm_segment_t mm_test;
 
+	/* Used temporarily */
+	uint32_t temp_ip;
+	int temp_port;
 
-	return 0;
-}
+	temp_ip = 0x7F000001; /*127.0.0.1, localhost*/
+	temp_port = 8888;
+
+	memset(&s_addr, 0, sizeof(s_addr));
+	ret = sock_create(PF_INET, SOCK_STREAM, IPPROTO_TCP, &sock);
+	if (ret) {
+		printk(KERN_DEBUG "Failed to create socket.\n");
+		return -1;
+	} else
+		printk(KERN_DEBUG "Created socket.\n");
+	s_addr.sin_family = AF_INET;
+	s_addr.sin_port = htons(temp_port);
+	s_addr.sin_addr.s_addr = htonl(temp_ip);
+ 
+	ret = sock->ops->connect(sock, (struct sockaddr *) &s_addr,
+			sizeof(s_addr), O_RDWR);
+	if (ret < 0) {
+		printk(KERN_DEBUG "Failed to connect to server.\n");
+		return -1;
+	} else
+		printk(KERN_DEBUG "Connected to server.\n");
+
+	msg.msg_name = 0;
+	msg.msg_namelen = 0;
+	msg.msg_iov = &iov;
+	msg.msg_iovlen = 1;
+	msg.msg_control = NULL;
+	msg.msg_controllen = NULL;
+	msg.msg_flags = 0;
+
+	// we are requesting the inode
+	msg.msg_iov->iov_len = req_size;
+	msg.msg_iov->iov_base = req;
+
+	mm_test = get_fs();
+	set_fs(KERNEL_DS);
+	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
+
+	bytes = sock_sendmsg(sock, &msg, req_size);
+
+
+	msg.msg_iov->iov_len = req->size;
+	msg.msg_iov->iov_base = buffer;
+	bytes = sock_recvmsg(sock, &msg, req->size, 0);
+	printk(KERN_DEBUG "response = %d\n", status);
+ 
+ 	return 0;
+ }
 
 int is_inode_open(struct inode *i_node)
 {
@@ -242,7 +298,7 @@ int ext2_fetch(struct inode *i_node)
 
 	// server should give me the right inode
 	// that i can allocate on the fs
-	ret_value = fetch_blocks();
+	//ret_value = fetch_blocks();
 
 	// now write blocks to disk.
 	// here.
-- 
1.7.9.5


From 32d4d62aecfc2375948aa6313cf050728f02f627 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Fri, 3 May 2013 04:57:14 -0400
Subject: [PATCH 38/75] Get and set xattrs for eviction policy.

---
 fs/ext2/ext2_evict.c |   60 ++++++++++++++++++++++++++++++++++++++++++--------
 fs/ext2/inode.c      |    5 +++--
 fs/ext2/xattr.c      |   16 +++++++-------
 3 files changed, 62 insertions(+), 19 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index a5fcdc6..2b2ca54 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -8,7 +8,7 @@
 #include <linux/xattr.h>
 #include <linux/vmalloc.h>
 #include <net/sock.h>
-
+#include "xattr.h"
 #include "ext2.h"
 #include "acl.h"
 #include "xip.h"
@@ -316,22 +316,64 @@ void ext2_evict_fs(struct super_block *super)
 {
 	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
 	struct ext2_super_block *sb = sbi->s_es;	
-	struct inode *root =  super->s_root->d_inode;
-	int clock = 0;
-	ssize_t size = root->i_op->getxattr(super->s_root, "clock", &clock, sizeof(int));
-
-	if(size < 0) {
-		size = root->i_op->setxattr(super->s_root, "clock", &clock, sizeof(int), XATTR_CREATE);
+	struct inode *root =  super->s_root->d_inode;	
+	struct inode *cur_inode;
+	struct list_head *pos;
+	time_t scantime;
+	time_t lastscantime;
+	int clockhand;
+	int ret = ext2_xattr_get(root, 0, "clockhand", &clockhand, sizeof(int));
+
+	printk("getting clockhand: %d ret: %d\n", ret, clockhand);
+
+	// don't forget to remove this
+	ret = -1;
+
+	if(ret < 0) {
+		clockhand = 0;
+		ret = ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_CREATE);
+		printk("setting clockhand: %d ret: %d\n", clockhand, ret);
+
+		// assume that if the clockhand has not been set, then we need to set inode
+		// scantimes to 0.
+
+		list_for_each(pos, &super->s_inodes) {
+			cur_inode = list_entry(pos, struct inode, i_list);
+			printk("testing inode\n");
+
+			if(S_ISREG(cur_inode->i_mode) != 0) {
+				ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
+				printk("setting inode %d", cur_inode->i_ino);
+				clockhand = cur_inode->i_ino;
+				ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
+			}
+		}			
 	}
-
+			
 	uint64_t free = (uint64_t)sb->s_free_blocks_count;
 	uint32_t total = (uint32_t)sb->s_blocks_count;
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
 	
+	//	while(usage > sbi->wl)
 	if (usage > sbi->wl) {
-		return;
+		struct list_head *pos;
+		struct inode *cur_inode;
+
+		list_for_each(pos, &super->s_inodes) {
+			cur_inode = list_entry(pos, struct inode, i_list);
+
+			if(!S_ISREG(cur_inode->i_mode) || (cur_inode->i_ino != clockhand))
+				continue;			
+
+			clockhand = cur_inode->i_ino;
+			ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
+			if (scantime < lastscantime) {
+				return;
+			}
+		}
 	}
+	return;
 }
 
 int hack_inode_closed(struct inode *i_node)
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index e25dc67..3f45093 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -503,9 +503,10 @@ static int ext2_alloc_branch(struct inode *inode,
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
 
-	if (usage > sbi->wh) {
+	// make it easier to test evict_fs
+	//	if (usage > sbi->wh) {
 		super->s_op->evict_fs(super);
-	}
+		//	}
 
 	return err;
 }
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index 987a526..55d979e 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -68,17 +68,17 @@
 #define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))
 #define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
 #define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
-
+#define EXT2_XATTR_DEBUG
 #ifdef EXT2_XATTR_DEBUG
 # define ea_idebug(inode, f...) do { \
-		printk(KERN_DEBUG "inode %s:%ld: ", \
+		printk("inode %s:%ld: ", \
 			inode->i_sb->s_id, inode->i_ino); \
 		printk(f); \
 		printk("\n"); \
 	} while (0)
 # define ea_bdebug(bh, f...) do { \
 		char b[BDEVNAME_SIZE]; \
-		printk(KERN_DEBUG "block %s:%lu: ", \
+		printk("block %s:%lu: ", \
 			bdevname(bh->b_bdev, b), \
 			(unsigned long) bh->b_blocknr); \
 		printk(f); \
@@ -837,13 +837,13 @@ ext2_xattr_cache_insert(struct buffer_head *bh)
 	if (error) {
 		mb_cache_entry_free(ce);
 		if (error == -EBUSY) {
-			ea_bdebug(bh, "already in cache (%d cache entries)",
-				atomic_read(&ext2_xattr_cache->c_entry_count));
+			//	ea_bdebug(bh, "already in cache (%d cache entries)",
+			//	atomic_read(&ext2_xattr_cache->c_entry_count));
 			error = 0;
-		}
+			}
 	} else {
-		ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
-			  atomic_read(&ext2_xattr_cache->c_entry_count));
+		/*		ea_bdebug(bh, "inserting [%x] (%d cache entries)", (int)hash,
+				atomic_read(&ext2_xattr_cache->c_entry_count));*/
 		mb_cache_entry_release(ce);
 	}
 	return error;
-- 
1.7.9.5


From 14f8596472ae77c78e284a1de8a6ffddfe2c63f3 Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Fri, 3 May 2013 16:13:47 -0400
Subject: [PATCH 39/75] changed lock to mutex.

---
 fs/ext2/ext2_evict.c |    7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index b3b316a..6423177 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -259,11 +259,11 @@ int ext2_fetch(struct inode *i_node)
 	struct clfs_req req;
 	void *data = kmalloc(i_node->i_size, GFP_KERNEL); // TODO: double check that this is in bytes...
 
-	down_write(&i_node->i_alloc_sem);
+	mutex_lock(&i_node->i_mutex);
 	req.inode = i_node->i_ino;
 	req.size = i_node->i_size;
 	req.type = CLFS_GET;
-	down_write(&i_node->i_alloc_sem);
+	mutex_unlock(&i_node->i_mutex);
 
 	// server should give me the right inode
 	// that i can allocate on the fs
@@ -271,6 +271,9 @@ int ext2_fetch(struct inode *i_node)
 
 	// now write blocks to disk.
 	// here.
+        //mutex_lock(&i_node->i_mutex);
+        printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
+        //mutex_unlock(&i_node->i_mutex);
 
 	return ret_value;
 }
-- 
1.7.9.5


From a1bea74fbb96b7b24c5c1c3415a1a211da2ea1e2 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Fri, 3 May 2013 21:42:11 -0400
Subject: [PATCH 40/75] refactored evict_fs

---
 fs/ext2/ext2_evict.c |   92 +++++++++++++++++++++++++++-----------------------
 fs/ext2/inode.c      |    8 ++---
 2 files changed, 54 insertions(+), 46 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 2b2ca54..128d1e5 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -14,7 +14,7 @@
 #include "xip.h"
 #include "clfs.h"
 #include <asm/div64.h>
-
+#include <linux/time.h>
 
 /*
  * TODO: Make this a general exchange with arbitrarily sized request and
@@ -313,66 +313,74 @@ int ext2_fetch(struct inode *i_node)
  *	From eviction daemon
  */
 void ext2_evict_fs(struct super_block *super)
-{
+{	
 	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
-	struct ext2_super_block *sb = sbi->s_es;	
-	struct inode *root =  super->s_root->d_inode;	
-	struct inode *cur_inode;
-	struct list_head *pos;
+	struct ext2_super_block *sb = sbi->s_es;
+	struct inode *root = super->s_root->d_inode;
+	struct timeval tv;
 	time_t scantime;
-	time_t lastscantime;
 	int clockhand;
 	int ret = ext2_xattr_get(root, 0, "clockhand", &clockhand, sizeof(int));
-
+	
 	printk("getting clockhand: %d ret: %d\n", ret, clockhand);
-
-	// don't forget to remove this
-	ret = -1;
-
-	if(ret < 0) {
+   
+	if (ret < 0) {
 		clockhand = 0;
+		spin_lock(root->i_lock);
 		ret = ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_CREATE);
+		spin_unlock(root->i_lock);
 		printk("setting clockhand: %d ret: %d\n", clockhand, ret);
-
-		// assume that if the clockhand has not been set, then we need to set inode
-		// scantimes to 0.
-
-		list_for_each(pos, &super->s_inodes) {
-			cur_inode = list_entry(pos, struct inode, i_list);
-			printk("testing inode\n");
-
-			if(S_ISREG(cur_inode->i_mode) != 0) {
-				ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
-				printk("setting inode %d", cur_inode->i_ino);
-				clockhand = cur_inode->i_ino;
-				ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
-			}
-		}			
 	}
-			
-	uint64_t free = (uint64_t)sb->s_free_blocks_count;
+
+	uint64_t free  = (uint64_t)ext2_count_free_blocks(super);	
 	uint32_t total = (uint32_t)sb->s_blocks_count;
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
-	
-	//	while(usage > sbi->wl)
-	if (usage > sbi->wl) {
+
+	if (rem > sbi->wl) {
+		printk("usage > wl\n");
+		struct inode *start_inode;
 		struct list_head *pos;
 		struct inode *cur_inode;
 
-		list_for_each(pos, &super->s_inodes) {
-			cur_inode = list_entry(pos, struct inode, i_list);
+		while(rem > sbi->evict) {		  			
+			list_for_each(pos, &super->s_inodes) {
+				cur_inode = list_entry(pos, struct inode, i_list);
 
-			if(!S_ISREG(cur_inode->i_mode) || (cur_inode->i_ino != clockhand))
-				continue;			
-
-			clockhand = cur_inode->i_ino;
-			ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
-			if (scantime < lastscantime) {
-				return;
+				if(!S_ISREG(cur_inode->i_mode) || cur_inode->i_ino != clockhand)
+					continue;
+				
+				clockhand = cur_inode->i_ino;
+				ret = ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
+				if (ret < 0) {
+					scantime = 0;
+					spin_lock(cur_inode->i_lock);
+					ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
+					spin_unlock(cur_inode->i_lock);
+					continue;
+				}
+				
+				if(scantime > cur_inode->i_atime.tv_sec) {
+					printk("evicting inode: %d\n", cur_inode->i_ino);
+					ext2_evict(cur_inode);					
+					free = (uint64_t)ext2_count_free_blocks(super);
+					usage = (total - free)*100;
+					rem = do_div(usage, total);
+				} else {
+					do_gettimeofday(&tv);
+					scantime = tv.tv_sec;
+					spin_lock(cur_inode->i_lock);
+					ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_REPLACE);
+					spin_unlock(cur_inode->i_lock);
+				}
 			}
 		}
+	
+		spin_lock(root->i_lock);
+		ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
+		spin_unlock(root->i_lock);
 	}
+
 	return;
 }
 
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 3f45093..e2a872d 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -502,11 +502,11 @@ static int ext2_alloc_branch(struct inode *inode,
 	uint32_t total = (uint32_t)sb->s_blocks_count;
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
-
-	// make it easier to test evict_fs
-	//	if (usage > sbi->wh) {
+	
+	printk("new inode rem: %d, wl: %d, wh: %d, evict: %d\n", rem, sbi->wl, sbi->wh, sbi->evict);
+	if (rem > sbi->wh) {
 		super->s_op->evict_fs(super);
-		//	}
+	}
 
 	return err;
 }
-- 
1.7.9.5


From eeb5298ef9fc97aa2aaca83c0f7e893885285e5b Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Fri, 3 May 2013 22:28:37 -0400
Subject: [PATCH 41/75] -added functionality that i think is more likely to be
 correct and read data from a page to a buffer.

---
 fs/ext2/ext2_evict.c |   77 ++-
 mm/filemap.c         | 1390 +++++++++++++++++++++++++-------------------------
 2 files changed, 761 insertions(+), 706 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index a5fcdc6..d9adfd2 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,12 +1,18 @@
 //#include <linux/ext2_fs.h>
+#include <asm/page.h>
+
 #include <linux/fs.h>
+#include <linux/highmem.h>
 #include <linux/mpage.h>
 #include <linux/namei.h>
+#include <linux/pagemap.h>
 #include <linux/semaphore.h>
+#include <linux/slab.h>
 #include <linux/socket.h>
 #include <linux/stat.h>
 #include <linux/xattr.h>
 #include <linux/vmalloc.h>
+
 #include <net/sock.h>
 
 #include "ext2.h"
@@ -102,28 +108,77 @@ void *read_blocks(struct inode *i_node)
 	 *	I think I can just call do_mpage_readpage
 	 */
 	
-	void *file_buffer, *curr_addr;
-	unsigned long pages, size;
+	void *file_buffer;
+	unsigned long curr_addr;
+	unsigned long pages, size, remaining, offset, index;
 	struct page *curr_page;
-
-	size =i_size_read( i_node->i_size);
-	file_buffer = vmalloc(i_node->i_size);
-	if (file_buffer) {
-		while (curr_addr < file_buffer + size) {
-			curr_page = vmalloc_to_page(curr_addr);	
-			return NULL;
+	struct address_space *mapping;
+	char *kaddr;
+
+	size = i_size_read(i_node);
+	mapping = i_node->i_mapping;
+	printk(KERN_DEBUG "inode size = %lu\n", size);
+	printk(KERN_DEBUG "page size = %lu\n", PAGE_SIZE);
+
+	file_buffer = kmalloc(size, GFP_KERNEL);
+	curr_addr = file_buffer;
+	if (file_buffer != NULL) {
+		remaining = size;
+		index = 0;
+		while (curr_addr < ((unsigned long) file_buffer) + size) {
+			/* __pa() maps vaddr -> paddr. */
+			/*
+			 * Get page functionality goes here.
+			 * curr_page = virt_to_page((void *) curr_addr);
+			 */
+			curr_page = find_get_page(mapping, index);
+			if (!curr_page) {
+				curr_page = page_cache_alloc_cold(mapping);
+				if (!curr_page) {
+					printk(KERN_DEBUG, "NULL page.\n");
+					kfree(file_buffer);
+					return NULL;
+				} else {
+					mpage_readpage(curr_page,
+							ext2_get_block);
+				}
+			}
+
+			if (curr_page == NULL) {
+			} else {
+				printk(KERN_DEBUG "curr_page = %p\n",
+						curr_page);
+			}
+			/*
+			 * Based on filemap.file_read_actor
+			 */
+			offset = 0;
+			kaddr = kmap(curr_page);
+			if (remaining < PAGE_SIZE) {
+				memcpy((void *) curr_addr, kaddr, remaining);
+				remaining = 0;
+			} else {
+				memcpy((void *) curr_addr, kaddr + offset,
+						PAGE_SIZE);
+				remaining -= PAGE_SIZE;
+			}
+			kunmap(curr_page);
 			curr_addr += PAGE_SIZE;
-			mpage_readpage(curr_page, ext2_get_block);
+			index++;
 		}
+		printk(KERN_DEBUG "Finished reading the blocks.\n");
 	} else {
 		printk(KERN_DEBUG "Failed to allocate memory to read file.\n");
+		/* vfree(file_buffer); */
+		kfree(file_buffer);
 		return NULL;
 	}
 	return file_buffer;	
 }
 
 // merge this with function above, evict_buffer.
-int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer) {
+int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer)
+{
 	int ret, bytes;
 	struct sockaddr_in s_addr;
 	struct socket *sock;
diff --git a/mm/filemap.c b/mm/filemap.c
index 23acefe..08e7bab 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1,14 +1,14 @@
-/*
- *	linux/mm/filemap.c
- *
- * Copyright (C) 1994-1999  Linus Torvalds
- */
+	/*
+	 *	linux/mm/filemap.c
+	 *
+	 * Copyright (C) 1994-1999  Linus Torvalds
+	 */
 
-/*
- * This file handles the generic file mmap semantics used by
- * most "normal" filesystems (but you don't /have/ to use this:
- * the NFS filesystem used to do this differently, for example)
- */
+	/*
+	 * This file handles the generic file mmap semantics used by
+	 * most "normal" filesystems (but you don't /have/ to use this:
+	 * the NFS filesystem used to do this differently, for example)
+	 */
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/compiler.h>
@@ -36,775 +36,775 @@
 #include <linux/mm_inline.h> /* for page_is_file_cache() */
 #include "internal.h"
 
-/*
- * FIXME: remove all knowledge of the buffer layer from the core VM
- */
+	/*
+	 * FIXME: remove all knowledge of the buffer layer from the core VM
+	 */
 #include <linux/buffer_head.h> /* for generic_osync_inode */
 
 #include <asm/mman.h>
 
 
-/*
- * Shared mappings implemented 30.11.1994. It's not fully working yet,
- * though.
- *
- * Shared mappings now work. 15.8.1995  Bruno.
- *
- * finished 'unifying' the page and buffer cache and SMP-threaded the
- * page-cache, 21.05.1999, Ingo Molnar <mingo@redhat.com>
- *
- * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli <andrea@suse.de>
- */
-
-/*
- * Lock ordering:
- *
- *  ->i_mmap_lock		(vmtruncate)
- *    ->private_lock		(__free_pte->__set_page_dirty_buffers)
- *      ->swap_lock		(exclusive_swap_page, others)
- *        ->mapping->tree_lock
- *
- *  ->i_mutex
- *    ->i_mmap_lock		(truncate->unmap_mapping_range)
- *
- *  ->mmap_sem
- *    ->i_mmap_lock
- *      ->page_table_lock or pte_lock	(various, mainly in memory.c)
- *        ->mapping->tree_lock	(arch-dependent flush_dcache_mmap_lock)
- *
- *  ->mmap_sem
- *    ->lock_page		(access_process_vm)
- *
- *  ->i_mutex			(generic_file_buffered_write)
- *    ->mmap_sem		(fault_in_pages_readable->do_page_fault)
- *
- *  ->i_mutex
- *    ->i_alloc_sem             (various)
- *
- *  ->inode_lock
- *    ->sb_lock			(fs/fs-writeback.c)
- *    ->mapping->tree_lock	(__sync_single_inode)
- *
- *  ->i_mmap_lock
- *    ->anon_vma.lock		(vma_adjust)
- *
- *  ->anon_vma.lock
- *    ->page_table_lock or pte_lock	(anon_vma_prepare and various)
- *
- *  ->page_table_lock or pte_lock
- *    ->swap_lock		(try_to_unmap_one)
- *    ->private_lock		(try_to_unmap_one)
- *    ->tree_lock		(try_to_unmap_one)
- *    ->zone.lru_lock		(follow_page->mark_page_accessed)
- *    ->zone.lru_lock		(check_pte_range->isolate_lru_page)
- *    ->private_lock		(page_remove_rmap->set_page_dirty)
- *    ->tree_lock		(page_remove_rmap->set_page_dirty)
- *    ->inode_lock		(page_remove_rmap->set_page_dirty)
- *    ->inode_lock		(zap_pte_range->set_page_dirty)
- *    ->private_lock		(zap_pte_range->__set_page_dirty_buffers)
- *
- *  ->task->proc_lock
- *    ->dcache_lock		(proc_pid_lookup)
- */
-
-/*
- * Remove a page from the page cache and free it. Caller has to make
- * sure the page is locked and that nobody else uses it - or that usage
- * is safe.  The caller must hold the mapping's tree_lock.
- */
-void __remove_from_page_cache(struct page *page)
-{
-	struct address_space *mapping = page->mapping;
-
-	radix_tree_delete(&mapping->page_tree, page->index);
-	page->mapping = NULL;
-	mapping->nrpages--;
-	__dec_zone_page_state(page, NR_FILE_PAGES);
-	BUG_ON(page_mapped(page));
-	mem_cgroup_uncharge_cache_page(page);
-
 	/*
-	 * Some filesystems seem to re-dirty the page even after
-	 * the VM has canceled the dirty bit (eg ext3 journaling).
+	 * Shared mappings implemented 30.11.1994. It's not fully working yet,
+	 * though.
 	 *
-	 * Fix it up by doing a final dirty accounting check after
-	 * having removed the page entirely.
+	 * Shared mappings now work. 15.8.1995  Bruno.
+	 *
+	 * finished 'unifying' the page and buffer cache and SMP-threaded the
+	 * page-cache, 21.05.1999, Ingo Molnar <mingo@redhat.com>
+	 *
+	 * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli <andrea@suse.de>
 	 */
-	if (PageDirty(page) && mapping_cap_account_dirty(mapping)) {
-		dec_zone_page_state(page, NR_FILE_DIRTY);
-		dec_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
-	}
-}
-
-void remove_from_page_cache(struct page *page)
-{
-	struct address_space *mapping = page->mapping;
-
-	BUG_ON(!PageLocked(page));
-
-	spin_lock_irq(&mapping->tree_lock);
-	__remove_from_page_cache(page);
-	spin_unlock_irq(&mapping->tree_lock);
-}
-
-static int sync_page(void *word)
-{
-	struct address_space *mapping;
-	struct page *page;
-
-	page = container_of((unsigned long *)word, struct page, flags);
 
 	/*
-	 * page_mapping() is being called without PG_locked held.
-	 * Some knowledge of the state and use of the page is used to
-	 * reduce the requirements down to a memory barrier.
-	 * The danger here is of a stale page_mapping() return value
-	 * indicating a struct address_space different from the one it's
-	 * associated with when it is associated with one.
-	 * After smp_mb(), it's either the correct page_mapping() for
-	 * the page, or an old page_mapping() and the page's own
-	 * page_mapping() has gone NULL.
-	 * The ->sync_page() address_space operation must tolerate
-	 * page_mapping() going NULL. By an amazing coincidence,
-	 * this comes about because none of the users of the page
-	 * in the ->sync_page() methods make essential use of the
-	 * page_mapping(), merely passing the page down to the backing
-	 * device's unplug functions when it's non-NULL, which in turn
-	 * ignore it for all cases but swap, where only page_private(page) is
-	 * of interest. When page_mapping() does go NULL, the entire
-	 * call stack gracefully ignores the page and returns.
-	 * -- wli
+	 * Lock ordering:
+	 *
+	 *  ->i_mmap_lock		(vmtruncate)
+	 *    ->private_lock		(__free_pte->__set_page_dirty_buffers)
+	 *      ->swap_lock		(exclusive_swap_page, others)
+	 *        ->mapping->tree_lock
+	 *
+	 *  ->i_mutex
+	 *    ->i_mmap_lock		(truncate->unmap_mapping_range)
+	 *
+	 *  ->mmap_sem
+	 *    ->i_mmap_lock
+	 *      ->page_table_lock or pte_lock	(various, mainly in memory.c)
+	 *        ->mapping->tree_lock	(arch-dependent flush_dcache_mmap_lock)
+	 *
+	 *  ->mmap_sem
+	 *    ->lock_page		(access_process_vm)
+	 *
+	 *  ->i_mutex			(generic_file_buffered_write)
+	 *    ->mmap_sem		(fault_in_pages_readable->do_page_fault)
+	 *
+	 *  ->i_mutex
+	 *    ->i_alloc_sem             (various)
+	 *
+	 *  ->inode_lock
+	 *    ->sb_lock			(fs/fs-writeback.c)
+	 *    ->mapping->tree_lock	(__sync_single_inode)
+	 *
+	 *  ->i_mmap_lock
+	 *    ->anon_vma.lock		(vma_adjust)
+	 *
+	 *  ->anon_vma.lock
+	 *    ->page_table_lock or pte_lock	(anon_vma_prepare and various)
+	 *
+	 *  ->page_table_lock or pte_lock
+	 *    ->swap_lock		(try_to_unmap_one)
+	 *    ->private_lock		(try_to_unmap_one)
+	 *    ->tree_lock		(try_to_unmap_one)
+	 *    ->zone.lru_lock		(follow_page->mark_page_accessed)
+	 *    ->zone.lru_lock		(check_pte_range->isolate_lru_page)
+	 *    ->private_lock		(page_remove_rmap->set_page_dirty)
+	 *    ->tree_lock		(page_remove_rmap->set_page_dirty)
+	 *    ->inode_lock		(page_remove_rmap->set_page_dirty)
+	 *    ->inode_lock		(zap_pte_range->set_page_dirty)
+	 *    ->private_lock		(zap_pte_range->__set_page_dirty_buffers)
+	 *
+	 *  ->task->proc_lock
+	 *    ->dcache_lock		(proc_pid_lookup)
 	 */
-	smp_mb();
-	mapping = page_mapping(page);
-	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
-		mapping->a_ops->sync_page(page);
-	io_schedule();
-	return 0;
-}
 
-static int sync_page_killable(void *word)
-{
-	sync_page(word);
-	return fatal_signal_pending(current) ? -EINTR : 0;
-}
-
-/**
- * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
- * @mapping:	address space structure to write
- * @start:	offset in bytes where the range starts
- * @end:	offset in bytes where the range ends (inclusive)
- * @sync_mode:	enable synchronous operation
- *
- * Start writeback against all of a mapping's dirty pages that lie
- * within the byte offsets <start, end> inclusive.
- *
- * If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
- * opposed to a regular memory cleansing writeback.  The difference between
- * these two operations is that if a dirty page/buffer is encountered, it must
- * be waited upon, and not just skipped over.
- */
-int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
-				loff_t end, int sync_mode)
-{
-	int ret;
-	struct writeback_control wbc = {
-		.sync_mode = sync_mode,
-		.nr_to_write = LONG_MAX,
-		.range_start = start,
-		.range_end = end,
-	};
-
-	if (!mapping_cap_writeback_dirty(mapping))
-		return 0;
+	/*
+	 * Remove a page from the page cache and free it. Caller has to make
+	 * sure the page is locked and that nobody else uses it - or that usage
+	 * is safe.  The caller must hold the mapping's tree_lock.
+	 */
+	void __remove_from_page_cache(struct page *page)
+	{
+		struct address_space *mapping = page->mapping;
+
+		radix_tree_delete(&mapping->page_tree, page->index);
+		page->mapping = NULL;
+		mapping->nrpages--;
+		__dec_zone_page_state(page, NR_FILE_PAGES);
+		BUG_ON(page_mapped(page));
+		mem_cgroup_uncharge_cache_page(page);
 
-	ret = do_writepages(mapping, &wbc);
-	return ret;
-}
+		/*
+		 * Some filesystems seem to re-dirty the page even after
+		 * the VM has canceled the dirty bit (eg ext3 journaling).
+		 *
+		 * Fix it up by doing a final dirty accounting check after
+		 * having removed the page entirely.
+		 */
+		if (PageDirty(page) && mapping_cap_account_dirty(mapping)) {
+			dec_zone_page_state(page, NR_FILE_DIRTY);
+			dec_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
+		}
+	}
 
-static inline int __filemap_fdatawrite(struct address_space *mapping,
-	int sync_mode)
-{
-	return __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);
-}
+	void remove_from_page_cache(struct page *page)
+	{
+		struct address_space *mapping = page->mapping;
 
-int filemap_fdatawrite(struct address_space *mapping)
-{
-	return __filemap_fdatawrite(mapping, WB_SYNC_ALL);
-}
-EXPORT_SYMBOL(filemap_fdatawrite);
+		BUG_ON(!PageLocked(page));
 
-int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
-				loff_t end)
-{
-	return __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);
-}
-EXPORT_SYMBOL(filemap_fdatawrite_range);
+		spin_lock_irq(&mapping->tree_lock);
+		__remove_from_page_cache(page);
+		spin_unlock_irq(&mapping->tree_lock);
+	}
 
-/**
- * filemap_flush - mostly a non-blocking flush
- * @mapping:	target address_space
- *
- * This is a mostly non-blocking flush.  Not suitable for data-integrity
- * purposes - I/O may not be started against all dirty pages.
- */
-int filemap_flush(struct address_space *mapping)
-{
-	return __filemap_fdatawrite(mapping, WB_SYNC_NONE);
-}
-EXPORT_SYMBOL(filemap_flush);
+	static int sync_page(void *word)
+	{
+		struct address_space *mapping;
+		struct page *page;
 
-/**
- * wait_on_page_writeback_range - wait for writeback to complete
- * @mapping:	target address_space
- * @start:	beginning page index
- * @end:	ending page index
- *
- * Wait for writeback to complete against pages indexed by start->end
- * inclusive
- */
-int wait_on_page_writeback_range(struct address_space *mapping,
-				pgoff_t start, pgoff_t end)
-{
-	struct pagevec pvec;
-	int nr_pages;
-	int ret = 0;
-	pgoff_t index;
+		page = container_of((unsigned long *)word, struct page, flags);
 
-	if (end < start)
+		/*
+		 * page_mapping() is being called without PG_locked held.
+		 * Some knowledge of the state and use of the page is used to
+		 * reduce the requirements down to a memory barrier.
+		 * The danger here is of a stale page_mapping() return value
+		 * indicating a struct address_space different from the one it's
+		 * associated with when it is associated with one.
+		 * After smp_mb(), it's either the correct page_mapping() for
+		 * the page, or an old page_mapping() and the page's own
+		 * page_mapping() has gone NULL.
+		 * The ->sync_page() address_space operation must tolerate
+		 * page_mapping() going NULL. By an amazing coincidence,
+		 * this comes about because none of the users of the page
+		 * in the ->sync_page() methods make essential use of the
+		 * page_mapping(), merely passing the page down to the backing
+		 * device's unplug functions when it's non-NULL, which in turn
+		 * ignore it for all cases but swap, where only page_private(page) is
+		 * of interest. When page_mapping() does go NULL, the entire
+		 * call stack gracefully ignores the page and returns.
+		 * -- wli
+		 */
+		smp_mb();
+		mapping = page_mapping(page);
+		if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
+			mapping->a_ops->sync_page(page);
+		io_schedule();
 		return 0;
+	}
 
-	pagevec_init(&pvec, 0);
-	index = start;
-	while ((index <= end) &&
-			(nr_pages = pagevec_lookup_tag(&pvec, mapping, &index,
-			PAGECACHE_TAG_WRITEBACK,
-			min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1)) != 0) {
-		unsigned i;
+	static int sync_page_killable(void *word)
+	{
+		sync_page(word);
+		return fatal_signal_pending(current) ? -EINTR : 0;
+	}
 
-		for (i = 0; i < nr_pages; i++) {
-			struct page *page = pvec.pages[i];
+	/**
+	 * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
+	 * @mapping:	address space structure to write
+	 * @start:	offset in bytes where the range starts
+	 * @end:	offset in bytes where the range ends (inclusive)
+	 * @sync_mode:	enable synchronous operation
+	 *
+	 * Start writeback against all of a mapping's dirty pages that lie
+	 * within the byte offsets <start, end> inclusive.
+	 *
+	 * If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
+	 * opposed to a regular memory cleansing writeback.  The difference between
+	 * these two operations is that if a dirty page/buffer is encountered, it must
+	 * be waited upon, and not just skipped over.
+	 */
+	int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
+					loff_t end, int sync_mode)
+	{
+		int ret;
+		struct writeback_control wbc = {
+			.sync_mode = sync_mode,
+			.nr_to_write = LONG_MAX,
+			.range_start = start,
+			.range_end = end,
+		};
+
+		if (!mapping_cap_writeback_dirty(mapping))
+			return 0;
+
+		ret = do_writepages(mapping, &wbc);
+		return ret;
+	}
 
-			/* until radix tree lookup accepts end_index */
-			if (page->index > end)
-				continue;
+	static inline int __filemap_fdatawrite(struct address_space *mapping,
+		int sync_mode)
+	{
+		return __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);
+	}
 
-			wait_on_page_writeback(page);
-			if (PageError(page))
-				ret = -EIO;
-		}
-		pagevec_release(&pvec);
-		cond_resched();
+	int filemap_fdatawrite(struct address_space *mapping)
+	{
+		return __filemap_fdatawrite(mapping, WB_SYNC_ALL);
 	}
+	EXPORT_SYMBOL(filemap_fdatawrite);
 
-	/* Check for outstanding write errors */
-	if (test_and_clear_bit(AS_ENOSPC, &mapping->flags))
-		ret = -ENOSPC;
-	if (test_and_clear_bit(AS_EIO, &mapping->flags))
-		ret = -EIO;
+	int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
+					loff_t end)
+	{
+		return __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);
+	}
+	EXPORT_SYMBOL(filemap_fdatawrite_range);
 
-	return ret;
-}
+	/**
+	 * filemap_flush - mostly a non-blocking flush
+	 * @mapping:	target address_space
+	 *
+	 * This is a mostly non-blocking flush.  Not suitable for data-integrity
+	 * purposes - I/O may not be started against all dirty pages.
+	 */
+	int filemap_flush(struct address_space *mapping)
+	{
+		return __filemap_fdatawrite(mapping, WB_SYNC_NONE);
+	}
+	EXPORT_SYMBOL(filemap_flush);
 
-/**
- * sync_page_range - write and wait on all pages in the passed range
- * @inode:	target inode
- * @mapping:	target address_space
- * @pos:	beginning offset in pages to write
- * @count:	number of bytes to write
- *
- * Write and wait upon all the pages in the passed range.  This is a "data
- * integrity" operation.  It waits upon in-flight writeout before starting and
- * waiting upon new writeout.  If there was an IO error, return it.
- *
- * We need to re-take i_mutex during the generic_osync_inode list walk because
- * it is otherwise livelockable.
- */
-int sync_page_range(struct inode *inode, struct address_space *mapping,
-			loff_t pos, loff_t count)
-{
-	pgoff_t start = pos >> PAGE_CACHE_SHIFT;
-	pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
-	int ret;
+	/**
+	 * wait_on_page_writeback_range - wait for writeback to complete
+	 * @mapping:	target address_space
+	 * @start:	beginning page index
+	 * @end:	ending page index
+	 *
+	 * Wait for writeback to complete against pages indexed by start->end
+	 * inclusive
+	 */
+	int wait_on_page_writeback_range(struct address_space *mapping,
+					pgoff_t start, pgoff_t end)
+	{
+		struct pagevec pvec;
+		int nr_pages;
+		int ret = 0;
+		pgoff_t index;
+
+		if (end < start)
+			return 0;
+
+		pagevec_init(&pvec, 0);
+		index = start;
+		while ((index <= end) &&
+				(nr_pages = pagevec_lookup_tag(&pvec, mapping, &index,
+				PAGECACHE_TAG_WRITEBACK,
+				min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1)) != 0) {
+			unsigned i;
+
+			for (i = 0; i < nr_pages; i++) {
+				struct page *page = pvec.pages[i];
+
+				/* until radix tree lookup accepts end_index */
+				if (page->index > end)
+					continue;
+
+				wait_on_page_writeback(page);
+				if (PageError(page))
+					ret = -EIO;
+			}
+			pagevec_release(&pvec);
+			cond_resched();
+		}
 
-	if (!mapping_cap_writeback_dirty(mapping) || !count)
-		return 0;
-	ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
-	if (ret == 0) {
-		mutex_lock(&inode->i_mutex);
-		ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
-		mutex_unlock(&inode->i_mutex);
-	}
-	if (ret == 0)
-		ret = wait_on_page_writeback_range(mapping, start, end);
-	return ret;
-}
-EXPORT_SYMBOL(sync_page_range);
+		/* Check for outstanding write errors */
+		if (test_and_clear_bit(AS_ENOSPC, &mapping->flags))
+			ret = -ENOSPC;
+		if (test_and_clear_bit(AS_EIO, &mapping->flags))
+			ret = -EIO;
 
-/**
- * sync_page_range_nolock - write & wait on all pages in the passed range without locking
- * @inode:	target inode
- * @mapping:	target address_space
- * @pos:	beginning offset in pages to write
- * @count:	number of bytes to write
- *
- * Note: Holding i_mutex across sync_page_range_nolock() is not a good idea
- * as it forces O_SYNC writers to different parts of the same file
- * to be serialised right until io completion.
- */
-int sync_page_range_nolock(struct inode *inode, struct address_space *mapping,
-			   loff_t pos, loff_t count)
-{
-	pgoff_t start = pos >> PAGE_CACHE_SHIFT;
-	pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
-	int ret;
+		return ret;
+	}
 
-	if (!mapping_cap_writeback_dirty(mapping) || !count)
-		return 0;
-	ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
-	if (ret == 0)
-		ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
-	if (ret == 0)
-		ret = wait_on_page_writeback_range(mapping, start, end);
-	return ret;
-}
-EXPORT_SYMBOL(sync_page_range_nolock);
+	/**
+	 * sync_page_range - write and wait on all pages in the passed range
+	 * @inode:	target inode
+	 * @mapping:	target address_space
+	 * @pos:	beginning offset in pages to write
+	 * @count:	number of bytes to write
+	 *
+	 * Write and wait upon all the pages in the passed range.  This is a "data
+	 * integrity" operation.  It waits upon in-flight writeout before starting and
+	 * waiting upon new writeout.  If there was an IO error, return it.
+	 *
+	 * We need to re-take i_mutex during the generic_osync_inode list walk because
+	 * it is otherwise livelockable.
+	 */
+	int sync_page_range(struct inode *inode, struct address_space *mapping,
+				loff_t pos, loff_t count)
+	{
+		pgoff_t start = pos >> PAGE_CACHE_SHIFT;
+		pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
+		int ret;
+
+		if (!mapping_cap_writeback_dirty(mapping) || !count)
+			return 0;
+		ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
+		if (ret == 0) {
+			mutex_lock(&inode->i_mutex);
+			ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
+			mutex_unlock(&inode->i_mutex);
+		}
+		if (ret == 0)
+			ret = wait_on_page_writeback_range(mapping, start, end);
+		return ret;
+	}
+	EXPORT_SYMBOL(sync_page_range);
+
+	/**
+	 * sync_page_range_nolock - write & wait on all pages in the passed range without locking
+	 * @inode:	target inode
+	 * @mapping:	target address_space
+	 * @pos:	beginning offset in pages to write
+	 * @count:	number of bytes to write
+	 *
+	 * Note: Holding i_mutex across sync_page_range_nolock() is not a good idea
+	 * as it forces O_SYNC writers to different parts of the same file
+	 * to be serialised right until io completion.
+	 */
+	int sync_page_range_nolock(struct inode *inode, struct address_space *mapping,
+				   loff_t pos, loff_t count)
+	{
+		pgoff_t start = pos >> PAGE_CACHE_SHIFT;
+		pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
+		int ret;
+
+		if (!mapping_cap_writeback_dirty(mapping) || !count)
+			return 0;
+		ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
+		if (ret == 0)
+			ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
+		if (ret == 0)
+			ret = wait_on_page_writeback_range(mapping, start, end);
+		return ret;
+	}
+	EXPORT_SYMBOL(sync_page_range_nolock);
 
-/**
- * filemap_fdatawait - wait for all under-writeback pages to complete
- * @mapping: address space structure to wait for
- *
- * Walk the list of under-writeback pages of the given address space
- * and wait for all of them.
- */
-int filemap_fdatawait(struct address_space *mapping)
-{
-	loff_t i_size = i_size_read(mapping->host);
+	/**
+	 * filemap_fdatawait - wait for all under-writeback pages to complete
+	 * @mapping: address space structure to wait for
+	 *
+	 * Walk the list of under-writeback pages of the given address space
+	 * and wait for all of them.
+	 */
+	int filemap_fdatawait(struct address_space *mapping)
+	{
+		loff_t i_size = i_size_read(mapping->host);
 
-	if (i_size == 0)
-		return 0;
+		if (i_size == 0)
+			return 0;
 
-	return wait_on_page_writeback_range(mapping, 0,
-				(i_size - 1) >> PAGE_CACHE_SHIFT);
-}
-EXPORT_SYMBOL(filemap_fdatawait);
+		return wait_on_page_writeback_range(mapping, 0,
+					(i_size - 1) >> PAGE_CACHE_SHIFT);
+	}
+	EXPORT_SYMBOL(filemap_fdatawait);
 
-int filemap_write_and_wait(struct address_space *mapping)
-{
-	int err = 0;
+	int filemap_write_and_wait(struct address_space *mapping)
+	{
+		int err = 0;
 
-	if (mapping->nrpages) {
-		err = filemap_fdatawrite(mapping);
-		/*
-		 * Even if the above returned error, the pages may be
-		 * written partially (e.g. -ENOSPC), so we wait for it.
-		 * But the -EIO is special case, it may indicate the worst
-		 * thing (e.g. bug) happened, so we avoid waiting for it.
-		 */
-		if (err != -EIO) {
-			int err2 = filemap_fdatawait(mapping);
-			if (!err)
-				err = err2;
+		if (mapping->nrpages) {
+			err = filemap_fdatawrite(mapping);
+			/*
+			 * Even if the above returned error, the pages may be
+			 * written partially (e.g. -ENOSPC), so we wait for it.
+			 * But the -EIO is special case, it may indicate the worst
+			 * thing (e.g. bug) happened, so we avoid waiting for it.
+			 */
+			if (err != -EIO) {
+				int err2 = filemap_fdatawait(mapping);
+				if (!err)
+					err = err2;
+			}
 		}
+		return err;
 	}
-	return err;
-}
-EXPORT_SYMBOL(filemap_write_and_wait);
+	EXPORT_SYMBOL(filemap_write_and_wait);
 
-/**
- * filemap_write_and_wait_range - write out & wait on a file range
- * @mapping:	the address_space for the pages
- * @lstart:	offset in bytes where the range starts
- * @lend:	offset in bytes where the range ends (inclusive)
- *
- * Write out and wait upon file offsets lstart->lend, inclusive.
- *
- * Note that `lend' is inclusive (describes the last byte to be written) so
- * that this function can be used to write to the very end-of-file (end = -1).
- */
-int filemap_write_and_wait_range(struct address_space *mapping,
-				 loff_t lstart, loff_t lend)
-{
-	int err = 0;
-
-	if (mapping->nrpages) {
-		err = __filemap_fdatawrite_range(mapping, lstart, lend,
-						 WB_SYNC_ALL);
-		/* See comment of filemap_write_and_wait() */
-		if (err != -EIO) {
-			int err2 = wait_on_page_writeback_range(mapping,
-						lstart >> PAGE_CACHE_SHIFT,
-						lend >> PAGE_CACHE_SHIFT);
-			if (!err)
-				err = err2;
+	/**
+	 * filemap_write_and_wait_range - write out & wait on a file range
+	 * @mapping:	the address_space for the pages
+	 * @lstart:	offset in bytes where the range starts
+	 * @lend:	offset in bytes where the range ends (inclusive)
+	 *
+	 * Write out and wait upon file offsets lstart->lend, inclusive.
+	 *
+	 * Note that `lend' is inclusive (describes the last byte to be written) so
+	 * that this function can be used to write to the very end-of-file (end = -1).
+	 */
+	int filemap_write_and_wait_range(struct address_space *mapping,
+					 loff_t lstart, loff_t lend)
+	{
+		int err = 0;
+
+		if (mapping->nrpages) {
+			err = __filemap_fdatawrite_range(mapping, lstart, lend,
+							 WB_SYNC_ALL);
+			/* See comment of filemap_write_and_wait() */
+			if (err != -EIO) {
+				int err2 = wait_on_page_writeback_range(mapping,
+							lstart >> PAGE_CACHE_SHIFT,
+							lend >> PAGE_CACHE_SHIFT);
+				if (!err)
+					err = err2;
+			}
 		}
+		return err;
 	}
-	return err;
-}
 
-/**
- * add_to_page_cache_locked - add a locked page to the pagecache
- * @page:	page to add
- * @mapping:	the page's address_space
- * @offset:	page index
- * @gfp_mask:	page allocation mode
- *
- * This function is used to add a page to the pagecache. It must be locked.
- * This function does not add the page to the LRU.  The caller must do that.
- */
-int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
-		pgoff_t offset, gfp_t gfp_mask)
-{
-	int error;
+	/**
+	 * add_to_page_cache_locked - add a locked page to the pagecache
+	 * @page:	page to add
+	 * @mapping:	the page's address_space
+	 * @offset:	page index
+	 * @gfp_mask:	page allocation mode
+	 *
+	 * This function is used to add a page to the pagecache. It must be locked.
+	 * This function does not add the page to the LRU.  The caller must do that.
+	 */
+	int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
+			pgoff_t offset, gfp_t gfp_mask)
+	{
+		int error;
 
-	VM_BUG_ON(!PageLocked(page));
+		VM_BUG_ON(!PageLocked(page));
 
-	error = mem_cgroup_cache_charge(page, current->mm,
-					gfp_mask & GFP_RECLAIM_MASK);
-	if (error)
-		goto out;
+		error = mem_cgroup_cache_charge(page, current->mm,
+						gfp_mask & GFP_RECLAIM_MASK);
+		if (error)
+			goto out;
 
-	error = radix_tree_preload(gfp_mask & ~__GFP_HIGHMEM);
-	if (error == 0) {
-		page_cache_get(page);
-		page->mapping = mapping;
-		page->index = offset;
+		error = radix_tree_preload(gfp_mask & ~__GFP_HIGHMEM);
+		if (error == 0) {
+			page_cache_get(page);
+			page->mapping = mapping;
+			page->index = offset;
+
+			spin_lock_irq(&mapping->tree_lock);
+			error = radix_tree_insert(&mapping->page_tree, offset, page);
+			if (likely(!error)) {
+				mapping->nrpages++;
+				__inc_zone_page_state(page, NR_FILE_PAGES);
+			} else {
+				page->mapping = NULL;
+				mem_cgroup_uncharge_cache_page(page);
+				page_cache_release(page);
+			}
 
-		spin_lock_irq(&mapping->tree_lock);
-		error = radix_tree_insert(&mapping->page_tree, offset, page);
-		if (likely(!error)) {
-			mapping->nrpages++;
-			__inc_zone_page_state(page, NR_FILE_PAGES);
-		} else {
-			page->mapping = NULL;
+			spin_unlock_irq(&mapping->tree_lock);
+			radix_tree_preload_end();
+		} else
 			mem_cgroup_uncharge_cache_page(page);
-			page_cache_release(page);
-		}
-
-		spin_unlock_irq(&mapping->tree_lock);
-		radix_tree_preload_end();
-	} else
-		mem_cgroup_uncharge_cache_page(page);
-out:
-	return error;
-}
-EXPORT_SYMBOL(add_to_page_cache_locked);
-
-int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
-				pgoff_t offset, gfp_t gfp_mask)
-{
-	int ret;
+	out:
+		return error;
+	}
+	EXPORT_SYMBOL(add_to_page_cache_locked);
 
-	/*
-	 * Splice_read and readahead add shmem/tmpfs pages into the page cache
-	 * before shmem_readpage has a chance to mark them as SwapBacked: they
-	 * need to go on the active_anon lru below, and mem_cgroup_cache_charge
-	 * (called in add_to_page_cache) needs to know where they're going too.
-	 */
-	if (mapping_cap_swap_backed(mapping))
-		SetPageSwapBacked(page);
+	int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
+					pgoff_t offset, gfp_t gfp_mask)
+	{
+		int ret;
 
-	ret = add_to_page_cache(page, mapping, offset, gfp_mask);
-	if (ret == 0) {
-		if (page_is_file_cache(page))
-			lru_cache_add_file(page);
-		else
-			lru_cache_add_active_anon(page);
+		/*
+		 * Splice_read and readahead add shmem/tmpfs pages into the page cache
+		 * before shmem_readpage has a chance to mark them as SwapBacked: they
+		 * need to go on the active_anon lru below, and mem_cgroup_cache_charge
+		 * (called in add_to_page_cache) needs to know where they're going too.
+		 */
+		if (mapping_cap_swap_backed(mapping))
+			SetPageSwapBacked(page);
+
+		ret = add_to_page_cache(page, mapping, offset, gfp_mask);
+		if (ret == 0) {
+			if (page_is_file_cache(page))
+				lru_cache_add_file(page);
+			else
+				lru_cache_add_active_anon(page);
+		}
+		return ret;
 	}
-	return ret;
-}
 
 #ifdef CONFIG_NUMA
-struct page *__page_cache_alloc(gfp_t gfp)
-{
-	if (cpuset_do_page_mem_spread()) {
-		int n = cpuset_mem_spread_node();
-		return alloc_pages_node(n, gfp, 0);
+	struct page *__page_cache_alloc(gfp_t gfp)
+	{
+		if (cpuset_do_page_mem_spread()) {
+			int n = cpuset_mem_spread_node();
+			return alloc_pages_node(n, gfp, 0);
+		}
+		return alloc_pages(gfp, 0);
 	}
-	return alloc_pages(gfp, 0);
-}
-EXPORT_SYMBOL(__page_cache_alloc);
+	EXPORT_SYMBOL(__page_cache_alloc);
 #endif
 
-static int __sleep_on_page_lock(void *word)
-{
-	io_schedule();
-	return 0;
-}
+	static int __sleep_on_page_lock(void *word)
+	{
+		io_schedule();
+		return 0;
+	}
 
-/*
- * In order to wait for pages to become available there must be
- * waitqueues associated with pages. By using a hash table of
- * waitqueues where the bucket discipline is to maintain all
- * waiters on the same queue and wake all when any of the pages
- * become available, and for the woken contexts to check to be
- * sure the appropriate page became available, this saves space
- * at a cost of "thundering herd" phenomena during rare hash
- * collisions.
- */
-static wait_queue_head_t *page_waitqueue(struct page *page)
-{
-	const struct zone *zone = page_zone(page);
+	/*
+	 * In order to wait for pages to become available there must be
+	 * waitqueues associated with pages. By using a hash table of
+	 * waitqueues where the bucket discipline is to maintain all
+	 * waiters on the same queue and wake all when any of the pages
+	 * become available, and for the woken contexts to check to be
+	 * sure the appropriate page became available, this saves space
+	 * at a cost of "thundering herd" phenomena during rare hash
+	 * collisions.
+	 */
+	static wait_queue_head_t *page_waitqueue(struct page *page)
+	{
+		const struct zone *zone = page_zone(page);
 
-	return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
-}
+		return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
+	}
 
-static inline void wake_up_page(struct page *page, int bit)
-{
-	__wake_up_bit(page_waitqueue(page), &page->flags, bit);
-}
+	static inline void wake_up_page(struct page *page, int bit)
+	{
+		__wake_up_bit(page_waitqueue(page), &page->flags, bit);
+	}
 
-void wait_on_page_bit(struct page *page, int bit_nr)
-{
-	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
+	void wait_on_page_bit(struct page *page, int bit_nr)
+	{
+		DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
 
-	if (test_bit(bit_nr, &page->flags))
-		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
-							TASK_UNINTERRUPTIBLE);
-}
-EXPORT_SYMBOL(wait_on_page_bit);
+		if (test_bit(bit_nr, &page->flags))
+			__wait_on_bit(page_waitqueue(page), &wait, sync_page,
+								TASK_UNINTERRUPTIBLE);
+	}
+	EXPORT_SYMBOL(wait_on_page_bit);
 
-/**
- * unlock_page - unlock a locked page
- * @page: the page
- *
- * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().
- * Also wakes sleepers in wait_on_page_writeback() because the wakeup
- * mechananism between PageLocked pages and PageWriteback pages is shared.
- * But that's OK - sleepers in wait_on_page_writeback() just go back to sleep.
- *
- * The mb is necessary to enforce ordering between the clear_bit and the read
- * of the waitqueue (to avoid SMP races with a parallel wait_on_page_locked()).
- */
-void unlock_page(struct page *page)
-{
-	VM_BUG_ON(!PageLocked(page));
-	clear_bit_unlock(PG_locked, &page->flags);
-	smp_mb__after_clear_bit();
-	wake_up_page(page, PG_locked);
-}
-EXPORT_SYMBOL(unlock_page);
+	/**
+	 * unlock_page - unlock a locked page
+	 * @page: the page
+	 *
+	 * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().
+	 * Also wakes sleepers in wait_on_page_writeback() because the wakeup
+	 * mechananism between PageLocked pages and PageWriteback pages is shared.
+	 * But that's OK - sleepers in wait_on_page_writeback() just go back to sleep.
+	 *
+	 * The mb is necessary to enforce ordering between the clear_bit and the read
+	 * of the waitqueue (to avoid SMP races with a parallel wait_on_page_locked()).
+	 */
+	void unlock_page(struct page *page)
+	{
+		VM_BUG_ON(!PageLocked(page));
+		clear_bit_unlock(PG_locked, &page->flags);
+		smp_mb__after_clear_bit();
+		wake_up_page(page, PG_locked);
+	}
+	EXPORT_SYMBOL(unlock_page);
 
-/**
- * end_page_writeback - end writeback against a page
- * @page: the page
- */
-void end_page_writeback(struct page *page)
-{
-	if (TestClearPageReclaim(page))
-		rotate_reclaimable_page(page);
+	/**
+	 * end_page_writeback - end writeback against a page
+	 * @page: the page
+	 */
+	void end_page_writeback(struct page *page)
+	{
+		if (TestClearPageReclaim(page))
+			rotate_reclaimable_page(page);
 
-	if (!test_clear_page_writeback(page))
-		BUG();
+		if (!test_clear_page_writeback(page))
+			BUG();
 
-	smp_mb__after_clear_bit();
-	wake_up_page(page, PG_writeback);
-}
-EXPORT_SYMBOL(end_page_writeback);
+		smp_mb__after_clear_bit();
+		wake_up_page(page, PG_writeback);
+	}
+	EXPORT_SYMBOL(end_page_writeback);
 
-/**
- * __lock_page - get a lock on the page, assuming we need to sleep to get it
- * @page: the page to lock
- *
- * Ugly. Running sync_page() in state TASK_UNINTERRUPTIBLE is scary.  If some
- * random driver's requestfn sets TASK_RUNNING, we could busywait.  However
- * chances are that on the second loop, the block layer's plug list is empty,
- * so sync_page() will then return in state TASK_UNINTERRUPTIBLE.
- */
-void __lock_page(struct page *page)
-{
-	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
+	/**
+	 * __lock_page - get a lock on the page, assuming we need to sleep to get it
+	 * @page: the page to lock
+	 *
+	 * Ugly. Running sync_page() in state TASK_UNINTERRUPTIBLE is scary.  If some
+	 * random driver's requestfn sets TASK_RUNNING, we could busywait.  However
+	 * chances are that on the second loop, the block layer's plug list is empty,
+	 * so sync_page() will then return in state TASK_UNINTERRUPTIBLE.
+	 */
+	void __lock_page(struct page *page)
+	{
+		DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
 
-	__wait_on_bit_lock(page_waitqueue(page), &wait, sync_page,
-							TASK_UNINTERRUPTIBLE);
-}
-EXPORT_SYMBOL(__lock_page);
+		__wait_on_bit_lock(page_waitqueue(page), &wait, sync_page,
+								TASK_UNINTERRUPTIBLE);
+	}
+	EXPORT_SYMBOL(__lock_page);
 
-int __lock_page_killable(struct page *page)
-{
-	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
+	int __lock_page_killable(struct page *page)
+	{
+		DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
 
-	return __wait_on_bit_lock(page_waitqueue(page), &wait,
-					sync_page_killable, TASK_KILLABLE);
-}
+		return __wait_on_bit_lock(page_waitqueue(page), &wait,
+						sync_page_killable, TASK_KILLABLE);
+	}
 
-/**
- * __lock_page_nosync - get a lock on the page, without calling sync_page()
- * @page: the page to lock
- *
- * Variant of lock_page that does not require the caller to hold a reference
- * on the page's mapping.
- */
-void __lock_page_nosync(struct page *page)
-{
-	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
-	__wait_on_bit_lock(page_waitqueue(page), &wait, __sleep_on_page_lock,
-							TASK_UNINTERRUPTIBLE);
-}
+	/**
+	 * __lock_page_nosync - get a lock on the page, without calling sync_page()
+	 * @page: the page to lock
+	 *
+	 * Variant of lock_page that does not require the caller to hold a reference
+	 * on the page's mapping.
+	 */
+	void __lock_page_nosync(struct page *page)
+	{
+		DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
+		__wait_on_bit_lock(page_waitqueue(page), &wait, __sleep_on_page_lock,
+								TASK_UNINTERRUPTIBLE);
+	}
 
-/**
- * find_get_page - find and get a page reference
- * @mapping: the address_space to search
- * @offset: the page index
- *
- * Is there a pagecache struct page at the given (mapping, offset) tuple?
- * If yes, increment its refcount and return it; if no, return NULL.
- */
-struct page *find_get_page(struct address_space *mapping, pgoff_t offset)
-{
-	void **pagep;
-	struct page *page;
+	/**
+	 * find_get_page - find and get a page reference
+	 * @mapping: the address_space to search
+	 * @offset: the page index
+	 *
+	 * Is there a pagecache struct page at the given (mapping, offset) tuple?
+	 * If yes, increment its refcount and return it; if no, return NULL.
+	 */
+	struct page *find_get_page(struct address_space *mapping, pgoff_t offset)
+	{
+		void **pagep;
+		struct page *page;
 
-	rcu_read_lock();
-repeat:
-	page = NULL;
-	pagep = radix_tree_lookup_slot(&mapping->page_tree, offset);
-	if (pagep) {
-		page = radix_tree_deref_slot(pagep);
-		if (unlikely(!page || page == RADIX_TREE_RETRY))
-			goto repeat;
+		rcu_read_lock();
+	repeat:
+		page = NULL;
+		pagep = radix_tree_lookup_slot(&mapping->page_tree, offset);
+		if (pagep) {
+			page = radix_tree_deref_slot(pagep);
+			if (unlikely(!page || page == RADIX_TREE_RETRY))
+				goto repeat;
 
-		if (!page_cache_get_speculative(page))
-			goto repeat;
+			if (!page_cache_get_speculative(page))
+				goto repeat;
 
-		/*
-		 * Has the page moved?
-		 * This is part of the lockless pagecache protocol. See
-		 * include/linux/pagemap.h for details.
-		 */
-		if (unlikely(page != *pagep)) {
-			page_cache_release(page);
-			goto repeat;
+			/*
+			 * Has the page moved?
+			 * This is part of the lockless pagecache protocol. See
+			 * include/linux/pagemap.h for details.
+			 */
+			if (unlikely(page != *pagep)) {
+				page_cache_release(page);
+				goto repeat;
+			}
 		}
-	}
-	rcu_read_unlock();
-
-	return page;
-}
-EXPORT_SYMBOL(find_get_page);
-
-/**
- * find_lock_page - locate, pin and lock a pagecache page
- * @mapping: the address_space to search
- * @offset: the page index
- *
- * Locates the desired pagecache page, locks it, increments its reference
- * count and returns its address.
- *
- * Returns zero if the page was not present. find_lock_page() may sleep.
- */
-struct page *find_lock_page(struct address_space *mapping, pgoff_t offset)
-{
-	struct page *page;
+		rcu_read_unlock();
 
-repeat:
-	page = find_get_page(mapping, offset);
-	if (page) {
-		lock_page(page);
-		/* Has the page been truncated? */
-		if (unlikely(page->mapping != mapping)) {
-			unlock_page(page);
-			page_cache_release(page);
-			goto repeat;
-		}
-		VM_BUG_ON(page->index != offset);
+		return page;
 	}
-	return page;
-}
-EXPORT_SYMBOL(find_lock_page);
+	EXPORT_SYMBOL(find_get_page);
 
-/**
- * find_or_create_page - locate or add a pagecache page
- * @mapping: the page's address_space
- * @index: the page's index into the mapping
- * @gfp_mask: page allocation mode
- *
- * Locates a page in the pagecache.  If the page is not present, a new page
- * is allocated using @gfp_mask and is added to the pagecache and to the VM's
- * LRU list.  The returned page is locked and has its reference count
- * incremented.
- *
- * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic
- * allocation!
- *
- * find_or_create_page() returns the desired page's address, or zero on
- * memory exhaustion.
- */
-struct page *find_or_create_page(struct address_space *mapping,
-		pgoff_t index, gfp_t gfp_mask)
-{
-	struct page *page;
-	int err;
-repeat:
-	page = find_lock_page(mapping, index);
-	if (!page) {
-		page = __page_cache_alloc(gfp_mask);
-		if (!page)
-			return NULL;
-		/*
-		 * We want a regular kernel memory (not highmem or DMA etc)
-		 * allocation for the radix tree nodes, but we need to honour
-		 * the context-specific requirements the caller has asked for.
-		 * GFP_RECLAIM_MASK collects those requirements.
-		 */
-		err = add_to_page_cache_lru(page, mapping, index,
-			(gfp_mask & GFP_RECLAIM_MASK));
-		if (unlikely(err)) {
-			page_cache_release(page);
-			page = NULL;
-			if (err == -EEXIST)
+	/**
+	 * find_lock_page - locate, pin and lock a pagecache page
+	 * @mapping: the address_space to search
+	 * @offset: the page index
+	 *
+	 * Locates the desired pagecache page, locks it, increments its reference
+	 * count and returns its address.
+	 *
+	 * Returns zero if the page was not present. find_lock_page() may sleep.
+	 */
+	struct page *find_lock_page(struct address_space *mapping, pgoff_t offset)
+	{
+		struct page *page;
+
+	repeat:
+		page = find_get_page(mapping, offset);
+		if (page) {
+			lock_page(page);
+			/* Has the page been truncated? */
+			if (unlikely(page->mapping != mapping)) {
+				unlock_page(page);
+				page_cache_release(page);
 				goto repeat;
+			}
+			VM_BUG_ON(page->index != offset);
 		}
+		return page;
 	}
-	return page;
-}
-EXPORT_SYMBOL(find_or_create_page);
-
-/**
- * find_get_pages - gang pagecache lookup
- * @mapping:	The address_space to search
- * @start:	The starting page index
- * @nr_pages:	The maximum number of pages
- * @pages:	Where the resulting pages are placed
- *
- * find_get_pages() will search for and return a group of up to
- * @nr_pages pages in the mapping.  The pages are placed at @pages.
- * find_get_pages() takes a reference against the returned pages.
- *
- * The search returns a group of mapping-contiguous pages with ascending
- * indexes.  There may be holes in the indices due to not-present pages.
- *
- * find_get_pages() returns the number of pages which were found.
- */
-unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
-			    unsigned int nr_pages, struct page **pages)
-{
-	unsigned int i;
-	unsigned int ret;
-	unsigned int nr_found;
+	EXPORT_SYMBOL(find_lock_page);
 
-	rcu_read_lock();
-restart:
-	nr_found = radix_tree_gang_lookup_slot(&mapping->page_tree,
-				(void ***)pages, start, nr_pages);
-	ret = 0;
-	for (i = 0; i < nr_found; i++) {
+	/**
+	 * find_or_create_page - locate or add a pagecache page
+	 * @mapping: the page's address_space
+	 * @index: the page's index into the mapping
+	 * @gfp_mask: page allocation mode
+	 *
+	 * Locates a page in the pagecache.  If the page is not present, a new page
+	 * is allocated using @gfp_mask and is added to the pagecache and to the VM's
+	 * LRU list.  The returned page is locked and has its reference count
+	 * incremented.
+	 *
+	 * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic
+	 * allocation!
+	 *
+	 * find_or_create_page() returns the desired page's address, or zero on
+	 * memory exhaustion.
+	 */
+	struct page *find_or_create_page(struct address_space *mapping,
+			pgoff_t index, gfp_t gfp_mask)
+	{
 		struct page *page;
-repeat:
-		page = radix_tree_deref_slot((void **)pages[i]);
-		if (unlikely(!page))
-			continue;
-		/*
-		 * this can only trigger if nr_found == 1, making livelock
-		 * a non issue.
-		 */
-		if (unlikely(page == RADIX_TREE_RETRY))
-			goto restart;
+		int err;
+	repeat:
+		page = find_lock_page(mapping, index);
+		if (!page) {
+			page = __page_cache_alloc(gfp_mask);
+			if (!page)
+				return NULL;
+			/*
+			 * We want a regular kernel memory (not highmem or DMA etc)
+			 * allocation for the radix tree nodes, but we need to honour
+			 * the context-specific requirements the caller has asked for.
+			 * GFP_RECLAIM_MASK collects those requirements.
+			 */
+			err = add_to_page_cache_lru(page, mapping, index,
+				(gfp_mask & GFP_RECLAIM_MASK));
+			if (unlikely(err)) {
+				page_cache_release(page);
+				page = NULL;
+				if (err == -EEXIST)
+					goto repeat;
+			}
+		}
+		return page;
+	}
+	EXPORT_SYMBOL(find_or_create_page);
+
+	/**
+	 * find_get_pages - gang pagecache lookup
+	 * @mapping:	The address_space to search
+	 * @start:	The starting page index
+	 * @nr_pages:	The maximum number of pages
+	 * @pages:	Where the resulting pages are placed
+	 *
+	 * find_get_pages() will search for and return a group of up to
+	 * @nr_pages pages in the mapping.  The pages are placed at @pages.
+	 * find_get_pages() takes a reference against the returned pages.
+	 *
+	 * The search returns a group of mapping-contiguous pages with ascending
+	 * indexes.  There may be holes in the indices due to not-present pages.
+	 *
+	 * find_get_pages() returns the number of pages which were found.
+	 */
+	unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
+				    unsigned int nr_pages, struct page **pages)
+	{
+		unsigned int i;
+		unsigned int ret;
+		unsigned int nr_found;
+
+		rcu_read_lock();
+	restart:
+		nr_found = radix_tree_gang_lookup_slot(&mapping->page_tree,
+					(void ***)pages, start, nr_pages);
+		ret = 0;
+		for (i = 0; i < nr_found; i++) {
+			struct page *page;
+	repeat:
+			page = radix_tree_deref_slot((void **)pages[i]);
+			if (unlikely(!page))
+				continue;
+			/*
+			 * this can only trigger if nr_found == 1, making livelock
+			 * a non issue.
+			 */
+			if (unlikely(page == RADIX_TREE_RETRY))
+				goto restart;
 
-		if (!page_cache_get_speculative(page))
-			goto repeat;
+			if (!page_cache_get_speculative(page))
+				goto repeat;
 
-		/* Has the page moved? */
+			/* Has the page moved? */
 		if (unlikely(page != *((void **)pages[i]))) {
 			page_cache_release(page);
 			goto repeat;
-- 
1.7.9.5


From 3379a653403d7059dc6bd80deee0f6a535cd8097 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Sat, 4 May 2013 14:15:11 -0400
Subject: [PATCH 42/75] Realized last push was looping infinitely. Temporarily
 remove that.

---
 fs/ext2/ext2_evict.c |   10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index b301a32..bd8fe74 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -398,13 +398,15 @@ void ext2_evict_fs(struct super_block *super)
 		struct list_head *pos;
 		struct inode *cur_inode;
 
-		while(rem > sbi->evict) {		  			
+		//		while(rem > sbi->evict) {		  			
 			list_for_each(pos, &super->s_inodes) {
 				cur_inode = list_entry(pos, struct inode, i_list);
 
-				if(!S_ISREG(cur_inode->i_mode) || cur_inode->i_ino != clockhand)
+				if(!S_ISREG(cur_inode->i_mode) || cur_inode->i_ino != clockhand) {
+					printk("inode: %d, type: %d\n", cur_inode->i_ino, cur_inode->i_mode);
 					continue;
-				
+				}
+
 				clockhand = cur_inode->i_ino;
 				ret = ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
 				if (ret < 0) {
@@ -429,7 +431,7 @@ void ext2_evict_fs(struct super_block *super)
 					spin_unlock(cur_inode->i_lock);
 				}
 			}
-		}
+			//		}
 	
 		spin_lock(root->i_lock);
 		ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
-- 
1.7.9.5


From 9879adb96179c74246d2d1d620e9ce8025a97240 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 4 May 2013 17:24:49 -0400
Subject: [PATCH 43/75] -files are being read and sent to server. -truncation
 is not crashing. -the server is not writing all of
 the data for some reason.

---
 fs/ext2/ext2_evict.c |   30 ++++++++++++++++++++----------
 1 file changed, 20 insertions(+), 10 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index b301a32..f5ee2ca 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -114,7 +114,9 @@ void *read_blocks(struct inode *i_node)
 	struct page *curr_page;
 	struct address_space *mapping;
 	char *kaddr;
+	unsigned long nr_segs, error;
 
+	nr_segs = 0;
 	size = i_size_read(i_node);
 	mapping = i_node->i_mapping;
 	printk(KERN_DEBUG "inode size = %lu\n", size);
@@ -122,33 +124,45 @@ void *read_blocks(struct inode *i_node)
 
 	file_buffer = kmalloc(size, GFP_KERNEL);
 	curr_addr = file_buffer;
+	printk(KERN_DEBUG "file_buffer = %p\n", file_buffer);
+	printk(KERN_DEBUG "curr_addr = %p\n", curr_addr);
+	printk(KERN_DEBUG "file_buffer + size = %p\n", file_buffer + size);
 	if (file_buffer != NULL) {
+		printk(KERN_DEBUG "file_buffer != NULL\n");
 		remaining = size;
 		index = 0;
 		while (curr_addr < ((unsigned long) file_buffer) + size) {
+			printk(KERN_DEBUG "Inside while loop.\n");
 			/* __pa() maps vaddr -> paddr. */
 			/*
 			 * Get page functionality goes here.
 			 * curr_page = virt_to_page((void *) curr_addr);
 			 */
 			curr_page = find_get_page(mapping, index);
+			printk(KERN_DEBUG "curr_page = %p\n", curr_page);
 			if (!curr_page) {
 				curr_page = page_cache_alloc_cold(mapping);
+				printk(KERN_DEBUG "after alloc, curr_page = %p\n", curr_page);
 				if (!curr_page) {
 					printk(KERN_DEBUG, "NULL page.\n");
 					kfree(file_buffer);
 					return NULL;
 				} else {
+					error = add_to_page_cache_lru(curr_page, mapping, index, GFP_KERNEL);
+					if (error) {
+						printk(KERN_DEBUG, "error adding lru.\n");
+						kfree(file_buffer);
+						return NULL;
+					}
+					printk(KERN_DEBUG "added page to lru cache.\n");
+					printk(KERN_DEBUG "curr_page = %p\n", curr_page);
+					printk(KERN_DEBUG, "Found page and preparing to read.\n");
 					mpage_readpage(curr_page,
 							ext2_get_block);
 				}
 			}
 
-			if (curr_page == NULL) {
-			} else {
-				printk(KERN_DEBUG "curr_page = %p\n",
-						curr_page);
-			}
+			printk(KERN_DEBUG, "Found and read page.\n");
 			/*
 			 * Based on filemap.file_read_actor
 			 */
@@ -314,18 +328,14 @@ int ext2_evict(struct inode *i_node)
 		 */
 		
 		blocks_buffer = read_blocks(i_node);
-		mutex_unlock(&i_node->i_mutex);
-		return -1;
 		if (blocks_buffer) {
 			printk(KERN_DEBUG "Blocks_buffer != null: %s", blocks_buffer);
-			return 0;
 		} else {
 			printk(KERN_DEBUG "Blocks_buffer == null");
 			return -1;
 		}
+		printk(KERN_DEBUG "Preparing to send.\n");
 		/* TODO: Must clear the cache of pages. */
-
-
 		req.inode = i_node->i_ino;
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
-- 
1.7.9.5


From 7bef6bc63cff946556126ca34a4d908b6865b3a6 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 4 May 2013 20:14:27 -0400
Subject: [PATCH 44/75] -corrected error where only the request structure was
 being evicted.

---
 fs/ext2/ext2_evict.c |   20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index f5ee2ca..ca0b000 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -144,7 +144,7 @@ void *read_blocks(struct inode *i_node)
 				curr_page = page_cache_alloc_cold(mapping);
 				printk(KERN_DEBUG "after alloc, curr_page = %p\n", curr_page);
 				if (!curr_page) {
-					printk(KERN_DEBUG, "NULL page.\n");
+					printk(KERN_DEBUG "NULL page.\n");
 					kfree(file_buffer);
 					return NULL;
 				} else {
@@ -156,7 +156,7 @@ void *read_blocks(struct inode *i_node)
 					}
 					printk(KERN_DEBUG "added page to lru cache.\n");
 					printk(KERN_DEBUG "curr_page = %p\n", curr_page);
-					printk(KERN_DEBUG, "Found page and preparing to read.\n");
+					printk(KERN_DEBUG "Found page and preparing to read.\n");
 					mpage_readpage(curr_page,
 							ext2_get_block);
 				}
@@ -285,7 +285,7 @@ int ext2_evict(struct inode *i_node)
 	struct clfs_req req;
 	struct dentry *i_dentry;
 	struct ext2_inode_info *in_info;
-	void *blocks_buffer;
+	void *blocks_buffer, *buffer_to_evict;
 
 	if (S_ISREG(i_node->i_mode) == 0) {
 		printk(KERN_DEBUG "Error: can only evict regular files.\n");
@@ -340,7 +340,19 @@ int ext2_evict(struct inode *i_node)
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
 		ret_value = clear_data_blocks(i_node);
-		ret_value = evict_buffer(sizeof(req), &req);
+
+		buffer_to_evict = kmalloc(req.size + sizeof(req),
+				GFP_KERNEL);
+		if (buffer_to_evict == NULL) {
+			printk(KERN_DEBUG "Failed to allocate buffer.\n");
+			kfree(blocks_buffer);
+			return -1;
+		}
+		memcpy(buffer_to_evict, &req, sizeof(req));
+		memcpy(buffer_to_evict + sizeof(req), blocks_buffer, req.size);
+		ret_value = evict_buffer(sizeof(req) + req.size, buffer_to_evict);
+		kfree(buffer_to_evict);
+		kfree(blocks_buffer);
 	}
 	mutex_unlock(&i_node->i_mutex);
 
-- 
1.7.9.5


From d06ea09c9115983f28c9f8549ba7b3b82104adc4 Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Sat, 4 May 2013 20:36:48 -0400
Subject: [PATCH 45/75] changed some locks, set up testing of writing buffer
 to disk. Probably not doing it correctly without
 changing metadata..

---
 fs/ext2/ext2_evict.c |   54 ++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 48 insertions(+), 6 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 6de054e..714df22 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -7,6 +7,7 @@
 #include <linux/stat.h>
 #include <linux/xattr.h>
 #include <linux/vmalloc.h>
+#include <linux/buffer_head.h>
 #include <net/sock.h>
 #include "xattr.h"
 #include "ext2.h"
@@ -122,6 +123,36 @@ void *read_blocks(struct inode *i_node)
 	return file_buffer;	
 }
 
+
+/**
+ * reads the data from the disk associated with the inode.
+ */
+void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
+{
+  void *curr_addr;
+  
+  struct page *curr_page;
+
+
+  int ret_val = 0;
+
+  /* struct writeback_control wbc = { */
+  /*   .sync_mode = WB_SYNC_ALL, */
+  /*   .nr_to_write = 0, */
+  /* }; */
+  
+  curr_addr = file_data;
+  while (curr_addr < file_data + file_size) {
+    curr_page = vmalloc_to_page(curr_addr);
+    curr_addr += PAGE_SIZE;
+    ret_val = mpage_writepage(curr_page, block_write_full_page, NULL);
+  }
+
+  return ret_val;
+  
+
+}
+
 // merge this with function above, evict_buffer.
 int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer) {
 	int ret, bytes;
@@ -137,7 +168,7 @@ int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer) {
 	uint32_t temp_ip;
 	int temp_port;
 
-	temp_ip = 0x7F000001; /*127.0.0.1, localhost*/
+	temp_ip = 0xa000202; /*10.0.2.2*/
 	temp_port = 8888;
 
 	memset(&s_addr, 0, sizeof(s_addr));
@@ -289,22 +320,33 @@ int ext2_fetch(struct inode *i_node)
 {
 	int ret_value;
 	struct clfs_req req;
+        void *file_data;
 
-	mutex_lock(&i_node->i_mutex);
+	//mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
+        mutex_lock(&i_node->i_mutex);
 	req.inode = i_node->i_ino;
 	req.size = i_node->i_size;
 	req.type = CLFS_GET;
-	mutex_unlock(&i_node->i_mutex);
+        mutex_unlock(&i_node->i_mutex);
+	//mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 
 	// server should give me the right inode
 	// that i can allocate on the fs
 	//ret_value = fetch_blocks();
+        
+        // using test file data for now, while server doesn't have real file data on it.
+        // need to see if I can write this out to blocks and attach those blocks to an inode.
+        file_data = vmalloc(4096);
+        memset(file_data, '6', 4096);
+
+        printk(KERN_ERR "file_data: %s", (char *)file_data);
 
 	// now write blocks to disk.
 	// here.
-        //mutex_lock(&i_node->i_mutex);
-        printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
-        //mutex_unlock(&i_node->i_mutex);
+        //mutex_lock_nested(&i_node->i_mutex, I_MUTEX_DATA);
+        //write_blocks(i_node, file_data, i_node->i_size);
+        //printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
+        //mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_DATA);
 
 	return ret_value;
 }
-- 
1.7.9.5


From babd0de3597d3d599a0c3a1846907abdb9f70936 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Sat, 4 May 2013 23:30:35 -0400
Subject: [PATCH 46/75] Find file inodes now.

---
 fs/ext2/ext2_evict.c |   19 ++++++++++---------
 fs/ext2/inode.c      |    2 +-
 fs/ext2/super.c      |    6 +++---
 3 files changed, 14 insertions(+), 13 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index c7ef3b4..532d761 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,4 +1,4 @@
-//#include <linux/ext2_fs.h>
+
 #include <asm/page.h>
 
 #include <linux/fs.h>
@@ -21,7 +21,7 @@
 #include "clfs.h"
 #include <asm/div64.h>
 #include <linux/time.h>
-
+#include <linux/ext2_fs.h>
 /*
  * TODO: Make this a general exchange with arbitrarily sized request and
  * response buffers so it can be used for both evict and fetch.
@@ -446,9 +446,9 @@ void ext2_evict_fs(struct super_block *super)
 	int ret = ext2_xattr_get(root, 0, "clockhand", &clockhand, sizeof(int));
 	
 	printk("getting clockhand: %d ret: %d\n", ret, clockhand);
-   
+
 	if (ret < 0) {
-		clockhand = 0;
+		clockhand = EXT2_FIRST_INO(super);
 		spin_lock(root->i_lock);
 		ret = ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_CREATE);
 		spin_unlock(root->i_lock);
@@ -462,20 +462,21 @@ void ext2_evict_fs(struct super_block *super)
 
 	if (rem > sbi->wl) {
 		printk("usage > wl\n");
-		struct inode *start_inode;
+		struct inode *start_inode = ext2_iget(super, EXT2_ROOT_INO);
 		struct list_head *pos;
 		struct inode *cur_inode;
 
-		//		while(rem > sbi->evict) {		  			
-			list_for_each(pos, &super->s_inodes) {
+		//		while(rem > sbi->evict) {
+
+			list_for_each(pos, &start_inode->i_list) {
 				cur_inode = list_entry(pos, struct inode, i_list);
 
 				if(!S_ISREG(cur_inode->i_mode) || cur_inode->i_ino != clockhand) {
-					printk("inode: %d, type: %d\n", cur_inode->i_ino, cur_inode->i_mode);
+					printk("inode: %d, type: %d\n", cur_inode->i_ino, S_ISREG(cur_inode->i_mode));
 					continue;
 				}
 
-				clockhand = cur_inode->i_ino;
+				clockhand = cur_inode->i_ino+1;
 				ret = ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
 				if (ret < 0) {
 					scantime = 0;
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index e2a872d..dd89c83 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -498,7 +498,7 @@ static int ext2_alloc_branch(struct inode *inode,
 	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
 	struct ext2_super_block *sb = sbi->s_es;
 
-	uint64_t free = (uint64_t)sb->s_free_blocks_count;
+	uint64_t free = (uint64_t)ext2_count_free_blocks(super);
 	uint32_t total = (uint32_t)sb->s_blocks_count;
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index 84db213..a134d8b 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -588,17 +588,17 @@ static int parse_options (char * options,
 			/* TODO */
 			break;
 		case Opt_wh:
-			if (match_int(&args[0], &option) || option < 0 || option > 100)
+			if (match_int(&args[0], &option))
 				return 0;
 			sbi->wh = option;
 			break;
 		case Opt_wl:
-			if (match_int(&args[0], &option) || option < 0 || option > sbi->wh)
+			if (match_int(&args[0], &option))
 				return 0;
 			sbi->wl = option;
 			break;
 		case Opt_evict:
-			if (match_int(&args[0], &option) || option < 0 || option > sbi->wl)
+			if (match_int(&args[0], &option))
 				return 0;
 			sbi->evict = option;
 			break;
-- 
1.7.9.5


From aabcf2bd244ed0170f7b1dabe52b809f28dcb23e Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Mon, 29 Apr 2013 13:15:42 -0400
Subject: [PATCH 47/75] fleshed out write_blocks function based on
 ext2_write_quota. debugging cause of sleeping in that
 function

---
 fs/ext2/ext2_evict.c |  104 ++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 76 insertions(+), 28 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index d177e99..204a14f 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -13,6 +13,8 @@
 #include <linux/xattr.h>
 #include <linux/vmalloc.h>
 #include <linux/buffer_head.h>
+#include <linux/writeback.h>
+#include <linux/mutex.h>
 #include <net/sock.h>
 #include "xattr.h"
 #include "ext2.h"
@@ -192,32 +194,75 @@ void *read_blocks(struct inode *i_node)
 
 
 /**
- * reads the data from the disk associated with the inode.
- */
+ * writes data to the disk and updates the inode.
+ */	
+//REFER TO: ext2_quota_read and ext2_quota_write
 void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
 {
-  void *curr_addr;
-  
-  struct page *curr_page;
+  	unsigned long curr_addr = (unsigned long)file_data;
+	unsigned long end_addr = ((unsigned long) file_data) + file_size;
+	unsigned long curr_block = 0;
+	struct super_block *sb = i_node->i_sb;
+	unsigned long blocksize = sb->s_blocksize;
+	int tocopy;
+	struct buffer_head tmp_bh;
+	struct buffer_head *bh;
+	struct page *curr_page;
+	int ret_val = 0;
 
+/*
+	struct writeback_control wbc = {
+		.sync_mode = WB_SYNC_ALL,
+		.nr_to_write = 1,
+	};
 
-  int ret_val = 0;
+	curr_addr = file_data;
+	while (curr_addr < ((unsigned long) file_data) + file_size) {
+		curr_page = vmalloc_to_page(curr_addr);
 
-  /* struct writeback_control wbc = { */
-  /*   .sync_mode = WB_SYNC_ALL, */
-  /*   .nr_to_write = 0, */
-  /* }; */
-  
-  curr_addr = file_data;
-  while (curr_addr < file_data + file_size) {
-    curr_page = vmalloc_to_page(curr_addr);
-    curr_addr += PAGE_SIZE;
-    ret_val = mpage_writepage(curr_page, block_write_full_page, NULL);
-  }
+		ret_val = mpage_writepage(curr_page, ext2_get_block, &wbc);
+	}
+*/
+//	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
+	while (curr_addr < end_addr) {
+		printk(KERN_DEBUG "executing write block loop.\n");
+		curr_page = vmalloc_to_page(curr_addr);
+		tocopy = blocksize < ( end_addr - curr_addr) ? blocksize : (end_addr - curr_addr);
+
+		tmp_bh.b_state = 0;
+		ret_val = ext2_get_block(i_node, curr_block, &tmp_bh, 1);
+		if (ret_val < 0) {
+			mutex_unlock(&i_node->i_mutex);
+			return ret_val;
+		}
 
-  return ret_val;
-  
+		bh = sb_getblk(sb, tmp_bh.b_blocknr);
+		if (!bh) {
+			ret_val = -EIO;
+			mutex_unlock(&i_node->i_mutex);
+			return ret_val;
+		}
+		
+		lock_buffer(bh);
+		
+		memcpy(bh->b_data, file_data, tocopy);
+		flush_dcache_page(bh->b_page);
+		set_buffer_uptodate(bh);
+		mark_buffer_dirty(bh);
+
+		unlock_buffer(bh);
+		sync_dirty_buffer(bh);
+		brelse(bh);
+		curr_addr += tocopy;
+		curr_block++;
+	}
+	
+	printk(KERN_DEBUG "exitted the block write loop.\n");
+	// TODO: check if this modifies any metadata...
+	mark_inode_dirty(i_node);
 
+//	mutex_unlock(&i_node->i_mutex);
+	return ret_val;
 }
 
 // merge this with function above, evict_buffer.
@@ -402,23 +447,24 @@ int ext2_fetch(struct inode *i_node)
 
 	//mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 
-        /*
-	mutex_lock(&i_node->i_mutex);
+        
+	//mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	req.inode = i_node->i_ino;
 	req.size = i_node->i_size;
 	req.type = CLFS_GET;
-        mutex_unlock(&i_node->i_mutex);
-	*/
+        //mutex_unlock(&i_node->i_mutex);
+
+	printk(KERN_ERR "ino: %lu", i_node->i_ino);	
 
 	//mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 
-	// server should give me the right inode
+	// server should give me the right file data
 	// that i can allocate on the fs
 	//ret_value = fetch_blocks();
         
         // using test file data for now, while server doesn't have real file data on it.
         // need to see if I can write this out to blocks and attach those blocks to an inode.
-        file_data = kmalloc(4096, GFP_KERNEL);
+        file_data = vmalloc(4096); //TODO: check that vmalloc was okay.
         memset(file_data, '6', 4096);
 
 	/* // DEBUG REMOVE ME
@@ -431,10 +477,11 @@ int ext2_fetch(struct inode *i_node)
 	// now write blocks to disk.
 	// here.
         //mutex_lock_nested(&i_node->i_mutex, I_MUTEX_DATA);
-	mutex_lock(&i_node->i_mutex);
-        //write_blocks(i_node, file_data, i_node->i_size);
+	//mutex_lock(&i_node->i_mutex);
+	//ret_value = write_blocks(i_node, file_data, i_node->i_size);
+	ret_value = write_blocks(i_node, file_data, 4096);
         //printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
-	mutex_unlock(&i_node->i_mutex);
+	//mutex_unlock(&i_node->i_mutex);
         //mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_DATA);
 
 	return ret_value;
@@ -563,6 +610,7 @@ asmlinkage long hw4_fetch_test()
 
 	ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
+	printk(KERN_ERR "i_node pointer: %p", i_node);
 	hack_inode_closed(i_node);
 
 	ret_val = ext2_fetch(&i_node);
-- 
1.7.9.5


From e0cb578e29a19333eef02d6fbbeb4dcd9fe8092b Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Mon, 6 May 2013 12:15:22 -0400
Subject: [PATCH 48/75] -added conditional so that data will not be removed
 from the disk if the server cannot be reached.

---
 fs/ext2/ext2_evict.c |   10 ++++------
 1 file changed, 4 insertions(+), 6 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 204a14f..036f14d 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -349,8 +349,8 @@ int is_inode_open(struct inode *i_node)
 
 /*
  * Evict's the blocks associated with the inode to the server.
- * TODO: actually read blocks from disk.
  * TODO: Handle accounting for free blocks.
+ * TODO: Test that server is available before removing blocks from the disk.
  */
 int ext2_evict(struct inode *i_node)
 {
@@ -416,7 +416,6 @@ int ext2_evict(struct inode *i_node)
 		req.inode = i_node->i_ino;
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
-		ret_value = clear_data_blocks(i_node);
 
 		buffer_to_evict = kmalloc(req.size + sizeof(req),
 				GFP_KERNEL);
@@ -428,6 +427,9 @@ int ext2_evict(struct inode *i_node)
 		memcpy(buffer_to_evict, &req, sizeof(req));
 		memcpy(buffer_to_evict + sizeof(req), blocks_buffer, req.size);
 		ret_value = evict_buffer(sizeof(req) + req.size, buffer_to_evict);
+		if (ret_value == 0) {
+			ret_value = clear_data_blocks(i_node);
+		}
 		kfree(buffer_to_evict);
 		kfree(blocks_buffer);
 	}
@@ -621,7 +623,3 @@ asmlinkage long hw4_fetch_test()
 
 
 
-
-
-
-
-- 
1.7.9.5


From b4cb814ae34533cae267d2a0e127ce326e3ab51d Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Mon, 6 May 2013 20:46:38 -0400
Subject: [PATCH 49/75] Started working on daemon

---
 fs/Makefile          |    2 +-
 fs/evictd.c          |   24 ++++++++++++++++++++++++
 fs/ext2/ext2_evict.c |   17 ++++++++++-------
 fs/ext2/inode.c      |   21 +++++++++++++--------
 fs/ext2/xattr.c      |    2 +-
 5 files changed, 49 insertions(+), 17 deletions(-)
 create mode 100644 fs/evictd.c

diff --git a/fs/Makefile b/fs/Makefile
index 9cbace8..50de40c 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -11,7 +11,7 @@ obj-y :=	open.o read_write.o file_table.o super.o \
 		attr.o bad_inode.o file.o filesystems.o namespace.o \
 		seq_file.o xattr.o libfs.o fs-writeback.o \
 		pnode.o drop_caches.o splice.o sync.o utimes.o \
-		stack.o
+		stack.o evictd.o
 
 ifeq ($(CONFIG_BLOCK),y)
 obj-y +=	buffer.o bio.o block_dev.o direct-io.o mpage.o ioprio.o
diff --git a/fs/evictd.c b/fs/evictd.c
new file mode 100644
index 0000000..565d7f4
--- /dev/null
+++ b/fs/evictd.c
@@ -0,0 +1,24 @@
+#include <linux/init.h>
+#include <linux/timer.h>
+#include <linux/mount.h>
+#include <linux/rwsem.h>
+
+void walk_filesystems(unsigned long data) {
+
+
+	return;
+}
+
+static int __init evict_init(void)
+{
+
+	struct timer_list my_timer;
+	init_timer(&my_timer);
+
+	my_timer.expires = jiffies + 60*HZ;
+	my_timer.function = walk_filesystems;
+	my_timer.data = 0;
+	//	return err;
+}
+
+fs_initcall(evict_init);
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 204a14f..4052601 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -502,8 +502,8 @@ void ext2_evict_fs(struct super_block *super)
 	time_t scantime;
 	int clockhand;
 	int ret = ext2_xattr_get(root, 0, "clockhand", &clockhand, sizeof(int));
-	
-	printk("getting clockhand: %d ret: %d\n", ret, clockhand);
+
+	printk("getting clockhand: %d ret: %d\n", clockhand, ret);
 
 	if (ret < 0) {
 		clockhand = EXT2_FIRST_INO(super);
@@ -514,17 +514,20 @@ void ext2_evict_fs(struct super_block *super)
 	}
 
 	uint64_t free  = (uint64_t)ext2_count_free_blocks(super);	
-	uint32_t total = (uint32_t)sb->s_blocks_count;
+	uint32_t total = (uint32_t)le32_to_cpu(sb->s_blocks_count);
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
+	
+	printk("free: %d, total: %d, usage: %d, rem: %d\n", free, total, usage, rem);
+	//	printk("evict wl: %d, wh: %d, evict: %d\n", sbi->wl, sbi->wh, sbi->evict);
 
-	if (rem > sbi->wl) {
+	if (usage > sbi->wl) {
 		printk("usage > wl\n");
 		struct inode *start_inode = ext2_iget(super, EXT2_ROOT_INO);
 		struct list_head *pos;
 		struct inode *cur_inode;
 
-		//		while(rem > sbi->evict) {
+		while(usage > sbi->evict) {
 
 			list_for_each(pos, &start_inode->i_list) {
 				cur_inode = list_entry(pos, struct inode, i_list);
@@ -546,7 +549,7 @@ void ext2_evict_fs(struct super_block *super)
 				
 				if(scantime > cur_inode->i_atime.tv_sec) {
 					printk("evicting inode: %d\n", cur_inode->i_ino);
-					ext2_evict(cur_inode);					
+					ext2_evict(cur_inode);
 					free = (uint64_t)ext2_count_free_blocks(super);
 					usage = (total - free)*100;
 					rem = do_div(usage, total);
@@ -558,7 +561,7 @@ void ext2_evict_fs(struct super_block *super)
 					spin_unlock(cur_inode->i_lock);
 				}
 			}
-			//		}
+		}
 	
 		spin_lock(root->i_lock);
 		ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index dd89c83..9a9cc84 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -406,6 +406,7 @@ static int ext2_alloc_blocks(struct inode *inode,
 	/* total number of blocks allocated for direct blocks */
 	ret = count;
 	*err = 0;
+
 	return ret;
 failed_out:
 	for (i = 0; i <index; i++)
@@ -496,15 +497,16 @@ static int ext2_alloc_branch(struct inode *inode,
 	
 	struct super_block *super = inode->i_sb;
 	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
-	struct ext2_super_block *sb = sbi->s_es;
+	struct ext2_super_block *sb = sbi->s_es;	
+		
+	uint32_t free  = (uint32_t)ext2_count_free_blocks(super);	
+	uint32_t total = (uint32_t)le32_to_cpu(sb->s_blocks_count);
+	uint32_t usage = (total - free)*100;
+	uint32_t rem = do_div(usage, total);
 
-	uint64_t free = (uint64_t)ext2_count_free_blocks(super);
-	uint32_t total = (uint32_t)sb->s_blocks_count;
-	uint64_t usage = (total - free)*100;
-	uint64_t rem = do_div(usage, total);
-	
-	printk("new inode rem: %d, wl: %d, wh: %d, evict: %d\n", rem, sbi->wl, sbi->wh, sbi->evict);
-	if (rem > sbi->wh) {
+	//	printk("usage: %d, free: %d, total: %d, rem: %d, wh: %d\n", usage, free, total, rem, sbi->wh);
+
+	if (usage > sbi->wh) {
 		super->s_op->evict_fs(super);
 	}
 
@@ -664,6 +666,7 @@ reread:
 	/*
 	 * XXX ???? Block out ext2_truncate while we alter the tree
 	 */
+
 	err = ext2_alloc_branch(inode, indirect_blks, &count, goal,
 				offsets + (partial - chain), partial);
 
@@ -687,6 +690,7 @@ reread:
 	ext2_splice_branch(inode, iblock, partial, indirect_blks, count);
 	mutex_unlock(&ei->truncate_mutex);
 	set_buffer_new(bh_result);
+
 got_it:
 	map_bh(bh_result, inode->i_sb, le32_to_cpu(chain[depth-1].key));
 	if (count > blocks_to_boundary)
@@ -699,6 +703,7 @@ cleanup:
 		brelse(partial->bh);
 		partial--;
 	}
+	
 	return err;
 changed:
 	while (partial > chain) {
diff --git a/fs/ext2/xattr.c b/fs/ext2/xattr.c
index 55d979e..bbcf8f5 100644
--- a/fs/ext2/xattr.c
+++ b/fs/ext2/xattr.c
@@ -68,7 +68,7 @@
 #define ENTRY(ptr) ((struct ext2_xattr_entry *)(ptr))
 #define FIRST_ENTRY(bh) ENTRY(HDR(bh)+1)
 #define IS_LAST_ENTRY(entry) (*(__u32 *)(entry) == 0)
-#define EXT2_XATTR_DEBUG
+//#define EXT2_XATTR_DEBUG
 #ifdef EXT2_XATTR_DEBUG
 # define ea_idebug(inode, f...) do { \
 		printk("inode %s:%ld: ", \
-- 
1.7.9.5


From 4e229514354934c35d37408e7a22a87341a8301a Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Mon, 6 May 2013 20:51:05 -0400
Subject: [PATCH 50/75] writing out to file from vmalloced memory in kernel
 works.

---
 clfs/Makefile_fetch_test |   51 ++++++++++++++++++++++++++++++++++++++++++++++
 fs/ext2/ext2_evict.c     |   18 ++++++++++++----
 2 files changed, 65 insertions(+), 4 deletions(-)
 create mode 100644 clfs/Makefile_fetch_test

diff --git a/clfs/Makefile_fetch_test b/clfs/Makefile_fetch_test
new file mode 100644
index 0000000..59440ea
--- /dev/null
+++ b/clfs/Makefile_fetch_test
@@ -0,0 +1,51 @@
+APP := fetch_test
+ROOT:=$(HOME)/DATA/SOFT
+NDK_PLATFORM_VER := 14
+INSTALL_DIR := /data/tmp
+
+ANDROID_SDK_ROOT:=$(ROOT)/android-sdk-linux
+ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8d
+ANDROID_NDK_HOST:=linux-x86
+ANDROID_TARGET:=i686-linux-android
+ANDROID_TARGET_ARCH:=x86
+ANDROID_TOOLCHAIN:=x86-4.4.3
+
+BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
+LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
+INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
+BIN := $(BINDIR)/bin
+ 
+CPP := $(BIN)/$(ANDROID_TARGET)-g++
+CC := $(BIN)/$(ANDROID_TARGET)-gcc
+CFLAGS := -I$(INCDIR)
+LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
+ 
+ 
+all: $(APP)
+ 
+OBJS += $(APP).o
+ 
+$(APP): $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $^
+ 
+%.o: %.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+install: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+ 
+shell:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
+ 
+run:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+r: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+clean:
+	@rm -f $(APP).o $(APP)
+
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 036f14d..e124600 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -199,16 +199,19 @@ void *read_blocks(struct inode *i_node)
 //REFER TO: ext2_quota_read and ext2_quota_write
 void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
 {
+        printk(KERN_DEBUG "point ALPHA ONE.\n");
   	unsigned long curr_addr = (unsigned long)file_data;
 	unsigned long end_addr = ((unsigned long) file_data) + file_size;
 	unsigned long curr_block = 0;
 	struct super_block *sb = i_node->i_sb;
+        printk(KERN_ERR "sb ptr: %p\n", sb);
 	unsigned long blocksize = sb->s_blocksize;
 	int tocopy;
 	struct buffer_head tmp_bh;
 	struct buffer_head *bh;
 	struct page *curr_page;
 	int ret_val = 0;
+        printk(KERN_DEBUG "point ALPHA TWO.\n");
 
 /*
 	struct writeback_control wbc = {
@@ -225,12 +228,14 @@ void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_siz
 */
 //	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	while (curr_addr < end_addr) {
-		printk(KERN_DEBUG "executing write block loop.\n");
+		printk(KERN_ERR "executing write block loop.\n");
 		curr_page = vmalloc_to_page(curr_addr);
 		tocopy = blocksize < ( end_addr - curr_addr) ? blocksize : (end_addr - curr_addr);
 
+                printk(KERN_ERR "point ALPHA.\n");
 		tmp_bh.b_state = 0;
 		ret_val = ext2_get_block(i_node, curr_block, &tmp_bh, 1);
+                printk(KERN_ERR "point BRAVO.\n");
 		if (ret_val < 0) {
 			mutex_unlock(&i_node->i_mutex);
 			return ret_val;
@@ -243,21 +248,26 @@ void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_siz
 			return ret_val;
 		}
 		
+                printk(KERN_ERR "point CHARLIE.\n");
 		lock_buffer(bh);
 		
 		memcpy(bh->b_data, file_data, tocopy);
+                printk(KERN_ERR "point DELTA.\n");
 		flush_dcache_page(bh->b_page);
+                printk(KERN_ERR "point ECHO.\n");
 		set_buffer_uptodate(bh);
 		mark_buffer_dirty(bh);
 
 		unlock_buffer(bh);
 		sync_dirty_buffer(bh);
 		brelse(bh);
+                printk(KERN_ERR "point FOXTROT.\n");
 		curr_addr += tocopy;
 		curr_block++;
+                printk(KERN_ERR "point GAMMA.\n");
 	}
 	
-	printk(KERN_DEBUG "exitted the block write loop.\n");
+	printk(KERN_ERR "exitted the block write loop.\n");
 	// TODO: check if this modifies any metadata...
 	mark_inode_dirty(i_node);
 
@@ -612,10 +622,10 @@ asmlinkage long hw4_fetch_test()
 
 	ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
-	printk(KERN_ERR "i_node pointer: %p", i_node);
+	printk(KERN_ERR "i_node pointer: %p\n", i_node);
 	hack_inode_closed(i_node);
 
-	ret_val = ext2_fetch(&i_node);
+	ret_val = ext2_fetch(i_node);
 
 	return ret_val;
 }
-- 
1.7.9.5


From ed35dc0fee506328e0024449612d604e7d69b816 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Mon, 6 May 2013 20:52:01 -0400
Subject: [PATCH 51/75] -moved setting xattr to end of file.

---
 fs/ext2/ext2_evict.c |   39 ++++++++++++++++++++++-----------------
 1 file changed, 22 insertions(+), 17 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 036f14d..8c7150c 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -355,7 +355,7 @@ int is_inode_open(struct inode *i_node)
 int ext2_evict(struct inode *i_node)
 {
 	char evict_label[] = "evicted";
-	int evicted = 1;
+	char evicted = "1";
 	int ret_value, is_open;
 	struct clfs_req req;
 	struct dentry *i_dentry;
@@ -373,21 +373,7 @@ int ext2_evict(struct inode *i_node)
 	 * function.
 	 */
 	mutex_lock(&i_node->i_mutex);
-	/* Test if the inode is currently being accessed. */
-	i_dentry = container_of(&i_node->i_dentry, struct dentry, d_alias);
-	
 	in_info = EXT2_I(i_node);
-
-	down_read(&in_info->xattr_sem);
-	
-	if (i_dentry == NULL) {
-		printk(KERN_DEBUG "i_dentry is NULL\n");
-		return -1;
-	}
-	//return -1;
-	//i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
-	up_read(&in_info->xattr_sem);
-
 	is_open = is_inode_open(i_node);
 	if (is_open) {
 		printk(KERN_DEBUG "Cannot evict file being accessed: %d.\n", atomic_read(&i_node->i_count));
@@ -432,6 +418,23 @@ int ext2_evict(struct inode *i_node)
 		}
 		kfree(buffer_to_evict);
 		kfree(blocks_buffer);
+		down_read(&in_info->xattr_sem);
+
+
+		//i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
+		if(i_node == NULL){
+			printk(KERN_DEBUG "INODE IS NULL.\n");
+		}
+		else if (i_node->i_sb == NULL) {
+			printk(KERN_DEBUG "SUPERBLOCK IS NULL.\n");
+		} else {
+			printk(KERN_DEBUG "SUPERBLOCK IS NOT NULL.\n");
+			int evict_int = 1;
+			//ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
+			ext2_xattr_set(i_node,    0, "evicted", &evict_int, sizeof(int), XATTR_CREATE);
+			printk(KERN_DEBUG "XATTR set.\n");
+		}
+		up_read(&in_info->xattr_sem);
 	}
 	mutex_unlock(&i_node->i_mutex);
 
@@ -588,10 +591,12 @@ asmlinkage long hw4test()
 {
 	int inode_num, ret_val;
 	struct inode *i_node;
-	char test_file[] = "/mnt/sdcard/test_file.txt";
+	//char test_file[] = "/mnt/sdcard/test_file.txt";
+	char test_file[] = "/mnt/sdcard/inode.c";
 	struct nameidata nd;
 
 	//ret_val = path_lookup(test_file, LOOKUP_OPEN, &nd);
+	printk(KERN_DEBUG "Looking up file: %s\n", test_file);
 	ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
 	hack_inode_closed(i_node);
@@ -607,7 +612,7 @@ asmlinkage long hw4_fetch_test()
 {
 	int inode_num, ret_val;
 	struct inode *i_node;
-	char test_file[] = "/mnt/sdcard/test_file.txt";
+	char test_file[] = "/mnt/sdcard/test_file.c";
 	struct nameidata nd;
 
 	ret_val = path_lookup(test_file, 0, &nd);
-- 
1.7.9.5


From b68c1c5ad34bf8955eb373b1242c4d8c53d7b42b Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Mon, 6 May 2013 22:51:31 -0400
Subject: [PATCH 52/75] -added cache flushing. -not acquiring xattr semaphore.

---
 fs/ext2/ext2_evict.c |   16 +++++++---------
 1 file changed, 7 insertions(+), 9 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 8e57b5b..aed218d 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -134,14 +134,15 @@ void *read_blocks(struct inode *i_node)
 		remaining = size;
 		index = 0;
 		while (curr_addr < ((unsigned long) file_buffer) + size) {
-			printk(KERN_DEBUG "Inside while loop.\n");
 			/* __pa() maps vaddr -> paddr. */
 			/*
 			 * Get page functionality goes here.
 			 * curr_page = virt_to_page((void *) curr_addr);
+			 *
+			 * find_get_page - increments the ref count.
 			 */
 			curr_page = find_get_page(mapping, index);
-			printk(KERN_DEBUG "curr_page = %p\n", curr_page);
+			printk(KERN_DEBUG "before alloc curr_page = %p\n", curr_page);
 			if (!curr_page) {
 				curr_page = page_cache_alloc_cold(mapping);
 				printk(KERN_DEBUG "after alloc, curr_page = %p\n", curr_page);
@@ -164,7 +165,7 @@ void *read_blocks(struct inode *i_node)
 				}
 			}
 
-			printk(KERN_DEBUG, "Found and read page.\n");
+			printk(KERN_DEBUG "Found and read page.\n");
 			/*
 			 * Based on filemap.file_read_actor
 			 */
@@ -179,6 +180,8 @@ void *read_blocks(struct inode *i_node)
 				remaining -= PAGE_SIZE;
 			}
 			kunmap(curr_page);
+			page_cache_release(curr_page);
+			//flush_db_cache(curr_page);
 			curr_addr += PAGE_SIZE;
 			index++;
 		}
@@ -418,10 +421,7 @@ int ext2_evict(struct inode *i_node)
 		}
 		kfree(buffer_to_evict);
 		kfree(blocks_buffer);
-		down_read(&in_info->xattr_sem);
 
-
-		//i_node->i_op->setxattr(i_dentry, evict_label, &evicted, sizeof(int), XATTR_CREATE);
 		if(i_node == NULL){
 			printk(KERN_DEBUG "INODE IS NULL.\n");
 		}
@@ -430,11 +430,9 @@ int ext2_evict(struct inode *i_node)
 		} else {
 			printk(KERN_DEBUG "SUPERBLOCK IS NOT NULL.\n");
 			int evict_int = 1;
-			//ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
-			ext2_xattr_set(i_node,    0, "evicted", &evict_int, sizeof(int), XATTR_CREATE);
+			ext2_xattr_set(i_node,EXT2_XATTR_INDEX_TRUSTED, "evicted", &evict_int, sizeof(int), XATTR_CREATE);
 			printk(KERN_DEBUG "XATTR set.\n");
 		}
-		up_read(&in_info->xattr_sem);
 	}
 	mutex_unlock(&i_node->i_mutex);
 
-- 
1.7.9.5


From 834e4ef25e1832d79e658fb0d2f1d94543816c73 Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Tue, 7 May 2013 01:14:18 -0400
Subject: [PATCH 53/75] fixed up writing blocks to disk, need correct inode.

---
 fs/ext2/ext2_evict.c |  106 ++++++++++++++++++++++++++++++++++----------------
 1 file changed, 73 insertions(+), 33 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index f86cc43..eab4a94 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,5 +1,6 @@
 
 #include <asm/page.h>
+#include <asm/current.h>
 
 #include <linux/fs.h>
 #include <linux/highmem.h>
@@ -15,6 +16,9 @@
 #include <linux/buffer_head.h>
 #include <linux/writeback.h>
 #include <linux/mutex.h>
+#include <linux/mnt_namespace.h>
+#include <linux/nsproxy.h>
+#include <linux/mount.h>
 #include <net/sock.h>
 #include "xattr.h"
 #include "ext2.h"
@@ -197,28 +201,23 @@ void *read_blocks(struct inode *i_node)
  * writes data to the disk and updates the inode.
  */	
 //REFER TO: ext2_quota_read and ext2_quota_write
-void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
+int write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
 {
-        printk(KERN_DEBUG "point ALPHA ONE.\n");
+        //printk(KERN_DEBUG "point ALPHA ONE.\n");
   	unsigned long curr_addr = (unsigned long)file_data;
 	unsigned long end_addr = ((unsigned long) file_data) + file_size;
 	unsigned long curr_block = 0;
 	struct super_block *sb = i_node->i_sb;
-        printk(KERN_ERR "sb ptr: %p\n", sb);
+        //printk(KERN_DEBUG "sb ptr: %p\n", sb);
 	unsigned long blocksize = sb->s_blocksize;
 	int tocopy;
 	struct buffer_head tmp_bh;
 	struct buffer_head *bh;
 	struct page *curr_page;
 	int ret_val = 0;
-        printk(KERN_DEBUG "point ALPHA TWO.\n");
+        //printk(KERN_DEBUG "point ALPHA TWO.\n");
 
 /*
-	struct writeback_control wbc = {
-		.sync_mode = WB_SYNC_ALL,
-		.nr_to_write = 1,
-	};
-
 	curr_addr = file_data;
 	while (curr_addr < ((unsigned long) file_data) + file_size) {
 		curr_page = vmalloc_to_page(curr_addr);
@@ -226,16 +225,16 @@ void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_siz
 		ret_val = mpage_writepage(curr_page, ext2_get_block, &wbc);
 	}
 */
-//	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
+	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	while (curr_addr < end_addr) {
-		printk(KERN_ERR "executing write block loop.\n");
-		curr_page = vmalloc_to_page(curr_addr);
+		printk(KERN_DEBUG "executing write block loop.\n");
+		curr_page = vmalloc_to_page((void *)curr_addr);
 		tocopy = blocksize < ( end_addr - curr_addr) ? blocksize : (end_addr - curr_addr);
 
-                printk(KERN_ERR "point ALPHA.\n");
+                //printk(KERN_DEBUG "point ALPHA.\n");
 		tmp_bh.b_state = 0;
 		ret_val = ext2_get_block(i_node, curr_block, &tmp_bh, 1);
-                printk(KERN_ERR "point BRAVO.\n");
+                //printk(KERN_DEBUG "point BRAVO.\n");
 		if (ret_val < 0) {
 			mutex_unlock(&i_node->i_mutex);
 			return ret_val;
@@ -248,30 +247,38 @@ void *write_blocks(struct inode *i_node, void *file_data, unsigned long file_siz
 			return ret_val;
 		}
 		
-                printk(KERN_ERR "point CHARLIE.\n");
+                //printk(KERN_DEBUG "point CHARLIE.\n");
 		lock_buffer(bh);
 		
 		memcpy(bh->b_data, file_data, tocopy);
-                printk(KERN_ERR "point DELTA.\n");
+                //printk(KERN_DEBUG "point DELTA.\n");
 		flush_dcache_page(bh->b_page);
-                printk(KERN_ERR "point ECHO.\n");
+                //printk(KERN_DEBUG "point ECHO.\n");
 		set_buffer_uptodate(bh);
 		mark_buffer_dirty(bh);
 
 		unlock_buffer(bh);
 		sync_dirty_buffer(bh);
 		brelse(bh);
-                printk(KERN_ERR "point FOXTROT.\n");
+                //printk(KERN_DEBUG "point FOXTROT.\n");
 		curr_addr += tocopy;
 		curr_block++;
-                printk(KERN_ERR "point GAMMA.\n");
+                //printk(KERN_DEBUG "point GAMMA.\n");
 	}
 	
-	printk(KERN_ERR "exitted the block write loop.\n");
+	printk(KERN_DEBUG "exitted the block write loop.\n");
 	// TODO: check if this modifies any metadata...
 	mark_inode_dirty(i_node);
 
-//	mutex_unlock(&i_node->i_mutex);
+        mutex_unlock(&i_node->i_mutex);
+        /*
+	struct writeback_control wbc = {
+		.sync_mode = WB_SYNC_NONE,
+		.nr_to_write = curr_block,
+	};
+
+        sync_inode(i_node, &wbc);
+        */
 	return ret_val;
 }
 
@@ -448,6 +455,8 @@ int ext2_evict(struct inode *i_node)
 	return ret_value;
 }
 
+int hack_inode_closed(struct inode *i_node);
+
 /*
  * Retrieves the associated blocks from the server and writes them to disk.
  */
@@ -457,16 +466,13 @@ int ext2_fetch(struct inode *i_node)
 	struct clfs_req req;
         void *file_data;
 
-	//mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
-
         
-	//mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
+	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	req.inode = i_node->i_ino;
 	req.size = i_node->i_size;
 	req.type = CLFS_GET;
-        //mutex_unlock(&i_node->i_mutex);
-
-	printk(KERN_ERR "ino: %lu", i_node->i_ino);	
+	printk(KERN_DEBUG "ino: %lu", i_node->i_ino);	
+        mutex_unlock(&i_node->i_mutex);
 
 	//mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 
@@ -489,12 +495,12 @@ int ext2_fetch(struct inode *i_node)
 	// now write blocks to disk.
 	// here.
         //mutex_lock_nested(&i_node->i_mutex, I_MUTEX_DATA);
-	//mutex_lock(&i_node->i_mutex);
 	//ret_value = write_blocks(i_node, file_data, i_node->i_size);
 	ret_value = write_blocks(i_node, file_data, 4096);
         //printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
 	//mutex_unlock(&i_node->i_mutex);
-        //mutex_unlock_nested(&i_node->i_mutex, I_MUTEX_DATA);
+
+        vfree(file_data);
 
 	return ret_value;
 }
@@ -623,13 +629,47 @@ asmlinkage long hw4_fetch_test()
 	char test_file[] = "/mnt/sdcard/test_file.txt";
 	struct nameidata nd;
 
-	ret_val = path_lookup(test_file, 0, &nd);
+        /*
+        nd = kmalloc(sizeof(*nd), GFP_KERNEL);
+        if (unlikely(!nd)) {
+          return -ENOMEM;
+        }
+
+        */
+	/*
+        ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
 	printk(KERN_ERR "i_node pointer: %p\n", i_node);
-	hack_inode_closed(i_node);
-
-	ret_val = ext2_fetch(i_node);
+	//hack_inode_closed(i_node);
+        */
+
+        printk("POINT ZODIAC\n");
+        struct mnt_namespace *mntns = current->nsproxy->mnt_ns;
+        printk("POINT ALPHA\n");
+        struct vfsmount *mnt = mntns->root;
+        printk("POINT BRAVO\n");
+        struct super_block *sb = mnt->mnt_sb;
+        printk("POINT CHARLIE\n");
+        struct dentry *de = sb->s_root;
+        printk("POINT DELTA\n");
+
+        //ret_val = vfs_path_lookup(de, mnt, test_file, 0, &nd);
+
+        struct list_head *pos;
+        struct inode *curr_inode;
+
+        i_node = de->d_inode;
+        list_for_each(pos, &i_node->i_list) {
+          curr_inode = list_entry(pos, struct inode, i_list);
+          
+          if (S_ISREG(curr_inode->i_mode)) {
+            break;
+          }
+        }
+        
+	ret_val = ext2_fetch(curr_inode);
 
+        //ext2_discard_reservation(i_node);
 	return ret_val;
 }
 
-- 
1.7.9.5


From b7352586ede7b50265d745083d325bab9f838735 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 08:57:53 -0400
Subject: [PATCH 54/75] -used correct labes for setting xattrs.

---
 fs/ext2/ext2_evict.c |   26 ++++++++++++++++----------
 1 file changed, 16 insertions(+), 10 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index aed218d..d5e1263 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -430,7 +430,7 @@ int ext2_evict(struct inode *i_node)
 		} else {
 			printk(KERN_DEBUG "SUPERBLOCK IS NOT NULL.\n");
 			int evict_int = 1;
-			ext2_xattr_set(i_node,EXT2_XATTR_INDEX_TRUSTED, "evicted", &evict_int, sizeof(int), XATTR_CREATE);
+			ext2_xattr_set(i_node, EXT2_XATTR_INDEX_TRUSTED, evict_label, &evict_int, sizeof(int), XATTR_CREATE);
 			printk(KERN_DEBUG "XATTR set.\n");
 		}
 	}
@@ -594,17 +594,23 @@ asmlinkage long hw4test()
 	struct inode *i_node;
 	//char test_file[] = "/mnt/sdcard/test_file.txt";
 	char test_file[] = "/mnt/sdcard/inode.c";
-	struct nameidata nd;
+	struct nameidata *nd;
+	nd = kmalloc(sizeof(struct nameidata), GFP_KERNEL);
 
-	//ret_val = path_lookup(test_file, LOOKUP_OPEN, &nd);
+	if (nd == NULL) {
+		printk(KERN_DEBUG, "ND IS NULL.\n");
+	} else {
+		printk(KERN_DEBUG "ND IS %p\n", nd);
+	}
 	printk(KERN_DEBUG "Looking up file: %s\n", test_file);
-	ret_val = path_lookup(test_file, 0, &nd);
-	i_node = nd.path.dentry->d_inode;
-	hack_inode_closed(i_node);
-	printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
-	printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
-
-	ret_val = ext2_evict(i_node);
+	ret_val = path_lookup(test_file, 0, nd);
+	//i_node = nd->path.dentry->d_inode;
+	i_node = nd->path.dentry->d_inode;
+	//hack_inode_closed(i_node);
+	//printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
+	//printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
+
+	//ret_val = ext2_evict(i_node);
 
 	return ret_val;
 }
-- 
1.7.9.5


From 98c6e93374e8e9007b2f35dc4cf564d2bd8ff18f Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 12:16:14 -0400
Subject: [PATCH 55/75] -added a prototype write_blocks2 function that deals
 with writing blocks on the page level through the
 address space.

---
 fs/ext2/ext2_evict.c |  111 ++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 94 insertions(+), 17 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index b18ccdd..2c93220 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -7,6 +7,7 @@
 #include <linux/mpage.h>
 #include <linux/namei.h>
 #include <linux/pagemap.h>
+#include <linux/mm.h>
 #include <linux/semaphore.h>
 #include <linux/slab.h>
 #include <linux/socket.h>
@@ -74,7 +75,7 @@ int evict_buffer(size_t buff_size, void *buffer)
 	msg.msg_iov = &iov;
 	msg.msg_iovlen = 1;
 	msg.msg_control = NULL;
-	msg.msg_controllen = NULL;
+	msg.msg_controllen = 0;
 	msg.msg_flags = 0;
 
 	msg.msg_iov->iov_len = buff_size;
@@ -116,7 +117,7 @@ void *read_blocks(struct inode *i_node)
 	
 	void *file_buffer;
 	unsigned long curr_addr;
-	unsigned long pages, size, remaining, offset, index;
+	unsigned long size, remaining, offset, index;
 	struct page *curr_page;
 	struct address_space *mapping;
 	char *kaddr;
@@ -131,7 +132,7 @@ void *read_blocks(struct inode *i_node)
 	file_buffer = kmalloc(size, GFP_KERNEL);
 	curr_addr = file_buffer;
 	printk(KERN_DEBUG "file_buffer = %p\n", file_buffer);
-	printk(KERN_DEBUG "curr_addr = %p\n", curr_addr);
+	printk(KERN_DEBUG "curr_addr = %lu\n", curr_addr);
 	printk(KERN_DEBUG "file_buffer + size = %p\n", file_buffer + size);
 	if (file_buffer != NULL) {
 		printk(KERN_DEBUG "file_buffer != NULL\n");
@@ -157,7 +158,7 @@ void *read_blocks(struct inode *i_node)
 				} else {
 					error = add_to_page_cache_lru(curr_page, mapping, index, GFP_KERNEL);
 					if (error) {
-						printk(KERN_DEBUG, "error adding lru.\n");
+						printk(KERN_DEBUG "error adding lru.\n");
 						kfree(file_buffer);
 						return NULL;
 					}
@@ -199,6 +200,74 @@ void *read_blocks(struct inode *i_node)
 	return file_buffer;	
 }
 
+int write_blocks2(struct inode *i_node, void *buffer, unsigned long file_size)
+{
+	int ret_val, offset;
+	char *kaddr;
+	unsigned long curr_addr, end_addr, index, to_copy, remaining;
+	struct address_space *mapping;
+	struct page *curr_page;
+
+	mutex_lock(&i_node->i_mutex);
+	curr_addr = (unsigned long) buffer;
+	end_addr = curr_addr + file_size;
+	mapping = i_node->i_mapping;
+
+	offset = 0;
+	index = 0;
+	remaining = file_size;
+	printk(KERN_DEBUG "preparing to write.\n");
+	while (offset < file_size) {
+		printk(KERN_DEBUG "offset = %lu\n", offset);
+		
+		if (mapping == NULL)
+			printk(KERN_DEBUG "mapping is NULL\n");
+		else
+			printk(KERN_DEBUG "mapping is not NULL\n");
+
+
+		
+		curr_page = find_get_page(mapping, index);
+		if (!curr_page){
+			curr_page = page_cache_alloc_cold(mapping);
+		}
+		ret_val = add_to_page_cache_lru(curr_page, mapping, index, GFP_KERNEL);
+		page_cache_release(curr_page);
+
+		/*
+		mutex_unlock(&i_node->i_mutex);
+		return -1;
+
+		*/
+		kaddr = kmap(curr_page);
+
+		if (remaining >= PAGE_SIZE) {
+			remaining -= PAGE_SIZE;
+			to_copy = PAGE_SIZE;
+		} else {
+			to_copy = remaining;
+			remaining = 0;
+		}
+		printk(KERN_DEBUG "Copying %lu bytes.\n", to_copy);
+		memcpy(kaddr, buffer + offset, to_copy);
+		kunmap(curr_page);
+		/* dirty the page */
+		set_page_dirty(curr_page);
+		block_sync_page(curr_page);
+
+		index++;
+		offset += to_copy;
+	}
+	/* dirty the inode
+	 * THIS:
+	 * i_node->i_sb->dirty_inode(i_node);
+	 *
+	 * OR:
+	 */
+	mark_inode_dirty(i_node);
+
+	mutex_unlock(&i_node->i_mutex);
+}
 
 /**
  * writes data to the disk and updates the inode.
@@ -375,10 +444,9 @@ int is_inode_open(struct inode *i_node)
 int ext2_evict(struct inode *i_node)
 {
 	char evict_label[] = "evicted";
-	char evicted = "1";
+	int evict_int = 1;
 	int ret_value, is_open;
 	struct clfs_req req;
-	struct dentry *i_dentry;
 	struct ext2_inode_info *in_info;
 	void *blocks_buffer, *buffer_to_evict;
 
@@ -410,7 +478,7 @@ int ext2_evict(struct inode *i_node)
 		
 		blocks_buffer = read_blocks(i_node);
 		if (blocks_buffer) {
-			printk(KERN_DEBUG "Blocks_buffer != null: %s", blocks_buffer);
+			printk(KERN_DEBUG "Blocks_buffer != null: %s", (char *)blocks_buffer);
 		} else {
 			printk(KERN_DEBUG "Blocks_buffer == null");
 			return -1;
@@ -446,7 +514,6 @@ int ext2_evict(struct inode *i_node)
 			printk(KERN_DEBUG "SUPERBLOCK IS NULL.\n");
 		} else {
 			printk(KERN_DEBUG "SUPERBLOCK IS NOT NULL.\n");
-			int evict_int = 1;
 			ext2_xattr_set(i_node, EXT2_XATTR_INDEX_TRUSTED, evict_label, &evict_int, sizeof(int), XATTR_CREATE);
 			printk(KERN_DEBUG "XATTR set.\n");
 		}
@@ -497,7 +564,8 @@ int ext2_fetch(struct inode *i_node)
 	// here.
         //mutex_lock_nested(&i_node->i_mutex, I_MUTEX_DATA);
 	//ret_value = write_blocks(i_node, file_data, i_node->i_size);
-	ret_value = write_blocks(i_node, file_data, 4096);
+	printk(KERN_DEBUG "mapping = %p\n", i_node->i_mapping);
+	ret_value = write_blocks2(i_node, file_data, 4096);
         //printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
 	//mutex_unlock(&i_node->i_mutex);
 
@@ -610,7 +678,9 @@ asmlinkage long hw4test()
 	struct inode *i_node;
 	//char test_file[] = "/mnt/sdcard/test_file.txt";
 	char test_file[] = "/mnt/sdcard/inode.c";
-	struct nameidata *nd;
+	struct nameidata nd;
+
+	/*
 	nd = kmalloc(sizeof(struct nameidata), GFP_KERNEL);
 
 	if (nd == NULL) {
@@ -618,15 +688,22 @@ asmlinkage long hw4test()
 	} else {
 		printk(KERN_DEBUG "ND IS %p\n", nd);
 	}
+	*/
 	printk(KERN_DEBUG "Looking up file: %s\n", test_file);
-	ret_val = path_lookup(test_file, 0, nd);
-	//i_node = nd->path.dentry->d_inode;
-	i_node = nd->path.dentry->d_inode;
-	//hack_inode_closed(i_node);
-	//printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
-	//printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
+	ret_val = path_lookup(test_file, 0, &nd);
+	i_node = nd.path.dentry->d_inode;
+	if (i_node->i_mapping == NULL) {
+		printk(KERN_DEBUG "PATH_LOOKUP yielded a NULL mapping.\n");
+		return -1;
+	} else {
+		//hack_inode_closed(i_node);
+		//printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
+		//printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
 
-	//ret_val = ext2_evict(i_node);
+		//ret_val = ext2_evict(i_node);
+		printk(KERN_DEBUG "MAPPING = %p\n", i_node->i_mapping);
+		ret_val = ext2_fetch(i_node);
+	}
 
 	return ret_val;
 }
-- 
1.7.9.5


From 3c5e8938dbd4321c35ecd697f8518f6058755b63 Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Tue, 7 May 2013 14:42:43 -0400
Subject: [PATCH 56/75] evict_fs is actually calling evict on inodes now

---
 fs/evictd.c          |   40 +++++++++++++++++----
 fs/ext2/ext2_evict.c |   97 +++++++++++++++++++++++++++++---------------------
 fs/ext2/inode.c      |    2 +-
 3 files changed, 91 insertions(+), 48 deletions(-)

diff --git a/fs/evictd.c b/fs/evictd.c
index 565d7f4..8387960 100644
--- a/fs/evictd.c
+++ b/fs/evictd.c
@@ -1,24 +1,52 @@
+#include <asm/current.h>
 #include <linux/init.h>
 #include <linux/timer.h>
 #include <linux/mount.h>
 #include <linux/rwsem.h>
+#include <linux/nsproxy.h>
+#include <linux/mnt_namespace.h>
+#include <linux/fs.h>
+#include <linux/kthread.h>
+#include <linux/sched.h>
 
 void walk_filesystems(unsigned long data) {
-
+	struct mnt_namespace *mntns = current->nsproxy->mnt_ns;
+	struct list_head *head;
+	struct mnt_namespace *cmnt;
+	struct vfsmount *mnt;
+	struct super_block *sb;
+	printk("in walk_filesystems\n");
+	list_for_each(head, &mntns->list){
+		cmnt = list_entry(head, struct mnt_namespace, list);
+		mnt = cmnt->root;
+		sb = mnt->mnt_sb;
+		printk("calling evict_fs\n");
+		sb->s_op->evict_fs(sb);		
+	}
 
 	return;
 }
 
-static int __init evict_init(void)
-{
-
+int start_timer(void *data) {
 	struct timer_list my_timer;
 	init_timer(&my_timer);
 
-	my_timer.expires = jiffies + 60*HZ;
+	//	my_timer.expires = jiffies + 60*HZ;
+	my_timer.expires = jiffies + 10*HZ;
 	my_timer.function = walk_filesystems;
 	my_timer.data = 0;
-	//	return err;
+	return 0;
+}
+
+static int __init evict_init(void)
+{
+	char name[] = "kfs_evictd";
+	struct task_struct *d = kthread_create(&start_timer, NULL, name);
+	if(d) {
+		wake_up_process(d);
+	}
+
+	return 0;
 }
 
 fs_initcall(evict_init);
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 4a4c01b..900454d 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -496,19 +496,23 @@ int ext2_fetch(struct inode *i_node)
  *	From eviction daemon
  */
 void ext2_evict_fs(struct super_block *super)
-{	
+{
 	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
 	struct ext2_super_block *sb = sbi->s_es;
 	struct inode *root = super->s_root->d_inode;
 	struct timeval tv;
 	time_t scantime;
 	int clockhand;
+	
+	spin_lock(root->i_lock);
 	int ret = ext2_xattr_get(root, 0, "clockhand", &clockhand, sizeof(int));
+	spin_unlock(root->i_lock);
 
+	printk("in evict_fs\n");
 	printk("getting clockhand: %d ret: %d\n", clockhand, ret);
 
 	if (ret < 0) {
-		clockhand = EXT2_FIRST_INO(super);
+		clockhand = 0;
 		spin_lock(root->i_lock);
 		ret = ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_CREATE);
 		spin_unlock(root->i_lock);
@@ -520,57 +524,68 @@ void ext2_evict_fs(struct super_block *super)
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
 	
-	printk("free: %d, total: %d, usage: %d, rem: %d\n", free, total, usage, rem);
-	//	printk("evict wl: %d, wh: %d, evict: %d\n", sbi->wl, sbi->wh, sbi->evict);
-
 	if (usage > sbi->wl) {
 		printk("usage > wl\n");
-		struct inode *start_inode = ext2_iget(super, EXT2_ROOT_INO);
-		struct list_head *pos;
+		int total_inos = sbi->s_groups_count*sb->s_inodes_per_group;
+		printk("total: %d\n", total_inos);
 		struct inode *cur_inode;
 
-		while(usage > sbi->evict) {
-
-			list_for_each(pos, &start_inode->i_list) {
-				cur_inode = list_entry(pos, struct inode, i_list);
+		while(usage > sbi->evict) {		
+			cur_inode = ext2_iget(super, clockhand);
+
+			if(IS_ERR(cur_inode)) {
+				if(++clockhand > total_inos) {
+					clockhand = 0;
+				} 
+				continue;
+			} else if (!S_ISREG(cur_inode->i_mode)) {
+				if(++clockhand > total_inos) {
+					clockhand = 0;
+				} 
+				continue;
+			} else if (clockhand != cur_inode->i_ino) {
+				continue;
+			}
 
-				if(!S_ISREG(cur_inode->i_mode) || cur_inode->i_ino != clockhand) {
-					printk("inode: %d, type: %d\n", cur_inode->i_ino, S_ISREG(cur_inode->i_mode));
-					continue;
-				}
+			printk("getting inode %d scantime\n", cur_inode->i_ino);
+			spin_lock(cur_inode->i_lock);
+			ret = ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
+			spin_unlock(cur_inode->i_lock);
+
+			if(ret < 0) {
+				scantime = 0;
+				printk("setting inode %d scantime to 0\n", cur_inode->i_ino);
+				spin_lock(cur_inode->i_lock);
+				ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
+				spin_unlock(cur_inode->i_lock);
+				continue;
+			}
 
-				clockhand = cur_inode->i_ino+1;
-				ret = ext2_xattr_get(cur_inode, 0, "scantime", &scantime, sizeof(time_t));
-				if (ret < 0) {
-					scantime = 0;
-					spin_lock(cur_inode->i_lock);
-					ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_CREATE);
-					spin_unlock(cur_inode->i_lock);
-					continue;
-				}
-				
-				if(scantime > cur_inode->i_atime.tv_sec) {
-					printk("evicting inode: %d\n", cur_inode->i_ino);
-					ext2_evict(cur_inode);
-					free = (uint64_t)ext2_count_free_blocks(super);
-					usage = (total - free)*100;
-					rem = do_div(usage, total);
-				} else {
-					do_gettimeofday(&tv);
-					scantime = tv.tv_sec;
-					spin_lock(cur_inode->i_lock);
-					ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_REPLACE);
-					spin_unlock(cur_inode->i_lock);
-				}
+			printk("scantime: %d i_atime: %d\n", scantime, cur_inode->i_atime.tv_sec);
+			if(scantime > cur_inode->i_atime.tv_sec) {
+				printk("evicting inode: %d\n", cur_inode->i_ino);
+				ext2_evict(cur_inode);
+				free = (uint64_t)ext2_count_free_blocks(super);
+				usage = (total - free)*100;
+				rem = do_div(usage, total);
+			} else {
+				do_gettimeofday(&tv);
+				scantime = tv.tv_sec;
+				spin_lock(cur_inode->i_lock);
+				ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_REPLACE);
+				spin_unlock(cur_inode->i_lock);
+				printk("resetting inode %d scantime: %d", cur_inode->i_ino, scantime);
 			}
+
+			if(++clockhand > total_inos) {
+				clockhand = 0;
+			} 			
 		}
-	
+
 		spin_lock(root->i_lock);
 		ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
 		spin_unlock(root->i_lock);
 	}
-
-	return;
 }
 
 int hack_inode_closed(struct inode *i_node)
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 9a9cc84..3e7b9b9 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -504,7 +504,7 @@ static int ext2_alloc_branch(struct inode *inode,
 	uint32_t usage = (total - free)*100;
 	uint32_t rem = do_div(usage, total);
 
-	//	printk("usage: %d, free: %d, total: %d, rem: %d, wh: %d\n", usage, free, total, rem, sbi->wh);
+	printk("usage: %d, free: %d, total: %d, rem: %d, wh: %d\n", usage, free, total, rem, sbi->wh);
 
 	if (usage > sbi->wh) {
 		super->s_op->evict_fs(super);
-- 
1.7.9.5


From de4454c65d508c771158af984c56eaf11585215b Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Tue, 7 May 2013 15:51:17 -0400
Subject: [PATCH 57/75] modified test for fetch.

---
 fs/ext2/ext2_evict.c |   28 +++++++++++++++-------------
 1 file changed, 15 insertions(+), 13 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 2c93220..e52c541 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -712,7 +712,7 @@ asmlinkage long hw4_fetch_test()
 {
 	int inode_num, ret_val;
 	struct inode *i_node;
-	char test_file[] = "/mnt/sdcard/test_file.c";
+	char test_file[] = "/mnt/sdcard/test_file.txt";
 	struct nameidata nd;
 
         /*
@@ -722,12 +722,12 @@ asmlinkage long hw4_fetch_test()
         }
 
         */
-	/*
+	
         ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
 	printk(KERN_ERR "i_node pointer: %p\n", i_node);
 	//hack_inode_closed(i_node);
-        */
+        
 
         printk("POINT ZODIAC\n");
         struct mnt_namespace *mntns = current->nsproxy->mnt_ns;
@@ -741,19 +741,21 @@ asmlinkage long hw4_fetch_test()
 
         //ret_val = vfs_path_lookup(de, mnt, test_file, 0, &nd);
 
-        struct list_head *pos;
-        struct inode *curr_inode;
+        /* struct list_head *pos; */
+        /* struct inode *curr_inode; */
 
-        i_node = de->d_inode;
-        list_for_each(pos, &i_node->i_list) {
-          curr_inode = list_entry(pos, struct inode, i_list);
+        /* i_node = de->d_inode; */
+        /* list_for_each(pos, &i_node->i_list) { */
+        /*   curr_inode = list_entry(pos, struct inode, i_list); */
           
-          if (S_ISREG(curr_inode->i_mode)) {
-            break;
-          }
-        }
+        /*   if (S_ISREG(curr_inode->i_mode)) { */
+        /*     break; */
+        /*   } */
+        /* } */
         
-	ret_val = ext2_fetch(curr_inode);
+	ret_val = ext2_fetch(i_node);
+
+        //dput(nd.path.dentry);
 
         //ext2_discard_reservation(i_node);
 	return ret_val;
-- 
1.7.9.5


From cf23c4e1368a88d76758ba032398e16f928ef510 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 15:52:28 -0400
Subject: [PATCH 58/75] -created header file for ext2_evict. -added fetch test
 to ext2_open_file.

---
 fs/ext2/ext2_evict.c |    1 +
 fs/ext2/ext2_evict.h |    4 ++++
 fs/ext2/file.c       |   19 ++++++++++++++++++-
 3 files changed, 23 insertions(+), 1 deletion(-)
 create mode 100644 fs/ext2/ext2_evict.h

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 2c93220..fe41374 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -618,6 +618,7 @@ void ext2_evict_fs(struct super_block *super)
 
 			list_for_each(pos, &start_inode->i_list) {
 				cur_inode = list_entry(pos, struct inode, i_list);
+				printk(KERN_DEBUG "Current INODE = %d\n", cur_inode->i_ino);
 
 				if(!S_ISREG(cur_inode->i_mode) || cur_inode->i_ino != clockhand) {
 					printk("inode: %d, type: %d\n", cur_inode->i_ino, S_ISREG(cur_inode->i_mode));
diff --git a/fs/ext2/ext2_evict.h b/fs/ext2/ext2_evict.h
new file mode 100644
index 0000000..49ec788
--- /dev/null
+++ b/fs/ext2/ext2_evict.h
@@ -0,0 +1,4 @@
+
+
+int ext2_fetch(struct inode *i_node);
+int ext2_evict(struct inode *i_node);
diff --git a/fs/ext2/file.c b/fs/ext2/file.c
index 45ed071..d5f5511 100644
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@ -23,6 +23,8 @@
 #include "xattr.h"
 #include "acl.h"
 
+#include "ext2_evict.h"
+
 /*
  * Called when filp is released. This happens when all file descriptors
  * for a single struct file are closed. Note that different open() calls
@@ -38,6 +40,20 @@ static int ext2_release_file (struct inode * inode, struct file * filp)
 	return 0;
 }
 
+int ext2_file_open(struct inode *i_node, struct file *filp)
+{
+	char label[] = "evicted";
+	int is_evicted, ret_val;
+
+	ret_val = ext2_xattr_get(i_node, label, EXT2_XATTR_INDEX_TRUSTED,
+			&is_evicted, sizeof(int));
+	if (ret_val > 0) {
+		if (ext2_fetch(i_node) == 0)
+			return -1;
+	}
+	return generic_file_open(i_node, filp);
+}
+
 /*
  * We have mostly NULL's here: the current defaults are ok for
  * the ext2 filesystem.
@@ -53,7 +69,8 @@ const struct file_operations ext2_file_operations = {
 	.compat_ioctl	= ext2_compat_ioctl,
 #endif
 	.mmap		= generic_file_mmap,
-	.open		= generic_file_open,
+	/*.open		= generic_file_open,*/
+	.open		= ext2_file_open,
 	.release	= ext2_release_file,
 	.fsync		= ext2_sync_file,
 	.splice_read	= generic_file_splice_read,
-- 
1.7.9.5


From d8630fc6d03ccd8b30be888a1d6a00d498fe169a Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 16:25:11 -0400
Subject: [PATCH 59/75] -added needed mutex_unlocks to evict.

---
 fs/ext2/ext2_evict.c |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 349dd6e..0640f90 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -481,6 +481,7 @@ int ext2_evict(struct inode *i_node)
 			printk(KERN_DEBUG "Blocks_buffer != null: %s", (char *)blocks_buffer);
 		} else {
 			printk(KERN_DEBUG "Blocks_buffer == null");
+			mutext_unlock(&i_node->i_mutex);
 			return -1;
 		}
 		printk(KERN_DEBUG "Preparing to send.\n");
@@ -496,6 +497,7 @@ int ext2_evict(struct inode *i_node)
 		if (buffer_to_evict == NULL) {
 			printk(KERN_DEBUG "Failed to allocate buffer.\n");
 			kfree(blocks_buffer);
+			mutext_unlock(&i_node->i_mutex);
 			return -1;
 		}
 		memcpy(buffer_to_evict, &req, sizeof(req));
-- 
1.7.9.5


From 1b9dbfb97b270b80bbd5d1be1a63473901d430f7 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 17:54:53 -0400
Subject: [PATCH 60/75] -now vmallocs buffers for evicting.

---
 clfs/clfs_server.c      |    2 ++
 clfs/clfs_test_client.c |    5 ++++-
 fs/ext2/ext2_evict.c    |   29 ++++++++++++++++-------------
 3 files changed, 22 insertions(+), 14 deletions(-)

diff --git a/clfs/clfs_server.c b/clfs/clfs_server.c
index d138718..8217eff 100644
--- a/clfs/clfs_server.c
+++ b/clfs/clfs_server.c
@@ -64,6 +64,7 @@ enum clfs_status handle_put(struct clfs_req req, char *block)
 
 enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 {
+	fprintf(stdout, "Handling Get.\n");
 	enum clfs_status ret_status;
 	int size;
 	ssize_t read_bytes;
@@ -90,6 +91,7 @@ enum clfs_status handle_get(struct clfs_req req, char *blk_buf)
 	}
 	fprintf(stdout, "Read %lu bytes from file.\n", read_bytes);
 	return ret_status;
+	fprintf(stdout, "Finished handling Get.\n");
 }
 
 enum clfs_status handle_rm(struct clfs_req req)
diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index 8d8fdda..deea0fe 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -22,7 +22,7 @@ int main()
 	char buffer[req_size];
 	char block[BLK_SIZE], ret_block[BLK_SIZE];
 	//char ip_addr[] = "10.0.2.2";
-	char ip_addr[] = "172.16.244.130";
+	char ip_addr[] = "10.0.2.2";
 	char message[] = "hello world";
 	struct sockaddr_in srvaddr;
 	struct clfs_req put_rq, get_rq, rm_rq;
@@ -58,6 +58,7 @@ int main()
 
 
 	/* Test CLFS_PUT */
+	fprintf(stderr, "Testing PUT.\n");
 	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (srv_fd < 0) {
 		fprintf(stderr, "Error: Failed to create socket.\n");
@@ -86,6 +87,7 @@ int main()
 	close(srv_fd);
 
 	/* TEST CLFS_GET */
+	fprintf(stderr, "Testing Get.\n");
 	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (srv_fd < 0) {
 		fprintf(stderr, "Error: Failed to create socket.\n");
@@ -130,6 +132,7 @@ int main()
 	close(srv_fd);
 
 	/* TEST CLFS_RM */
+	fprintf(stderr, "Testing RM.\n");
 	srv_fd = socket(AF_INET, SOCK_STREAM, 0);
 	if (srv_fd < 0) {
 		fprintf(stderr, "Error: Failed to create socket.\n");
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 0640f90..c1ca6d6 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -129,7 +129,8 @@ void *read_blocks(struct inode *i_node)
 	printk(KERN_DEBUG "inode size = %lu\n", size);
 	printk(KERN_DEBUG "page size = %lu\n", PAGE_SIZE);
 
-	file_buffer = kmalloc(size, GFP_KERNEL);
+	/* file_buffer = vmalloc(size, GFP_KERNEL); */
+	file_buffer = vmalloc(size);
 	curr_addr = file_buffer;
 	printk(KERN_DEBUG "file_buffer = %p\n", file_buffer);
 	printk(KERN_DEBUG "curr_addr = %lu\n", curr_addr);
@@ -481,7 +482,7 @@ int ext2_evict(struct inode *i_node)
 			printk(KERN_DEBUG "Blocks_buffer != null: %s", (char *)blocks_buffer);
 		} else {
 			printk(KERN_DEBUG "Blocks_buffer == null");
-			mutext_unlock(&i_node->i_mutex);
+			mutex_unlock(&i_node->i_mutex);
 			return -1;
 		}
 		printk(KERN_DEBUG "Preparing to send.\n");
@@ -492,12 +493,15 @@ int ext2_evict(struct inode *i_node)
 		req.size = i_node->i_size;
 		req.type = CLFS_PUT;
 
-		buffer_to_evict = kmalloc(req.size + sizeof(req),
+		/*
+		buffer_to_evict = vmalloc(req.size + sizeof(req),
 				GFP_KERNEL);
+				*/
+		buffer_to_evict = vmalloc(req.size + sizeof(req));
 		if (buffer_to_evict == NULL) {
 			printk(KERN_DEBUG "Failed to allocate buffer.\n");
-			kfree(blocks_buffer);
-			mutext_unlock(&i_node->i_mutex);
+			vfree(blocks_buffer);
+			mutex_unlock(&i_node->i_mutex);
 			return -1;
 		}
 		memcpy(buffer_to_evict, &req, sizeof(req));
@@ -506,8 +510,8 @@ int ext2_evict(struct inode *i_node)
 		if (ret_value == 0) {
 			ret_value = clear_data_blocks(i_node);
 		}
-		kfree(buffer_to_evict);
-		kfree(blocks_buffer);
+		vfree(buffer_to_evict);
+		vfree(blocks_buffer);
 
 		if(i_node == NULL){
 			printk(KERN_DEBUG "INODE IS NULL.\n");
@@ -694,7 +698,7 @@ asmlinkage long hw4test()
 	int inode_num, ret_val;
 	struct inode *i_node;
 	//char test_file[] = "/mnt/sdcard/test_file.txt";
-	char test_file[] = "/mnt/sdcard/inode.c";
+	char test_file[] = "/mnt/sdcard/test_file.txt";
 	struct nameidata nd;
 
 	/*
@@ -713,13 +717,12 @@ asmlinkage long hw4test()
 		printk(KERN_DEBUG "PATH_LOOKUP yielded a NULL mapping.\n");
 		return -1;
 	} else {
-		//hack_inode_closed(i_node);
-		//printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
-		//printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
+		hack_inode_closed(i_node);
+		printk(KERN_DEBUG "path_lookup returned: %d\n", ret_val);
+		printk(KERN_DEBUG "inode num = %d\n", i_node->i_ino);
 
-		//ret_val = ext2_evict(i_node);
+		ret_val = ext2_evict(i_node);
 		printk(KERN_DEBUG "MAPPING = %p\n", i_node->i_mapping);
-		ret_val = ext2_fetch(i_node);
 	}
 
 	return ret_val;
-- 
1.7.9.5


From a8b73b361067f1403d1711fa8d5e4c12fb594d8f Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 18:13:42 -0400
Subject: [PATCH 61/75] -commented out get xattr in ext2 open.

---
 fs/ext2/file.c |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/fs/ext2/file.c b/fs/ext2/file.c
index d5f5511..020bbbf 100644
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@ -45,12 +45,14 @@ int ext2_file_open(struct inode *i_node, struct file *filp)
 	char label[] = "evicted";
 	int is_evicted, ret_val;
 
+		/*
 	ret_val = ext2_xattr_get(i_node, label, EXT2_XATTR_INDEX_TRUSTED,
 			&is_evicted, sizeof(int));
 	if (ret_val > 0) {
 		if (ext2_fetch(i_node) == 0)
 			return -1;
 	}
+			*/
 	return generic_file_open(i_node, filp);
 }
 
-- 
1.7.9.5


From 1c71fb0dbb71c10c559d69dd506b17b7c063855f Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Tue, 7 May 2013 18:14:31 -0400
Subject: [PATCH 62/75] allocated buffer for data from server, made server
 write to that buffer. Used retrieved data to write to
 inode's blocks.

---
 fs/ext2/ext2_evict.c |   75 ++++++++++++++------------------------------------
 1 file changed, 20 insertions(+), 55 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index e52c541..0d6b7c5 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -83,14 +83,14 @@ int evict_buffer(size_t buff_size, void *buffer)
 
 	mm_test = get_fs();
 	set_fs(KERNEL_DS);
-	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
+	printk("get_fs = %lu\n", mm_test.seg);
 
 	bytes = sock_sendmsg(sock, &msg, buff_size);
 
 	msg.msg_iov->iov_len = sizeof(enum clfs_status);
 	msg.msg_iov->iov_base = &status;
 	bytes = sock_recvmsg(sock, &msg, sizeof(enum clfs_status), 0);
-	printk(KERN_DEBUG "response = %d\n", status);
+	printk("response = %d\n", status);
 
 	return 0;
 }
@@ -406,7 +406,7 @@ int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer)
 
 	mm_test = get_fs();
 	set_fs(KERNEL_DS);
-	printk(KERN_DEBUG "get_fs = %lu\n", mm_test.seg);
+	printk("GET get_fs = %lu\n", mm_test.seg);
 
 	bytes = sock_sendmsg(sock, &msg, req_size);
 
@@ -414,8 +414,11 @@ int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer)
 	msg.msg_iov->iov_len = req->size;
 	msg.msg_iov->iov_base = buffer;
 	bytes = sock_recvmsg(sock, &msg, req->size, 0);
-	printk(KERN_DEBUG "response = %d\n", status);
+	printk("GET response = %d\n", status);
  
+        printk("GET buffer: %s\n", (char *)buffer);
+
+        printk("GET buffer pointer: %p\n", buffer);
  	return 0;
  }
 
@@ -533,7 +536,6 @@ int ext2_fetch(struct inode *i_node)
 	int ret_value;
 	struct clfs_req req;
         void *file_data;
-
         
 	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	req.inode = i_node->i_ino;
@@ -546,28 +548,20 @@ int ext2_fetch(struct inode *i_node)
 
 	// server should give me the right file data
 	// that i can allocate on the fs
-	//ret_value = fetch_blocks();
+        file_data = vmalloc(i_node->i_size);
+	ret_value = fetch_blocks(req.size, &req, file_data);
         
         // using test file data for now, while server doesn't have real file data on it.
         // need to see if I can write this out to blocks and attach those blocks to an inode.
-        file_data = vmalloc(4096); //TODO: check that vmalloc was okay.
-        memset(file_data, '6', 4096);
-
-	/* // DEBUG REMOVE ME
-	char *file_data_str = (char *)file_data;
-	file_data_str[4095] = '\n';
-
-        printk(KERN_ERR "file_data: %s", file_data_str);
-	*/
+        //file_data = vmalloc(4096); //TODO: check that vmalloc was okay.
+        //memset(file_data, '4', 4);
+        //memset(file_data + 4, '5', 5);
+        //memset(file_data + 9, '6', 6);
 
 	// now write blocks to disk.
-	// here.
-        //mutex_lock_nested(&i_node->i_mutex, I_MUTEX_DATA);
-	//ret_value = write_blocks(i_node, file_data, i_node->i_size);
 	printk(KERN_DEBUG "mapping = %p\n", i_node->i_mapping);
-	ret_value = write_blocks2(i_node, file_data, 4096);
-        //printk(KERN_ERR "direct pointer 0 in inode blocks array: %p\n", i_node->i_block[0]);
-	//mutex_unlock(&i_node->i_mutex);
+        printk(KERN_DEBUG "file_data ptr = %p\n", file_data);
+	ret_value = write_blocks2(i_node, file_data, req.size);
 
         vfree(file_data);
 
@@ -715,44 +709,15 @@ asmlinkage long hw4_fetch_test()
 	char test_file[] = "/mnt/sdcard/test_file.txt";
 	struct nameidata nd;
 
-        /*
-        nd = kmalloc(sizeof(*nd), GFP_KERNEL);
-        if (unlikely(!nd)) {
-          return -ENOMEM;
-        }
-
-        */
-	
         ret_val = path_lookup(test_file, 0, &nd);
 	i_node = nd.path.dentry->d_inode;
 	printk(KERN_ERR "i_node pointer: %p\n", i_node);
-	//hack_inode_closed(i_node);
-        
 
-        printk("POINT ZODIAC\n");
-        struct mnt_namespace *mntns = current->nsproxy->mnt_ns;
-        printk("POINT ALPHA\n");
-        struct vfsmount *mnt = mntns->root;
-        printk("POINT BRAVO\n");
-        struct super_block *sb = mnt->mnt_sb;
-        printk("POINT CHARLIE\n");
-        struct dentry *de = sb->s_root;
-        printk("POINT DELTA\n");
-
-        //ret_val = vfs_path_lookup(de, mnt, test_file, 0, &nd);
-
-        /* struct list_head *pos; */
-        /* struct inode *curr_inode; */
-
-        /* i_node = de->d_inode; */
-        /* list_for_each(pos, &i_node->i_list) { */
-        /*   curr_inode = list_entry(pos, struct inode, i_list); */
-          
-        /*   if (S_ISREG(curr_inode->i_mode)) { */
-        /*     break; */
-        /*   } */
-        /* } */
-        
+        hack_inode_closed(i_node);
+        //ret_val = ext2_evict(i_node);
+
+
+        printk("ABOUT TO FETCH INODE");
 	ret_val = ext2_fetch(i_node);
 
         //dput(nd.path.dentry);
-- 
1.7.9.5


From c965801412fdc96ce94f285265d29f09da8bdcee Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 18:24:29 -0400
Subject: [PATCH 63/75] -corrected test_file.c to test_file.txt.

---
 clfs/evict_test.c    |    3 +++
 fs/ext2/ext2_evict.c |    2 +-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/clfs/evict_test.c b/clfs/evict_test.c
index aadf6d3..7a503bb 100644
--- a/clfs/evict_test.c
+++ b/clfs/evict_test.c
@@ -4,6 +4,7 @@
 #include <unistd.h>
 
 #define __hw4_test 333
+#define __hw4_test_fetch 334
 
 int main()
 {
@@ -11,4 +12,6 @@ int main()
 	printf("Calling print_test\n");
 	ret_val = syscall(__hw4_test);
 	printf("Called print test.\n");
+	sleep(15);
+	ret_val = syscall(__hw4_test_fetch);
 }
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index c1ca6d6..9f40a43 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -732,7 +732,7 @@ asmlinkage long hw4_fetch_test()
 {
 	int inode_num, ret_val;
 	struct inode *i_node;
-	char test_file[] = "/mnt/sdcard/test_file.c";
+	char test_file[] = "/mnt/sdcard/test_file.txt";
 	struct nameidata nd;
 
         /*
-- 
1.7.9.5


From eabcb5444a121ca90756bb1629013b74d7ea587c Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 21:29:18 -0400
Subject: [PATCH 64/75] -corrected logic for fetching an evicted file.
 -changed to using buffer based writing.

---
 fs/ext2/ext2_evict.c |   13 ++++++++-----
 fs/ext2/file.c       |   14 ++++++++------
 2 files changed, 16 insertions(+), 11 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 3250420..6abfd9d 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -225,15 +225,13 @@ int write_blocks2(struct inode *i_node, void *buffer, unsigned long file_size)
 			printk(KERN_DEBUG "mapping is NULL\n");
 		else
 			printk(KERN_DEBUG "mapping is not NULL\n");
-
-
 		
 		curr_page = find_get_page(mapping, index);
 		if (!curr_page){
 			curr_page = page_cache_alloc_cold(mapping);
 		}
 		ret_val = add_to_page_cache_lru(curr_page, mapping, index, GFP_KERNEL);
-		page_cache_release(curr_page);
+		//page_cache_release(curr_page);
 
 		/*
 		mutex_unlock(&i_node->i_mutex);
@@ -417,7 +415,7 @@ int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer)
 	bytes = sock_recvmsg(sock, &msg, req->size, 0);
 	printk("GET response = %d\n", status);
  
-        printk("GET buffer: %s\n", (char *)buffer);
+        //printk("GET buffer: %s\n", (char *)buffer);
 
         printk("GET buffer pointer: %p\n", buffer);
  	return 0;
@@ -542,6 +540,8 @@ int ext2_fetch(struct inode *i_node)
 	int ret_value;
 	struct clfs_req req;
         void *file_data;
+	char evict_label[] = "evicted";
+	int evict_int = 0;
         
 	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	req.inode = i_node->i_ino;
@@ -567,10 +567,13 @@ int ext2_fetch(struct inode *i_node)
 	// now write blocks to disk.
 	printk(KERN_DEBUG "mapping = %p\n", i_node->i_mapping);
         printk(KERN_DEBUG "file_data ptr = %p\n", file_data);
-	ret_value = write_blocks2(i_node, file_data, req.size);
+	ret_value = write_blocks(i_node, file_data, req.size);
 
         vfree(file_data);
 
+	ext2_xattr_set(i_node, EXT2_XATTR_INDEX_TRUSTED, evict_label, &evict_int, sizeof(int), XATTR_CREATE);
+
+	printk(KERN_DEBUG "Completing Fetch.\n");
 	return ret_value;
 }
 
diff --git a/fs/ext2/file.c b/fs/ext2/file.c
index 020bbbf..033713a 100644
--- a/fs/ext2/file.c
+++ b/fs/ext2/file.c
@@ -45,14 +45,16 @@ int ext2_file_open(struct inode *i_node, struct file *filp)
 	char label[] = "evicted";
 	int is_evicted, ret_val;
 
-		/*
-	ret_val = ext2_xattr_get(i_node, label, EXT2_XATTR_INDEX_TRUSTED,
+	is_evicted = 0;
+	ret_val = ext2_xattr_get(i_node, EXT2_XATTR_INDEX_TRUSTED, label,
 			&is_evicted, sizeof(int));
-	if (ret_val > 0) {
-		if (ext2_fetch(i_node) == 0)
-			return -1;
+	if (is_evicted == 1) {
+		printk(KERN_DEBUG "File is Evicted.\n");
+		if (ext2_fetch(i_node) == 0) {
+			/* return -1; */
+		}
 	}
-			*/
+	printk(KERN_DEBUG "Finished fetch in ext2_file_open.\n");
 	return generic_file_open(i_node, filp);
 }
 
-- 
1.7.9.5


From d6b848e9cb270bc223027d16bfe0e2a127c4468f Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 22:19:02 -0400
Subject: [PATCH 65/75] -reverted filemap back.

---
 mm/filemap.c | 1390 +++++++++++++++++++++++++++++-----------------------------
 1 file changed, 695 insertions(+), 695 deletions(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index 08e7bab..23acefe 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -1,14 +1,14 @@
-	/*
-	 *	linux/mm/filemap.c
-	 *
-	 * Copyright (C) 1994-1999  Linus Torvalds
-	 */
+/*
+ *	linux/mm/filemap.c
+ *
+ * Copyright (C) 1994-1999  Linus Torvalds
+ */
 
-	/*
-	 * This file handles the generic file mmap semantics used by
-	 * most "normal" filesystems (but you don't /have/ to use this:
-	 * the NFS filesystem used to do this differently, for example)
-	 */
+/*
+ * This file handles the generic file mmap semantics used by
+ * most "normal" filesystems (but you don't /have/ to use this:
+ * the NFS filesystem used to do this differently, for example)
+ */
 #include <linux/module.h>
 #include <linux/slab.h>
 #include <linux/compiler.h>
@@ -36,775 +36,775 @@
 #include <linux/mm_inline.h> /* for page_is_file_cache() */
 #include "internal.h"
 
-	/*
-	 * FIXME: remove all knowledge of the buffer layer from the core VM
-	 */
+/*
+ * FIXME: remove all knowledge of the buffer layer from the core VM
+ */
 #include <linux/buffer_head.h> /* for generic_osync_inode */
 
 #include <asm/mman.h>
 
 
-	/*
-	 * Shared mappings implemented 30.11.1994. It's not fully working yet,
-	 * though.
-	 *
-	 * Shared mappings now work. 15.8.1995  Bruno.
-	 *
-	 * finished 'unifying' the page and buffer cache and SMP-threaded the
-	 * page-cache, 21.05.1999, Ingo Molnar <mingo@redhat.com>
-	 *
-	 * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli <andrea@suse.de>
-	 */
+/*
+ * Shared mappings implemented 30.11.1994. It's not fully working yet,
+ * though.
+ *
+ * Shared mappings now work. 15.8.1995  Bruno.
+ *
+ * finished 'unifying' the page and buffer cache and SMP-threaded the
+ * page-cache, 21.05.1999, Ingo Molnar <mingo@redhat.com>
+ *
+ * SMP-threaded pagemap-LRU 1999, Andrea Arcangeli <andrea@suse.de>
+ */
+
+/*
+ * Lock ordering:
+ *
+ *  ->i_mmap_lock		(vmtruncate)
+ *    ->private_lock		(__free_pte->__set_page_dirty_buffers)
+ *      ->swap_lock		(exclusive_swap_page, others)
+ *        ->mapping->tree_lock
+ *
+ *  ->i_mutex
+ *    ->i_mmap_lock		(truncate->unmap_mapping_range)
+ *
+ *  ->mmap_sem
+ *    ->i_mmap_lock
+ *      ->page_table_lock or pte_lock	(various, mainly in memory.c)
+ *        ->mapping->tree_lock	(arch-dependent flush_dcache_mmap_lock)
+ *
+ *  ->mmap_sem
+ *    ->lock_page		(access_process_vm)
+ *
+ *  ->i_mutex			(generic_file_buffered_write)
+ *    ->mmap_sem		(fault_in_pages_readable->do_page_fault)
+ *
+ *  ->i_mutex
+ *    ->i_alloc_sem             (various)
+ *
+ *  ->inode_lock
+ *    ->sb_lock			(fs/fs-writeback.c)
+ *    ->mapping->tree_lock	(__sync_single_inode)
+ *
+ *  ->i_mmap_lock
+ *    ->anon_vma.lock		(vma_adjust)
+ *
+ *  ->anon_vma.lock
+ *    ->page_table_lock or pte_lock	(anon_vma_prepare and various)
+ *
+ *  ->page_table_lock or pte_lock
+ *    ->swap_lock		(try_to_unmap_one)
+ *    ->private_lock		(try_to_unmap_one)
+ *    ->tree_lock		(try_to_unmap_one)
+ *    ->zone.lru_lock		(follow_page->mark_page_accessed)
+ *    ->zone.lru_lock		(check_pte_range->isolate_lru_page)
+ *    ->private_lock		(page_remove_rmap->set_page_dirty)
+ *    ->tree_lock		(page_remove_rmap->set_page_dirty)
+ *    ->inode_lock		(page_remove_rmap->set_page_dirty)
+ *    ->inode_lock		(zap_pte_range->set_page_dirty)
+ *    ->private_lock		(zap_pte_range->__set_page_dirty_buffers)
+ *
+ *  ->task->proc_lock
+ *    ->dcache_lock		(proc_pid_lookup)
+ */
+
+/*
+ * Remove a page from the page cache and free it. Caller has to make
+ * sure the page is locked and that nobody else uses it - or that usage
+ * is safe.  The caller must hold the mapping's tree_lock.
+ */
+void __remove_from_page_cache(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	radix_tree_delete(&mapping->page_tree, page->index);
+	page->mapping = NULL;
+	mapping->nrpages--;
+	__dec_zone_page_state(page, NR_FILE_PAGES);
+	BUG_ON(page_mapped(page));
+	mem_cgroup_uncharge_cache_page(page);
 
 	/*
-	 * Lock ordering:
-	 *
-	 *  ->i_mmap_lock		(vmtruncate)
-	 *    ->private_lock		(__free_pte->__set_page_dirty_buffers)
-	 *      ->swap_lock		(exclusive_swap_page, others)
-	 *        ->mapping->tree_lock
-	 *
-	 *  ->i_mutex
-	 *    ->i_mmap_lock		(truncate->unmap_mapping_range)
-	 *
-	 *  ->mmap_sem
-	 *    ->i_mmap_lock
-	 *      ->page_table_lock or pte_lock	(various, mainly in memory.c)
-	 *        ->mapping->tree_lock	(arch-dependent flush_dcache_mmap_lock)
-	 *
-	 *  ->mmap_sem
-	 *    ->lock_page		(access_process_vm)
-	 *
-	 *  ->i_mutex			(generic_file_buffered_write)
-	 *    ->mmap_sem		(fault_in_pages_readable->do_page_fault)
-	 *
-	 *  ->i_mutex
-	 *    ->i_alloc_sem             (various)
-	 *
-	 *  ->inode_lock
-	 *    ->sb_lock			(fs/fs-writeback.c)
-	 *    ->mapping->tree_lock	(__sync_single_inode)
-	 *
-	 *  ->i_mmap_lock
-	 *    ->anon_vma.lock		(vma_adjust)
+	 * Some filesystems seem to re-dirty the page even after
+	 * the VM has canceled the dirty bit (eg ext3 journaling).
 	 *
-	 *  ->anon_vma.lock
-	 *    ->page_table_lock or pte_lock	(anon_vma_prepare and various)
-	 *
-	 *  ->page_table_lock or pte_lock
-	 *    ->swap_lock		(try_to_unmap_one)
-	 *    ->private_lock		(try_to_unmap_one)
-	 *    ->tree_lock		(try_to_unmap_one)
-	 *    ->zone.lru_lock		(follow_page->mark_page_accessed)
-	 *    ->zone.lru_lock		(check_pte_range->isolate_lru_page)
-	 *    ->private_lock		(page_remove_rmap->set_page_dirty)
-	 *    ->tree_lock		(page_remove_rmap->set_page_dirty)
-	 *    ->inode_lock		(page_remove_rmap->set_page_dirty)
-	 *    ->inode_lock		(zap_pte_range->set_page_dirty)
-	 *    ->private_lock		(zap_pte_range->__set_page_dirty_buffers)
-	 *
-	 *  ->task->proc_lock
-	 *    ->dcache_lock		(proc_pid_lookup)
+	 * Fix it up by doing a final dirty accounting check after
+	 * having removed the page entirely.
 	 */
+	if (PageDirty(page) && mapping_cap_account_dirty(mapping)) {
+		dec_zone_page_state(page, NR_FILE_DIRTY);
+		dec_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
+	}
+}
+
+void remove_from_page_cache(struct page *page)
+{
+	struct address_space *mapping = page->mapping;
+
+	BUG_ON(!PageLocked(page));
+
+	spin_lock_irq(&mapping->tree_lock);
+	__remove_from_page_cache(page);
+	spin_unlock_irq(&mapping->tree_lock);
+}
+
+static int sync_page(void *word)
+{
+	struct address_space *mapping;
+	struct page *page;
+
+	page = container_of((unsigned long *)word, struct page, flags);
 
 	/*
-	 * Remove a page from the page cache and free it. Caller has to make
-	 * sure the page is locked and that nobody else uses it - or that usage
-	 * is safe.  The caller must hold the mapping's tree_lock.
+	 * page_mapping() is being called without PG_locked held.
+	 * Some knowledge of the state and use of the page is used to
+	 * reduce the requirements down to a memory barrier.
+	 * The danger here is of a stale page_mapping() return value
+	 * indicating a struct address_space different from the one it's
+	 * associated with when it is associated with one.
+	 * After smp_mb(), it's either the correct page_mapping() for
+	 * the page, or an old page_mapping() and the page's own
+	 * page_mapping() has gone NULL.
+	 * The ->sync_page() address_space operation must tolerate
+	 * page_mapping() going NULL. By an amazing coincidence,
+	 * this comes about because none of the users of the page
+	 * in the ->sync_page() methods make essential use of the
+	 * page_mapping(), merely passing the page down to the backing
+	 * device's unplug functions when it's non-NULL, which in turn
+	 * ignore it for all cases but swap, where only page_private(page) is
+	 * of interest. When page_mapping() does go NULL, the entire
+	 * call stack gracefully ignores the page and returns.
+	 * -- wli
 	 */
-	void __remove_from_page_cache(struct page *page)
-	{
-		struct address_space *mapping = page->mapping;
-
-		radix_tree_delete(&mapping->page_tree, page->index);
-		page->mapping = NULL;
-		mapping->nrpages--;
-		__dec_zone_page_state(page, NR_FILE_PAGES);
-		BUG_ON(page_mapped(page));
-		mem_cgroup_uncharge_cache_page(page);
+	smp_mb();
+	mapping = page_mapping(page);
+	if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
+		mapping->a_ops->sync_page(page);
+	io_schedule();
+	return 0;
+}
 
-		/*
-		 * Some filesystems seem to re-dirty the page even after
-		 * the VM has canceled the dirty bit (eg ext3 journaling).
-		 *
-		 * Fix it up by doing a final dirty accounting check after
-		 * having removed the page entirely.
-		 */
-		if (PageDirty(page) && mapping_cap_account_dirty(mapping)) {
-			dec_zone_page_state(page, NR_FILE_DIRTY);
-			dec_bdi_stat(mapping->backing_dev_info, BDI_RECLAIMABLE);
-		}
-	}
+static int sync_page_killable(void *word)
+{
+	sync_page(word);
+	return fatal_signal_pending(current) ? -EINTR : 0;
+}
 
-	void remove_from_page_cache(struct page *page)
-	{
-		struct address_space *mapping = page->mapping;
+/**
+ * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
+ * @mapping:	address space structure to write
+ * @start:	offset in bytes where the range starts
+ * @end:	offset in bytes where the range ends (inclusive)
+ * @sync_mode:	enable synchronous operation
+ *
+ * Start writeback against all of a mapping's dirty pages that lie
+ * within the byte offsets <start, end> inclusive.
+ *
+ * If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
+ * opposed to a regular memory cleansing writeback.  The difference between
+ * these two operations is that if a dirty page/buffer is encountered, it must
+ * be waited upon, and not just skipped over.
+ */
+int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
+				loff_t end, int sync_mode)
+{
+	int ret;
+	struct writeback_control wbc = {
+		.sync_mode = sync_mode,
+		.nr_to_write = LONG_MAX,
+		.range_start = start,
+		.range_end = end,
+	};
+
+	if (!mapping_cap_writeback_dirty(mapping))
+		return 0;
 
-		BUG_ON(!PageLocked(page));
+	ret = do_writepages(mapping, &wbc);
+	return ret;
+}
 
-		spin_lock_irq(&mapping->tree_lock);
-		__remove_from_page_cache(page);
-		spin_unlock_irq(&mapping->tree_lock);
-	}
+static inline int __filemap_fdatawrite(struct address_space *mapping,
+	int sync_mode)
+{
+	return __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);
+}
 
-	static int sync_page(void *word)
-	{
-		struct address_space *mapping;
-		struct page *page;
+int filemap_fdatawrite(struct address_space *mapping)
+{
+	return __filemap_fdatawrite(mapping, WB_SYNC_ALL);
+}
+EXPORT_SYMBOL(filemap_fdatawrite);
 
-		page = container_of((unsigned long *)word, struct page, flags);
+int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
+				loff_t end)
+{
+	return __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);
+}
+EXPORT_SYMBOL(filemap_fdatawrite_range);
 
-		/*
-		 * page_mapping() is being called without PG_locked held.
-		 * Some knowledge of the state and use of the page is used to
-		 * reduce the requirements down to a memory barrier.
-		 * The danger here is of a stale page_mapping() return value
-		 * indicating a struct address_space different from the one it's
-		 * associated with when it is associated with one.
-		 * After smp_mb(), it's either the correct page_mapping() for
-		 * the page, or an old page_mapping() and the page's own
-		 * page_mapping() has gone NULL.
-		 * The ->sync_page() address_space operation must tolerate
-		 * page_mapping() going NULL. By an amazing coincidence,
-		 * this comes about because none of the users of the page
-		 * in the ->sync_page() methods make essential use of the
-		 * page_mapping(), merely passing the page down to the backing
-		 * device's unplug functions when it's non-NULL, which in turn
-		 * ignore it for all cases but swap, where only page_private(page) is
-		 * of interest. When page_mapping() does go NULL, the entire
-		 * call stack gracefully ignores the page and returns.
-		 * -- wli
-		 */
-		smp_mb();
-		mapping = page_mapping(page);
-		if (mapping && mapping->a_ops && mapping->a_ops->sync_page)
-			mapping->a_ops->sync_page(page);
-		io_schedule();
+/**
+ * filemap_flush - mostly a non-blocking flush
+ * @mapping:	target address_space
+ *
+ * This is a mostly non-blocking flush.  Not suitable for data-integrity
+ * purposes - I/O may not be started against all dirty pages.
+ */
+int filemap_flush(struct address_space *mapping)
+{
+	return __filemap_fdatawrite(mapping, WB_SYNC_NONE);
+}
+EXPORT_SYMBOL(filemap_flush);
+
+/**
+ * wait_on_page_writeback_range - wait for writeback to complete
+ * @mapping:	target address_space
+ * @start:	beginning page index
+ * @end:	ending page index
+ *
+ * Wait for writeback to complete against pages indexed by start->end
+ * inclusive
+ */
+int wait_on_page_writeback_range(struct address_space *mapping,
+				pgoff_t start, pgoff_t end)
+{
+	struct pagevec pvec;
+	int nr_pages;
+	int ret = 0;
+	pgoff_t index;
+
+	if (end < start)
 		return 0;
-	}
 
-	static int sync_page_killable(void *word)
-	{
-		sync_page(word);
-		return fatal_signal_pending(current) ? -EINTR : 0;
-	}
+	pagevec_init(&pvec, 0);
+	index = start;
+	while ((index <= end) &&
+			(nr_pages = pagevec_lookup_tag(&pvec, mapping, &index,
+			PAGECACHE_TAG_WRITEBACK,
+			min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1)) != 0) {
+		unsigned i;
 
-	/**
-	 * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
-	 * @mapping:	address space structure to write
-	 * @start:	offset in bytes where the range starts
-	 * @end:	offset in bytes where the range ends (inclusive)
-	 * @sync_mode:	enable synchronous operation
-	 *
-	 * Start writeback against all of a mapping's dirty pages that lie
-	 * within the byte offsets <start, end> inclusive.
-	 *
-	 * If sync_mode is WB_SYNC_ALL then this is a "data integrity" operation, as
-	 * opposed to a regular memory cleansing writeback.  The difference between
-	 * these two operations is that if a dirty page/buffer is encountered, it must
-	 * be waited upon, and not just skipped over.
-	 */
-	int __filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
-					loff_t end, int sync_mode)
-	{
-		int ret;
-		struct writeback_control wbc = {
-			.sync_mode = sync_mode,
-			.nr_to_write = LONG_MAX,
-			.range_start = start,
-			.range_end = end,
-		};
-
-		if (!mapping_cap_writeback_dirty(mapping))
-			return 0;
-
-		ret = do_writepages(mapping, &wbc);
-		return ret;
-	}
+		for (i = 0; i < nr_pages; i++) {
+			struct page *page = pvec.pages[i];
 
-	static inline int __filemap_fdatawrite(struct address_space *mapping,
-		int sync_mode)
-	{
-		return __filemap_fdatawrite_range(mapping, 0, LLONG_MAX, sync_mode);
-	}
+			/* until radix tree lookup accepts end_index */
+			if (page->index > end)
+				continue;
 
-	int filemap_fdatawrite(struct address_space *mapping)
-	{
-		return __filemap_fdatawrite(mapping, WB_SYNC_ALL);
+			wait_on_page_writeback(page);
+			if (PageError(page))
+				ret = -EIO;
+		}
+		pagevec_release(&pvec);
+		cond_resched();
 	}
-	EXPORT_SYMBOL(filemap_fdatawrite);
 
-	int filemap_fdatawrite_range(struct address_space *mapping, loff_t start,
-					loff_t end)
-	{
-		return __filemap_fdatawrite_range(mapping, start, end, WB_SYNC_ALL);
-	}
-	EXPORT_SYMBOL(filemap_fdatawrite_range);
+	/* Check for outstanding write errors */
+	if (test_and_clear_bit(AS_ENOSPC, &mapping->flags))
+		ret = -ENOSPC;
+	if (test_and_clear_bit(AS_EIO, &mapping->flags))
+		ret = -EIO;
 
-	/**
-	 * filemap_flush - mostly a non-blocking flush
-	 * @mapping:	target address_space
-	 *
-	 * This is a mostly non-blocking flush.  Not suitable for data-integrity
-	 * purposes - I/O may not be started against all dirty pages.
-	 */
-	int filemap_flush(struct address_space *mapping)
-	{
-		return __filemap_fdatawrite(mapping, WB_SYNC_NONE);
-	}
-	EXPORT_SYMBOL(filemap_flush);
+	return ret;
+}
 
-	/**
-	 * wait_on_page_writeback_range - wait for writeback to complete
-	 * @mapping:	target address_space
-	 * @start:	beginning page index
-	 * @end:	ending page index
-	 *
-	 * Wait for writeback to complete against pages indexed by start->end
-	 * inclusive
-	 */
-	int wait_on_page_writeback_range(struct address_space *mapping,
-					pgoff_t start, pgoff_t end)
-	{
-		struct pagevec pvec;
-		int nr_pages;
-		int ret = 0;
-		pgoff_t index;
-
-		if (end < start)
-			return 0;
-
-		pagevec_init(&pvec, 0);
-		index = start;
-		while ((index <= end) &&
-				(nr_pages = pagevec_lookup_tag(&pvec, mapping, &index,
-				PAGECACHE_TAG_WRITEBACK,
-				min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1)) != 0) {
-			unsigned i;
-
-			for (i = 0; i < nr_pages; i++) {
-				struct page *page = pvec.pages[i];
-
-				/* until radix tree lookup accepts end_index */
-				if (page->index > end)
-					continue;
-
-				wait_on_page_writeback(page);
-				if (PageError(page))
-					ret = -EIO;
-			}
-			pagevec_release(&pvec);
-			cond_resched();
-		}
+/**
+ * sync_page_range - write and wait on all pages in the passed range
+ * @inode:	target inode
+ * @mapping:	target address_space
+ * @pos:	beginning offset in pages to write
+ * @count:	number of bytes to write
+ *
+ * Write and wait upon all the pages in the passed range.  This is a "data
+ * integrity" operation.  It waits upon in-flight writeout before starting and
+ * waiting upon new writeout.  If there was an IO error, return it.
+ *
+ * We need to re-take i_mutex during the generic_osync_inode list walk because
+ * it is otherwise livelockable.
+ */
+int sync_page_range(struct inode *inode, struct address_space *mapping,
+			loff_t pos, loff_t count)
+{
+	pgoff_t start = pos >> PAGE_CACHE_SHIFT;
+	pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
+	int ret;
 
-		/* Check for outstanding write errors */
-		if (test_and_clear_bit(AS_ENOSPC, &mapping->flags))
-			ret = -ENOSPC;
-		if (test_and_clear_bit(AS_EIO, &mapping->flags))
-			ret = -EIO;
+	if (!mapping_cap_writeback_dirty(mapping) || !count)
+		return 0;
+	ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
+	if (ret == 0) {
+		mutex_lock(&inode->i_mutex);
+		ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
+		mutex_unlock(&inode->i_mutex);
+	}
+	if (ret == 0)
+		ret = wait_on_page_writeback_range(mapping, start, end);
+	return ret;
+}
+EXPORT_SYMBOL(sync_page_range);
 
-		return ret;
-	}
+/**
+ * sync_page_range_nolock - write & wait on all pages in the passed range without locking
+ * @inode:	target inode
+ * @mapping:	target address_space
+ * @pos:	beginning offset in pages to write
+ * @count:	number of bytes to write
+ *
+ * Note: Holding i_mutex across sync_page_range_nolock() is not a good idea
+ * as it forces O_SYNC writers to different parts of the same file
+ * to be serialised right until io completion.
+ */
+int sync_page_range_nolock(struct inode *inode, struct address_space *mapping,
+			   loff_t pos, loff_t count)
+{
+	pgoff_t start = pos >> PAGE_CACHE_SHIFT;
+	pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
+	int ret;
 
-	/**
-	 * sync_page_range - write and wait on all pages in the passed range
-	 * @inode:	target inode
-	 * @mapping:	target address_space
-	 * @pos:	beginning offset in pages to write
-	 * @count:	number of bytes to write
-	 *
-	 * Write and wait upon all the pages in the passed range.  This is a "data
-	 * integrity" operation.  It waits upon in-flight writeout before starting and
-	 * waiting upon new writeout.  If there was an IO error, return it.
-	 *
-	 * We need to re-take i_mutex during the generic_osync_inode list walk because
-	 * it is otherwise livelockable.
-	 */
-	int sync_page_range(struct inode *inode, struct address_space *mapping,
-				loff_t pos, loff_t count)
-	{
-		pgoff_t start = pos >> PAGE_CACHE_SHIFT;
-		pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
-		int ret;
-
-		if (!mapping_cap_writeback_dirty(mapping) || !count)
-			return 0;
-		ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
-		if (ret == 0) {
-			mutex_lock(&inode->i_mutex);
-			ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
-			mutex_unlock(&inode->i_mutex);
-		}
-		if (ret == 0)
-			ret = wait_on_page_writeback_range(mapping, start, end);
-		return ret;
-	}
-	EXPORT_SYMBOL(sync_page_range);
-
-	/**
-	 * sync_page_range_nolock - write & wait on all pages in the passed range without locking
-	 * @inode:	target inode
-	 * @mapping:	target address_space
-	 * @pos:	beginning offset in pages to write
-	 * @count:	number of bytes to write
-	 *
-	 * Note: Holding i_mutex across sync_page_range_nolock() is not a good idea
-	 * as it forces O_SYNC writers to different parts of the same file
-	 * to be serialised right until io completion.
-	 */
-	int sync_page_range_nolock(struct inode *inode, struct address_space *mapping,
-				   loff_t pos, loff_t count)
-	{
-		pgoff_t start = pos >> PAGE_CACHE_SHIFT;
-		pgoff_t end = (pos + count - 1) >> PAGE_CACHE_SHIFT;
-		int ret;
-
-		if (!mapping_cap_writeback_dirty(mapping) || !count)
-			return 0;
-		ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
-		if (ret == 0)
-			ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
-		if (ret == 0)
-			ret = wait_on_page_writeback_range(mapping, start, end);
-		return ret;
-	}
-	EXPORT_SYMBOL(sync_page_range_nolock);
+	if (!mapping_cap_writeback_dirty(mapping) || !count)
+		return 0;
+	ret = filemap_fdatawrite_range(mapping, pos, pos + count - 1);
+	if (ret == 0)
+		ret = generic_osync_inode(inode, mapping, OSYNC_METADATA);
+	if (ret == 0)
+		ret = wait_on_page_writeback_range(mapping, start, end);
+	return ret;
+}
+EXPORT_SYMBOL(sync_page_range_nolock);
 
-	/**
-	 * filemap_fdatawait - wait for all under-writeback pages to complete
-	 * @mapping: address space structure to wait for
-	 *
-	 * Walk the list of under-writeback pages of the given address space
-	 * and wait for all of them.
-	 */
-	int filemap_fdatawait(struct address_space *mapping)
-	{
-		loff_t i_size = i_size_read(mapping->host);
+/**
+ * filemap_fdatawait - wait for all under-writeback pages to complete
+ * @mapping: address space structure to wait for
+ *
+ * Walk the list of under-writeback pages of the given address space
+ * and wait for all of them.
+ */
+int filemap_fdatawait(struct address_space *mapping)
+{
+	loff_t i_size = i_size_read(mapping->host);
 
-		if (i_size == 0)
-			return 0;
+	if (i_size == 0)
+		return 0;
 
-		return wait_on_page_writeback_range(mapping, 0,
-					(i_size - 1) >> PAGE_CACHE_SHIFT);
-	}
-	EXPORT_SYMBOL(filemap_fdatawait);
+	return wait_on_page_writeback_range(mapping, 0,
+				(i_size - 1) >> PAGE_CACHE_SHIFT);
+}
+EXPORT_SYMBOL(filemap_fdatawait);
 
-	int filemap_write_and_wait(struct address_space *mapping)
-	{
-		int err = 0;
+int filemap_write_and_wait(struct address_space *mapping)
+{
+	int err = 0;
 
-		if (mapping->nrpages) {
-			err = filemap_fdatawrite(mapping);
-			/*
-			 * Even if the above returned error, the pages may be
-			 * written partially (e.g. -ENOSPC), so we wait for it.
-			 * But the -EIO is special case, it may indicate the worst
-			 * thing (e.g. bug) happened, so we avoid waiting for it.
-			 */
-			if (err != -EIO) {
-				int err2 = filemap_fdatawait(mapping);
-				if (!err)
-					err = err2;
-			}
+	if (mapping->nrpages) {
+		err = filemap_fdatawrite(mapping);
+		/*
+		 * Even if the above returned error, the pages may be
+		 * written partially (e.g. -ENOSPC), so we wait for it.
+		 * But the -EIO is special case, it may indicate the worst
+		 * thing (e.g. bug) happened, so we avoid waiting for it.
+		 */
+		if (err != -EIO) {
+			int err2 = filemap_fdatawait(mapping);
+			if (!err)
+				err = err2;
 		}
-		return err;
 	}
-	EXPORT_SYMBOL(filemap_write_and_wait);
+	return err;
+}
+EXPORT_SYMBOL(filemap_write_and_wait);
 
-	/**
-	 * filemap_write_and_wait_range - write out & wait on a file range
-	 * @mapping:	the address_space for the pages
-	 * @lstart:	offset in bytes where the range starts
-	 * @lend:	offset in bytes where the range ends (inclusive)
-	 *
-	 * Write out and wait upon file offsets lstart->lend, inclusive.
-	 *
-	 * Note that `lend' is inclusive (describes the last byte to be written) so
-	 * that this function can be used to write to the very end-of-file (end = -1).
-	 */
-	int filemap_write_and_wait_range(struct address_space *mapping,
-					 loff_t lstart, loff_t lend)
-	{
-		int err = 0;
-
-		if (mapping->nrpages) {
-			err = __filemap_fdatawrite_range(mapping, lstart, lend,
-							 WB_SYNC_ALL);
-			/* See comment of filemap_write_and_wait() */
-			if (err != -EIO) {
-				int err2 = wait_on_page_writeback_range(mapping,
-							lstart >> PAGE_CACHE_SHIFT,
-							lend >> PAGE_CACHE_SHIFT);
-				if (!err)
-					err = err2;
-			}
+/**
+ * filemap_write_and_wait_range - write out & wait on a file range
+ * @mapping:	the address_space for the pages
+ * @lstart:	offset in bytes where the range starts
+ * @lend:	offset in bytes where the range ends (inclusive)
+ *
+ * Write out and wait upon file offsets lstart->lend, inclusive.
+ *
+ * Note that `lend' is inclusive (describes the last byte to be written) so
+ * that this function can be used to write to the very end-of-file (end = -1).
+ */
+int filemap_write_and_wait_range(struct address_space *mapping,
+				 loff_t lstart, loff_t lend)
+{
+	int err = 0;
+
+	if (mapping->nrpages) {
+		err = __filemap_fdatawrite_range(mapping, lstart, lend,
+						 WB_SYNC_ALL);
+		/* See comment of filemap_write_and_wait() */
+		if (err != -EIO) {
+			int err2 = wait_on_page_writeback_range(mapping,
+						lstart >> PAGE_CACHE_SHIFT,
+						lend >> PAGE_CACHE_SHIFT);
+			if (!err)
+				err = err2;
 		}
-		return err;
 	}
+	return err;
+}
 
-	/**
-	 * add_to_page_cache_locked - add a locked page to the pagecache
-	 * @page:	page to add
-	 * @mapping:	the page's address_space
-	 * @offset:	page index
-	 * @gfp_mask:	page allocation mode
-	 *
-	 * This function is used to add a page to the pagecache. It must be locked.
-	 * This function does not add the page to the LRU.  The caller must do that.
-	 */
-	int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
-			pgoff_t offset, gfp_t gfp_mask)
-	{
-		int error;
+/**
+ * add_to_page_cache_locked - add a locked page to the pagecache
+ * @page:	page to add
+ * @mapping:	the page's address_space
+ * @offset:	page index
+ * @gfp_mask:	page allocation mode
+ *
+ * This function is used to add a page to the pagecache. It must be locked.
+ * This function does not add the page to the LRU.  The caller must do that.
+ */
+int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
+		pgoff_t offset, gfp_t gfp_mask)
+{
+	int error;
 
-		VM_BUG_ON(!PageLocked(page));
+	VM_BUG_ON(!PageLocked(page));
 
-		error = mem_cgroup_cache_charge(page, current->mm,
-						gfp_mask & GFP_RECLAIM_MASK);
-		if (error)
-			goto out;
+	error = mem_cgroup_cache_charge(page, current->mm,
+					gfp_mask & GFP_RECLAIM_MASK);
+	if (error)
+		goto out;
 
-		error = radix_tree_preload(gfp_mask & ~__GFP_HIGHMEM);
-		if (error == 0) {
-			page_cache_get(page);
-			page->mapping = mapping;
-			page->index = offset;
-
-			spin_lock_irq(&mapping->tree_lock);
-			error = radix_tree_insert(&mapping->page_tree, offset, page);
-			if (likely(!error)) {
-				mapping->nrpages++;
-				__inc_zone_page_state(page, NR_FILE_PAGES);
-			} else {
-				page->mapping = NULL;
-				mem_cgroup_uncharge_cache_page(page);
-				page_cache_release(page);
-			}
+	error = radix_tree_preload(gfp_mask & ~__GFP_HIGHMEM);
+	if (error == 0) {
+		page_cache_get(page);
+		page->mapping = mapping;
+		page->index = offset;
 
-			spin_unlock_irq(&mapping->tree_lock);
-			radix_tree_preload_end();
-		} else
+		spin_lock_irq(&mapping->tree_lock);
+		error = radix_tree_insert(&mapping->page_tree, offset, page);
+		if (likely(!error)) {
+			mapping->nrpages++;
+			__inc_zone_page_state(page, NR_FILE_PAGES);
+		} else {
+			page->mapping = NULL;
 			mem_cgroup_uncharge_cache_page(page);
-	out:
-		return error;
-	}
-	EXPORT_SYMBOL(add_to_page_cache_locked);
+			page_cache_release(page);
+		}
 
-	int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
-					pgoff_t offset, gfp_t gfp_mask)
-	{
-		int ret;
+		spin_unlock_irq(&mapping->tree_lock);
+		radix_tree_preload_end();
+	} else
+		mem_cgroup_uncharge_cache_page(page);
+out:
+	return error;
+}
+EXPORT_SYMBOL(add_to_page_cache_locked);
 
-		/*
-		 * Splice_read and readahead add shmem/tmpfs pages into the page cache
-		 * before shmem_readpage has a chance to mark them as SwapBacked: they
-		 * need to go on the active_anon lru below, and mem_cgroup_cache_charge
-		 * (called in add_to_page_cache) needs to know where they're going too.
-		 */
-		if (mapping_cap_swap_backed(mapping))
-			SetPageSwapBacked(page);
-
-		ret = add_to_page_cache(page, mapping, offset, gfp_mask);
-		if (ret == 0) {
-			if (page_is_file_cache(page))
-				lru_cache_add_file(page);
-			else
-				lru_cache_add_active_anon(page);
-		}
-		return ret;
+int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
+				pgoff_t offset, gfp_t gfp_mask)
+{
+	int ret;
+
+	/*
+	 * Splice_read and readahead add shmem/tmpfs pages into the page cache
+	 * before shmem_readpage has a chance to mark them as SwapBacked: they
+	 * need to go on the active_anon lru below, and mem_cgroup_cache_charge
+	 * (called in add_to_page_cache) needs to know where they're going too.
+	 */
+	if (mapping_cap_swap_backed(mapping))
+		SetPageSwapBacked(page);
+
+	ret = add_to_page_cache(page, mapping, offset, gfp_mask);
+	if (ret == 0) {
+		if (page_is_file_cache(page))
+			lru_cache_add_file(page);
+		else
+			lru_cache_add_active_anon(page);
 	}
+	return ret;
+}
 
 #ifdef CONFIG_NUMA
-	struct page *__page_cache_alloc(gfp_t gfp)
-	{
-		if (cpuset_do_page_mem_spread()) {
-			int n = cpuset_mem_spread_node();
-			return alloc_pages_node(n, gfp, 0);
-		}
-		return alloc_pages(gfp, 0);
+struct page *__page_cache_alloc(gfp_t gfp)
+{
+	if (cpuset_do_page_mem_spread()) {
+		int n = cpuset_mem_spread_node();
+		return alloc_pages_node(n, gfp, 0);
 	}
-	EXPORT_SYMBOL(__page_cache_alloc);
+	return alloc_pages(gfp, 0);
+}
+EXPORT_SYMBOL(__page_cache_alloc);
 #endif
 
-	static int __sleep_on_page_lock(void *word)
-	{
-		io_schedule();
-		return 0;
-	}
+static int __sleep_on_page_lock(void *word)
+{
+	io_schedule();
+	return 0;
+}
 
-	/*
-	 * In order to wait for pages to become available there must be
-	 * waitqueues associated with pages. By using a hash table of
-	 * waitqueues where the bucket discipline is to maintain all
-	 * waiters on the same queue and wake all when any of the pages
-	 * become available, and for the woken contexts to check to be
-	 * sure the appropriate page became available, this saves space
-	 * at a cost of "thundering herd" phenomena during rare hash
-	 * collisions.
-	 */
-	static wait_queue_head_t *page_waitqueue(struct page *page)
-	{
-		const struct zone *zone = page_zone(page);
+/*
+ * In order to wait for pages to become available there must be
+ * waitqueues associated with pages. By using a hash table of
+ * waitqueues where the bucket discipline is to maintain all
+ * waiters on the same queue and wake all when any of the pages
+ * become available, and for the woken contexts to check to be
+ * sure the appropriate page became available, this saves space
+ * at a cost of "thundering herd" phenomena during rare hash
+ * collisions.
+ */
+static wait_queue_head_t *page_waitqueue(struct page *page)
+{
+	const struct zone *zone = page_zone(page);
 
-		return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
-	}
+	return &zone->wait_table[hash_ptr(page, zone->wait_table_bits)];
+}
 
-	static inline void wake_up_page(struct page *page, int bit)
-	{
-		__wake_up_bit(page_waitqueue(page), &page->flags, bit);
-	}
+static inline void wake_up_page(struct page *page, int bit)
+{
+	__wake_up_bit(page_waitqueue(page), &page->flags, bit);
+}
 
-	void wait_on_page_bit(struct page *page, int bit_nr)
-	{
-		DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
+void wait_on_page_bit(struct page *page, int bit_nr)
+{
+	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
 
-		if (test_bit(bit_nr, &page->flags))
-			__wait_on_bit(page_waitqueue(page), &wait, sync_page,
-								TASK_UNINTERRUPTIBLE);
-	}
-	EXPORT_SYMBOL(wait_on_page_bit);
+	if (test_bit(bit_nr, &page->flags))
+		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
+							TASK_UNINTERRUPTIBLE);
+}
+EXPORT_SYMBOL(wait_on_page_bit);
 
-	/**
-	 * unlock_page - unlock a locked page
-	 * @page: the page
-	 *
-	 * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().
-	 * Also wakes sleepers in wait_on_page_writeback() because the wakeup
-	 * mechananism between PageLocked pages and PageWriteback pages is shared.
-	 * But that's OK - sleepers in wait_on_page_writeback() just go back to sleep.
-	 *
-	 * The mb is necessary to enforce ordering between the clear_bit and the read
-	 * of the waitqueue (to avoid SMP races with a parallel wait_on_page_locked()).
-	 */
-	void unlock_page(struct page *page)
-	{
-		VM_BUG_ON(!PageLocked(page));
-		clear_bit_unlock(PG_locked, &page->flags);
-		smp_mb__after_clear_bit();
-		wake_up_page(page, PG_locked);
-	}
-	EXPORT_SYMBOL(unlock_page);
+/**
+ * unlock_page - unlock a locked page
+ * @page: the page
+ *
+ * Unlocks the page and wakes up sleepers in ___wait_on_page_locked().
+ * Also wakes sleepers in wait_on_page_writeback() because the wakeup
+ * mechananism between PageLocked pages and PageWriteback pages is shared.
+ * But that's OK - sleepers in wait_on_page_writeback() just go back to sleep.
+ *
+ * The mb is necessary to enforce ordering between the clear_bit and the read
+ * of the waitqueue (to avoid SMP races with a parallel wait_on_page_locked()).
+ */
+void unlock_page(struct page *page)
+{
+	VM_BUG_ON(!PageLocked(page));
+	clear_bit_unlock(PG_locked, &page->flags);
+	smp_mb__after_clear_bit();
+	wake_up_page(page, PG_locked);
+}
+EXPORT_SYMBOL(unlock_page);
 
-	/**
-	 * end_page_writeback - end writeback against a page
-	 * @page: the page
-	 */
-	void end_page_writeback(struct page *page)
-	{
-		if (TestClearPageReclaim(page))
-			rotate_reclaimable_page(page);
+/**
+ * end_page_writeback - end writeback against a page
+ * @page: the page
+ */
+void end_page_writeback(struct page *page)
+{
+	if (TestClearPageReclaim(page))
+		rotate_reclaimable_page(page);
 
-		if (!test_clear_page_writeback(page))
-			BUG();
+	if (!test_clear_page_writeback(page))
+		BUG();
 
-		smp_mb__after_clear_bit();
-		wake_up_page(page, PG_writeback);
-	}
-	EXPORT_SYMBOL(end_page_writeback);
+	smp_mb__after_clear_bit();
+	wake_up_page(page, PG_writeback);
+}
+EXPORT_SYMBOL(end_page_writeback);
 
-	/**
-	 * __lock_page - get a lock on the page, assuming we need to sleep to get it
-	 * @page: the page to lock
-	 *
-	 * Ugly. Running sync_page() in state TASK_UNINTERRUPTIBLE is scary.  If some
-	 * random driver's requestfn sets TASK_RUNNING, we could busywait.  However
-	 * chances are that on the second loop, the block layer's plug list is empty,
-	 * so sync_page() will then return in state TASK_UNINTERRUPTIBLE.
-	 */
-	void __lock_page(struct page *page)
-	{
-		DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
+/**
+ * __lock_page - get a lock on the page, assuming we need to sleep to get it
+ * @page: the page to lock
+ *
+ * Ugly. Running sync_page() in state TASK_UNINTERRUPTIBLE is scary.  If some
+ * random driver's requestfn sets TASK_RUNNING, we could busywait.  However
+ * chances are that on the second loop, the block layer's plug list is empty,
+ * so sync_page() will then return in state TASK_UNINTERRUPTIBLE.
+ */
+void __lock_page(struct page *page)
+{
+	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
 
-		__wait_on_bit_lock(page_waitqueue(page), &wait, sync_page,
-								TASK_UNINTERRUPTIBLE);
-	}
-	EXPORT_SYMBOL(__lock_page);
+	__wait_on_bit_lock(page_waitqueue(page), &wait, sync_page,
+							TASK_UNINTERRUPTIBLE);
+}
+EXPORT_SYMBOL(__lock_page);
 
-	int __lock_page_killable(struct page *page)
-	{
-		DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
+int __lock_page_killable(struct page *page)
+{
+	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
 
-		return __wait_on_bit_lock(page_waitqueue(page), &wait,
-						sync_page_killable, TASK_KILLABLE);
-	}
+	return __wait_on_bit_lock(page_waitqueue(page), &wait,
+					sync_page_killable, TASK_KILLABLE);
+}
 
-	/**
-	 * __lock_page_nosync - get a lock on the page, without calling sync_page()
-	 * @page: the page to lock
-	 *
-	 * Variant of lock_page that does not require the caller to hold a reference
-	 * on the page's mapping.
-	 */
-	void __lock_page_nosync(struct page *page)
-	{
-		DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
-		__wait_on_bit_lock(page_waitqueue(page), &wait, __sleep_on_page_lock,
-								TASK_UNINTERRUPTIBLE);
-	}
+/**
+ * __lock_page_nosync - get a lock on the page, without calling sync_page()
+ * @page: the page to lock
+ *
+ * Variant of lock_page that does not require the caller to hold a reference
+ * on the page's mapping.
+ */
+void __lock_page_nosync(struct page *page)
+{
+	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);
+	__wait_on_bit_lock(page_waitqueue(page), &wait, __sleep_on_page_lock,
+							TASK_UNINTERRUPTIBLE);
+}
 
-	/**
-	 * find_get_page - find and get a page reference
-	 * @mapping: the address_space to search
-	 * @offset: the page index
-	 *
-	 * Is there a pagecache struct page at the given (mapping, offset) tuple?
-	 * If yes, increment its refcount and return it; if no, return NULL.
-	 */
-	struct page *find_get_page(struct address_space *mapping, pgoff_t offset)
-	{
-		void **pagep;
-		struct page *page;
+/**
+ * find_get_page - find and get a page reference
+ * @mapping: the address_space to search
+ * @offset: the page index
+ *
+ * Is there a pagecache struct page at the given (mapping, offset) tuple?
+ * If yes, increment its refcount and return it; if no, return NULL.
+ */
+struct page *find_get_page(struct address_space *mapping, pgoff_t offset)
+{
+	void **pagep;
+	struct page *page;
 
-		rcu_read_lock();
-	repeat:
-		page = NULL;
-		pagep = radix_tree_lookup_slot(&mapping->page_tree, offset);
-		if (pagep) {
-			page = radix_tree_deref_slot(pagep);
-			if (unlikely(!page || page == RADIX_TREE_RETRY))
-				goto repeat;
+	rcu_read_lock();
+repeat:
+	page = NULL;
+	pagep = radix_tree_lookup_slot(&mapping->page_tree, offset);
+	if (pagep) {
+		page = radix_tree_deref_slot(pagep);
+		if (unlikely(!page || page == RADIX_TREE_RETRY))
+			goto repeat;
 
-			if (!page_cache_get_speculative(page))
-				goto repeat;
+		if (!page_cache_get_speculative(page))
+			goto repeat;
 
-			/*
-			 * Has the page moved?
-			 * This is part of the lockless pagecache protocol. See
-			 * include/linux/pagemap.h for details.
-			 */
-			if (unlikely(page != *pagep)) {
-				page_cache_release(page);
-				goto repeat;
-			}
+		/*
+		 * Has the page moved?
+		 * This is part of the lockless pagecache protocol. See
+		 * include/linux/pagemap.h for details.
+		 */
+		if (unlikely(page != *pagep)) {
+			page_cache_release(page);
+			goto repeat;
 		}
-		rcu_read_unlock();
-
-		return page;
 	}
-	EXPORT_SYMBOL(find_get_page);
+	rcu_read_unlock();
 
-	/**
-	 * find_lock_page - locate, pin and lock a pagecache page
-	 * @mapping: the address_space to search
-	 * @offset: the page index
-	 *
-	 * Locates the desired pagecache page, locks it, increments its reference
-	 * count and returns its address.
-	 *
-	 * Returns zero if the page was not present. find_lock_page() may sleep.
-	 */
-	struct page *find_lock_page(struct address_space *mapping, pgoff_t offset)
-	{
-		struct page *page;
+	return page;
+}
+EXPORT_SYMBOL(find_get_page);
 
-	repeat:
-		page = find_get_page(mapping, offset);
-		if (page) {
-			lock_page(page);
-			/* Has the page been truncated? */
-			if (unlikely(page->mapping != mapping)) {
-				unlock_page(page);
-				page_cache_release(page);
-				goto repeat;
-			}
-			VM_BUG_ON(page->index != offset);
+/**
+ * find_lock_page - locate, pin and lock a pagecache page
+ * @mapping: the address_space to search
+ * @offset: the page index
+ *
+ * Locates the desired pagecache page, locks it, increments its reference
+ * count and returns its address.
+ *
+ * Returns zero if the page was not present. find_lock_page() may sleep.
+ */
+struct page *find_lock_page(struct address_space *mapping, pgoff_t offset)
+{
+	struct page *page;
+
+repeat:
+	page = find_get_page(mapping, offset);
+	if (page) {
+		lock_page(page);
+		/* Has the page been truncated? */
+		if (unlikely(page->mapping != mapping)) {
+			unlock_page(page);
+			page_cache_release(page);
+			goto repeat;
 		}
-		return page;
+		VM_BUG_ON(page->index != offset);
 	}
-	EXPORT_SYMBOL(find_lock_page);
+	return page;
+}
+EXPORT_SYMBOL(find_lock_page);
 
-	/**
-	 * find_or_create_page - locate or add a pagecache page
-	 * @mapping: the page's address_space
-	 * @index: the page's index into the mapping
-	 * @gfp_mask: page allocation mode
-	 *
-	 * Locates a page in the pagecache.  If the page is not present, a new page
-	 * is allocated using @gfp_mask and is added to the pagecache and to the VM's
-	 * LRU list.  The returned page is locked and has its reference count
-	 * incremented.
-	 *
-	 * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic
-	 * allocation!
-	 *
-	 * find_or_create_page() returns the desired page's address, or zero on
-	 * memory exhaustion.
-	 */
-	struct page *find_or_create_page(struct address_space *mapping,
-			pgoff_t index, gfp_t gfp_mask)
-	{
-		struct page *page;
-		int err;
-	repeat:
-		page = find_lock_page(mapping, index);
-		if (!page) {
-			page = __page_cache_alloc(gfp_mask);
-			if (!page)
-				return NULL;
-			/*
-			 * We want a regular kernel memory (not highmem or DMA etc)
-			 * allocation for the radix tree nodes, but we need to honour
-			 * the context-specific requirements the caller has asked for.
-			 * GFP_RECLAIM_MASK collects those requirements.
-			 */
-			err = add_to_page_cache_lru(page, mapping, index,
-				(gfp_mask & GFP_RECLAIM_MASK));
-			if (unlikely(err)) {
-				page_cache_release(page);
-				page = NULL;
-				if (err == -EEXIST)
-					goto repeat;
-			}
+/**
+ * find_or_create_page - locate or add a pagecache page
+ * @mapping: the page's address_space
+ * @index: the page's index into the mapping
+ * @gfp_mask: page allocation mode
+ *
+ * Locates a page in the pagecache.  If the page is not present, a new page
+ * is allocated using @gfp_mask and is added to the pagecache and to the VM's
+ * LRU list.  The returned page is locked and has its reference count
+ * incremented.
+ *
+ * find_or_create_page() may sleep, even if @gfp_flags specifies an atomic
+ * allocation!
+ *
+ * find_or_create_page() returns the desired page's address, or zero on
+ * memory exhaustion.
+ */
+struct page *find_or_create_page(struct address_space *mapping,
+		pgoff_t index, gfp_t gfp_mask)
+{
+	struct page *page;
+	int err;
+repeat:
+	page = find_lock_page(mapping, index);
+	if (!page) {
+		page = __page_cache_alloc(gfp_mask);
+		if (!page)
+			return NULL;
+		/*
+		 * We want a regular kernel memory (not highmem or DMA etc)
+		 * allocation for the radix tree nodes, but we need to honour
+		 * the context-specific requirements the caller has asked for.
+		 * GFP_RECLAIM_MASK collects those requirements.
+		 */
+		err = add_to_page_cache_lru(page, mapping, index,
+			(gfp_mask & GFP_RECLAIM_MASK));
+		if (unlikely(err)) {
+			page_cache_release(page);
+			page = NULL;
+			if (err == -EEXIST)
+				goto repeat;
 		}
-		return page;
 	}
-	EXPORT_SYMBOL(find_or_create_page);
-
-	/**
-	 * find_get_pages - gang pagecache lookup
-	 * @mapping:	The address_space to search
-	 * @start:	The starting page index
-	 * @nr_pages:	The maximum number of pages
-	 * @pages:	Where the resulting pages are placed
-	 *
-	 * find_get_pages() will search for and return a group of up to
-	 * @nr_pages pages in the mapping.  The pages are placed at @pages.
-	 * find_get_pages() takes a reference against the returned pages.
-	 *
-	 * The search returns a group of mapping-contiguous pages with ascending
-	 * indexes.  There may be holes in the indices due to not-present pages.
-	 *
-	 * find_get_pages() returns the number of pages which were found.
-	 */
-	unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
-				    unsigned int nr_pages, struct page **pages)
-	{
-		unsigned int i;
-		unsigned int ret;
-		unsigned int nr_found;
-
-		rcu_read_lock();
-	restart:
-		nr_found = radix_tree_gang_lookup_slot(&mapping->page_tree,
-					(void ***)pages, start, nr_pages);
-		ret = 0;
-		for (i = 0; i < nr_found; i++) {
-			struct page *page;
-	repeat:
-			page = radix_tree_deref_slot((void **)pages[i]);
-			if (unlikely(!page))
-				continue;
-			/*
-			 * this can only trigger if nr_found == 1, making livelock
-			 * a non issue.
-			 */
-			if (unlikely(page == RADIX_TREE_RETRY))
-				goto restart;
+	return page;
+}
+EXPORT_SYMBOL(find_or_create_page);
 
-			if (!page_cache_get_speculative(page))
-				goto repeat;
+/**
+ * find_get_pages - gang pagecache lookup
+ * @mapping:	The address_space to search
+ * @start:	The starting page index
+ * @nr_pages:	The maximum number of pages
+ * @pages:	Where the resulting pages are placed
+ *
+ * find_get_pages() will search for and return a group of up to
+ * @nr_pages pages in the mapping.  The pages are placed at @pages.
+ * find_get_pages() takes a reference against the returned pages.
+ *
+ * The search returns a group of mapping-contiguous pages with ascending
+ * indexes.  There may be holes in the indices due to not-present pages.
+ *
+ * find_get_pages() returns the number of pages which were found.
+ */
+unsigned find_get_pages(struct address_space *mapping, pgoff_t start,
+			    unsigned int nr_pages, struct page **pages)
+{
+	unsigned int i;
+	unsigned int ret;
+	unsigned int nr_found;
 
-			/* Has the page moved? */
+	rcu_read_lock();
+restart:
+	nr_found = radix_tree_gang_lookup_slot(&mapping->page_tree,
+				(void ***)pages, start, nr_pages);
+	ret = 0;
+	for (i = 0; i < nr_found; i++) {
+		struct page *page;
+repeat:
+		page = radix_tree_deref_slot((void **)pages[i]);
+		if (unlikely(!page))
+			continue;
+		/*
+		 * this can only trigger if nr_found == 1, making livelock
+		 * a non issue.
+		 */
+		if (unlikely(page == RADIX_TREE_RETRY))
+			goto restart;
+
+		if (!page_cache_get_speculative(page))
+			goto repeat;
+
+		/* Has the page moved? */
 		if (unlikely(page != *((void **)pages[i]))) {
 			page_cache_release(page);
 			goto repeat;
-- 
1.7.9.5


From bfe1523dcc42521a954cafef5eb5dbbb74b60e2d Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 22:23:16 -0400
Subject: [PATCH 66/75] -corrected checkpatch in clfs/Makefile.

---
 clfs/Makefile |   27 +++++++++++++--------------
 1 file changed, 13 insertions(+), 14 deletions(-)

diff --git a/clfs/Makefile b/clfs/Makefile
index 4b19f72..6daeecd 100644
--- a/clfs/Makefile
+++ b/clfs/Makefile
@@ -23,43 +23,42 @@ SRVR := clfs_server
 CPP := $(BIN)/$(ANDROID_TARGET)-g++
 CC := $(BIN)/$(ANDROID_TARGET)-gcc
 CFLAGS := -I$(INCDIR)
-LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR)
 LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
- 
+
 all: $(APP) server evict
 
 server: $(SRVR).c
 	$(LOCAL_CC) $(SRVR).c $(LOCAL_FLAGS) -o $(SRVR)
- 
+
 evict: $(EVICT).c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $(EVICT).c -o $(EVICT).o
 	$(CC) $(LDFLAGS) -o $(EVICT) $(EVICT).o
-	
 
 OBJS += $(APP).o
- 
+
 $(APP): $(OBJS)
 	$(CC) $(LDFLAGS) -o $@ $^
- 
+
 %.o: %.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@
 install: $(APP) evict server
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP)
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(EVICT) $(INSTALL_DIR)/$(EVICT) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(EVICT) $(INSTALL_DIR)/$(EVICT)
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(EVICT)
- 
+
 shell:
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
- 
+
 run:
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
+
 r: $(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP)
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
+
 clean:
 	@rm -f *.o $(APP) $(SRVR) $(EVICT)
 
-- 
1.7.9.5


From 14341cc10fceb706cd203c557e66895f79740d3c Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 22:26:06 -0400
Subject: [PATCH 67/75] -removed old test makefile.

---
 clfs/Makefile_fetch_test |   51 ----------------------------------------------
 1 file changed, 51 deletions(-)
 delete mode 100644 clfs/Makefile_fetch_test

diff --git a/clfs/Makefile_fetch_test b/clfs/Makefile_fetch_test
deleted file mode 100644
index 59440ea..0000000
--- a/clfs/Makefile_fetch_test
+++ /dev/null
@@ -1,51 +0,0 @@
-APP := fetch_test
-ROOT:=$(HOME)/DATA/SOFT
-NDK_PLATFORM_VER := 14
-INSTALL_DIR := /data/tmp
-
-ANDROID_SDK_ROOT:=$(ROOT)/android-sdk-linux
-ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8d
-ANDROID_NDK_HOST:=linux-x86
-ANDROID_TARGET:=i686-linux-android
-ANDROID_TARGET_ARCH:=x86
-ANDROID_TOOLCHAIN:=x86-4.4.3
-
-BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
-LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
-INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
-BIN := $(BINDIR)/bin
- 
-CPP := $(BIN)/$(ANDROID_TARGET)-g++
-CC := $(BIN)/$(ANDROID_TARGET)-gcc
-CFLAGS := -I$(INCDIR)
-LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
-LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
- 
- 
-all: $(APP)
- 
-OBJS += $(APP).o
- 
-$(APP): $(OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^
- 
-%.o: %.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-install: $(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
- 
-shell:
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
- 
-run:
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-r: $(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-clean:
-	@rm -f $(APP).o $(APP)
-
-- 
1.7.9.5


From 86d0bccf182de889cf82fb0fa534a99c273afe2b Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Tue, 7 May 2013 22:26:41 -0400
Subject: [PATCH 68/75] added a README-GROUP16 for the group and did a little
 bit of cleanup in ext2_evict.c

---
 README-GROUP16       |   17 +++++++++++++++++
 fs/ext2/ext2_evict.c |   17 +++++------------
 2 files changed, 22 insertions(+), 12 deletions(-)
 create mode 100644 README-GROUP16

diff --git a/README-GROUP16 b/README-GROUP16
new file mode 100644
index 0000000..25bc93b
--- /dev/null
+++ b/README-GROUP16
@@ -0,0 +1,17 @@
+Victor Frenkel
+Riley Spahn
+Seshu (Venkata) Yamajala
+OS HW 5
+
+
+Documentation of Modifications
+
+clfs/clfs_server.c, clfs/clfs.h
+        - Contains the implementation of part 1, the cloud server. Supports requests in the format given in the assignment. Works as described in the assignment.
+
+fs/ext2/ext2_evict.c
+        - Here we define ext2_evict and ext2_fetch as requested by the assignment, as well as the ext2_evict_fs which implements the clock algorithm for eviction when the usage is higher than the wh watermark.
+        - A number of helper functions are here to read and write blocks from disk. Due to issues in writing out blocks that have since been resolved, Victor wrote one version of the write_blocks function that works by filling up buffers and writing them to disk, while Riley wrote another function that uses the page cache and the inode's mapping to write out pages to disk. After correctly marking items as dirty and synchronizing them to disk, we found that both of our approaches work. We chose to use Victor's write_blocks method because it doesn't give a strange warning about non-GPL licensed code (module tainted).
+
+
+
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 6abfd9d..a89bd1a 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -288,18 +288,10 @@ int write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
 	int ret_val = 0;
         //printk(KERN_DEBUG "point ALPHA TWO.\n");
 
-/*
-	curr_addr = file_data;
-	while (curr_addr < ((unsigned long) file_data) + file_size) {
-		curr_page = vmalloc_to_page(curr_addr);
-
-		ret_val = mpage_writepage(curr_page, ext2_get_block, &wbc);
-	}
-*/
 	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	while (curr_addr < end_addr) {
 		printk(KERN_DEBUG "executing write block loop.\n");
-		curr_page = vmalloc_to_page((void *)curr_addr);
+		//curr_page = vmalloc_to_page((void *)curr_addr);
 		tocopy = blocksize < ( end_addr - curr_addr) ? blocksize : (end_addr - curr_addr);
 
                 //printk(KERN_DEBUG "point ALPHA.\n");
@@ -555,6 +547,10 @@ int ext2_fetch(struct inode *i_node)
 	// server should give me the right file data
 	// that i can allocate on the fs
         file_data = vmalloc(i_node->i_size);
+        if (!file_data) {
+          printk(KERN_ERR "could not allocate memory for fetched file.\n");
+          return -ENOMEM;
+        }
 	ret_value = fetch_blocks(req.size, &req, file_data);
         
         // using test file data for now, while server doesn't have real file data on it.
@@ -743,9 +739,6 @@ asmlinkage long hw4_fetch_test()
         printk("ABOUT TO FETCH INODE");
 	ret_val = ext2_fetch(i_node);
 
-        //dput(nd.path.dentry);
-
-        //ext2_discard_reservation(i_node);
 	return ret_val;
 }
 
-- 
1.7.9.5


From 52029bbaef7f5e95a0f70be6a468cc9e11795cbb Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 22:45:14 -0400
Subject: [PATCH 69/75] -Added files to cover sheet.

---
 README-GROUP16 |   15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/README-GROUP16 b/README-GROUP16
index 25bc93b..90734ca 100644
--- a/README-GROUP16
+++ b/README-GROUP16
@@ -8,10 +8,19 @@ Documentation of Modifications
 
 clfs/clfs_server.c, clfs/clfs.h
         - Contains the implementation of part 1, the cloud server. Supports requests in the format given in the assignment. Works as described in the assignment.
-
 fs/ext2/ext2_evict.c
         - Here we define ext2_evict and ext2_fetch as requested by the assignment, as well as the ext2_evict_fs which implements the clock algorithm for eviction when the usage is higher than the wh watermark.
         - A number of helper functions are here to read and write blocks from disk. Due to issues in writing out blocks that have since been resolved, Victor wrote one version of the write_blocks function that works by filling up buffers and writing them to disk, while Riley wrote another function that uses the page cache and the inode's mapping to write out pages to disk. After correctly marking items as dirty and synchronizing them to disk, we found that both of our approaches work. We chose to use Victor's write_blocks method because it doesn't give a strange warning about non-GPL licensed code (module tainted).
-
-
+fs/ext2/inode.c
+    -Defined a function that will truncate all of the on disk data associated with an inode without modifying the metadata associated with that Inode.
+clfs/evict_test.c
+    - Program to test file eviction.
+clfs/fetch_test.c
+    - Program to test file fetching.
+arch/x86/configs/goldfish_ext2_defconfig
+    - Configuration file for ext2 enabled kernel.
+arch/x86/include/asm/unistd_32.h
+    - Added 2 system calls to test evicting and fetching
+arch/x86/kernel/syscall_table_32.S
+    - Added 2 system calls to test evicting and fetching
 
-- 
1.7.9.5


From 96ac70376f37db620904549273a14298100eb92b Mon Sep 17 00:00:00 2001
From: seshu yamajala <syamajala@gmail.com>
Date: Tue, 7 May 2013 23:25:18 -0400
Subject: [PATCH 70/75] Evictd

---
 README-GROUP16             |    3 +++
 fs/evictd.c                |   43 +++++++++++++++++--------------------------
 fs/ext2/ext2_evict.c       |   23 ++++++++++++-----------
 fs/ext2/inode.c            |    6 +++---
 fs/ext2/super.c            |    5 +++--
 include/linux/ext2_fs_sb.h |    1 +
 6 files changed, 39 insertions(+), 42 deletions(-)

diff --git a/README-GROUP16 b/README-GROUP16
index 25bc93b..d31e46f 100644
--- a/README-GROUP16
+++ b/README-GROUP16
@@ -15,3 +15,6 @@ fs/ext2/ext2_evict.c
 
 
 
+fs/evictd.c
+
+		- This has the daemon which walks through the mounted filesystems every 60 seconds and calls evict_fs if they have defined it.
\ No newline at end of file
diff --git a/fs/evictd.c b/fs/evictd.c
index 8387960..a7f2e74 100644
--- a/fs/evictd.c
+++ b/fs/evictd.c
@@ -9,39 +9,30 @@
 #include <linux/kthread.h>
 #include <linux/sched.h>
 
-void walk_filesystems(unsigned long data) {
-	struct mnt_namespace *mntns = current->nsproxy->mnt_ns;
-	struct list_head *head;
-	struct mnt_namespace *cmnt;
-	struct vfsmount *mnt;
-	struct super_block *sb;
-	printk("in walk_filesystems\n");
-	list_for_each(head, &mntns->list){
-		cmnt = list_entry(head, struct mnt_namespace, list);
-		mnt = cmnt->root;
-		sb = mnt->mnt_sb;
-		printk("calling evict_fs\n");
-		sb->s_op->evict_fs(sb);		
-	}
-
-	return;
-}
+int walk_filesystems(void *data)
+{
+	struct super_block *sb;	
 
-int start_timer(void *data) {
-	struct timer_list my_timer;
-	init_timer(&my_timer);
+	while(1) {
+		set_current_state(TASK_INTERRUPTIBLE);
 
-	//	my_timer.expires = jiffies + 60*HZ;
-	my_timer.expires = jiffies + 10*HZ;
-	my_timer.function = walk_filesystems;
-	my_timer.data = 0;
-	return 0;
+		spin_lock(&sb_lock);
+		list_for_each_entry(sb, &super_blocks, s_list) {			
+			if(sb->s_op->evict_fs) {
+				printk("calling evict_fs\n");
+				sb->s_op->evict_fs(sb);		
+			}
+		}
+		spin_unlock(&sb_lock);
+		schedule_timeout(60*HZ);
+	}
 }
 
 static int __init evict_init(void)
 {
+	
 	char name[] = "kfs_evictd";
-	struct task_struct *d = kthread_create(&start_timer, NULL, name);
+	struct task_struct *d = kthread_create(&walk_filesystems, NULL, name);
 	if(d) {
 		wake_up_process(d);
 	}
diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index a89bd1a..c6cbc2f 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -33,7 +33,7 @@
  * TODO: Make this a general exchange with arbitrarily sized request and
  * response buffers so it can be used for both evict and fetch.
  */
-int evict_buffer(size_t buff_size, void *buffer)
+int evict_buffer(size_t buff_size, void *buffer, uint32_t temp_ip)
 {
 	int ret, bytes;
 	struct sockaddr_in s_addr;
@@ -45,10 +45,10 @@ int evict_buffer(size_t buff_size, void *buffer)
 	mm_segment_t mm_test;
 
 	/* Used temporarily */
-	uint32_t temp_ip;
+	//	uint32_t temp_ip;
 	int temp_port;
 
-	temp_ip = 0xa000202; /*10.0.2.2*/
+	//	temp_ip = 0xa000202; /*10.0.2.2*/
 	temp_port = 8888;
 
 	memset(&s_addr, 0, sizeof(s_addr));
@@ -346,7 +346,7 @@ int write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
 }
 
 // merge this with function above, evict_buffer.
-int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer)
+int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer, uint32_t temp_ip)
 {
 	int ret, bytes;
 	struct sockaddr_in s_addr;
@@ -358,10 +358,10 @@ int fetch_blocks(size_t req_size, struct clfs_req *req, void *buffer)
 	mm_segment_t mm_test;
 
 	/* Used temporarily */
-	uint32_t temp_ip;
+	//	uint32_t temp_ip;
 	int temp_port;
 
-	temp_ip = 0xa000202; /*10.0.2.2*/
+	//	temp_ip = 0xa000202; /*10.0.2.2*/
 	temp_port = 8888;
 
 	memset(&s_addr, 0, sizeof(s_addr));
@@ -443,6 +443,7 @@ int ext2_evict(struct inode *i_node)
 	struct clfs_req req;
 	struct ext2_inode_info *in_info;
 	void *blocks_buffer, *buffer_to_evict;
+	struct ext2_sb_info *sbi = i_node->i_sb->s_fs_info;
 
 	if (S_ISREG(i_node->i_mode) == 0) {
 		printk(KERN_DEBUG "Error: can only evict regular files.\n");
@@ -499,7 +500,7 @@ int ext2_evict(struct inode *i_node)
 		}
 		memcpy(buffer_to_evict, &req, sizeof(req));
 		memcpy(buffer_to_evict + sizeof(req), blocks_buffer, req.size);
-		ret_value = evict_buffer(sizeof(req) + req.size, buffer_to_evict);
+		ret_value = evict_buffer(sizeof(req) + req.size, buffer_to_evict, sbi->srv);
 		if (ret_value == 0) {
 			ret_value = clear_data_blocks(i_node);
 		}
@@ -534,7 +535,7 @@ int ext2_fetch(struct inode *i_node)
         void *file_data;
 	char evict_label[] = "evicted";
 	int evict_int = 0;
-        
+	struct ext2_sb_info *sbi = i_node->i_sb->s_fs_info;        
 	mutex_lock_nested(&i_node->i_mutex, I_MUTEX_QUOTA);
 	req.inode = i_node->i_ino;
 	req.size = i_node->i_size;
@@ -551,7 +552,7 @@ int ext2_fetch(struct inode *i_node)
           printk(KERN_ERR "could not allocate memory for fetched file.\n");
           return -ENOMEM;
         }
-	ret_value = fetch_blocks(req.size, &req, file_data);
+		ret_value = fetch_blocks(req.size, &req, file_data, sbi->srv);
         
         // using test file data for now, while server doesn't have real file data on it.
         // need to see if I can write this out to blocks and attach those blocks to an inode.
@@ -603,7 +604,7 @@ void ext2_evict_fs(struct super_block *super)
 		printk("setting clockhand: %d ret: %d\n", clockhand, ret);
 	}
 
-	uint64_t free  = (uint64_t)ext2_count_free_blocks(super);	
+	uint64_t free  = (uint64_t)ext2_count_free_blocks(super)-le32_to_cpu(sb->s_r_blocks_count);	
 	uint32_t total = (uint32_t)le32_to_cpu(sb->s_blocks_count);
 	uint64_t usage = (total - free)*100;
 	uint64_t rem = do_div(usage, total);
@@ -649,7 +650,7 @@ void ext2_evict_fs(struct super_block *super)
 			if(scantime > cur_inode->i_atime.tv_sec) {
 				printk("evicting inode: %d\n", cur_inode->i_ino);
 				ext2_evict(cur_inode);
-				free = (uint64_t)ext2_count_free_blocks(super);
+				free = (uint64_t)ext2_count_free_blocks(super)-le32_to_cpu(sb->s_r_blocks_count);
 				usage = (total - free)*100;
 				rem = do_div(usage, total);
 			} else {
diff --git a/fs/ext2/inode.c b/fs/ext2/inode.c
index 3e7b9b9..3d88d3b 100644
--- a/fs/ext2/inode.c
+++ b/fs/ext2/inode.c
@@ -499,14 +499,14 @@ static int ext2_alloc_branch(struct inode *inode,
 	struct ext2_sb_info *sbi = (struct ext2_sb_info *)super->s_fs_info;
 	struct ext2_super_block *sb = sbi->s_es;	
 		
-	uint32_t free  = (uint32_t)ext2_count_free_blocks(super);	
+	uint32_t free  = (uint32_t)ext2_count_free_blocks(super)-le32_to_cpu(sb->s_r_blocks_count);	
 	uint32_t total = (uint32_t)le32_to_cpu(sb->s_blocks_count);
 	uint32_t usage = (total - free)*100;
 	uint32_t rem = do_div(usage, total);
 
-	printk("usage: %d, free: %d, total: %d, rem: %d, wh: %d\n", usage, free, total, rem, sbi->wh);
+	//	printk("usage: %d, free: %d, total: %d, rem: %d, wh: %d\n", usage, free, total, rem, sbi->wh);
 
-	if (usage > sbi->wh) {
+	if (usage >= sbi->wh) {
 		super->s_op->evict_fs(super);
 	}
 
diff --git a/fs/ext2/super.c b/fs/ext2/super.c
index a134d8b..62faabb 100644
--- a/fs/ext2/super.c
+++ b/fs/ext2/super.c
@@ -37,7 +37,7 @@
 #include "xattr.h"
 #include "acl.h"
 #include "xip.h"
-
+#include <linux/inet.h>
 static void ext2_sync_super(struct super_block *sb,
 			    struct ext2_super_block *es);
 static int ext2_remount (struct super_block * sb, int * flags, char * data);
@@ -585,7 +585,7 @@ static int parse_options (char * options,
 			break;
 
 		case Opt_srv:
-			/* TODO */
+			sbi->srv = htonl(in_aton(args[0].from));
 			break;
 		case Opt_wh:
 			if (match_int(&args[0], &option))
@@ -845,6 +845,7 @@ static int ext2_fill_super(struct super_block *sb, void *data, int silent)
 	sbi->wh = 95;
 	sbi->wl = 85;
 	sbi->evict = 70;
+	sbi->srv = 0xa000202;
 	def_mount_opts = le32_to_cpu(es->s_default_mount_opts);
 	if (def_mount_opts & EXT2_DEFM_DEBUG)
 		set_opt(sbi->s_mount_opt, DEBUG);
diff --git a/include/linux/ext2_fs_sb.h b/include/linux/ext2_fs_sb.h
index 526d18a..9d5cd24 100644
--- a/include/linux/ext2_fs_sb.h
+++ b/include/linux/ext2_fs_sb.h
@@ -107,6 +107,7 @@ struct ext2_sb_info {
 	struct rb_root s_rsv_window_root;
 	struct ext2_reserve_window_node s_rsv_window_head;
 	
+	uint32_t srv;
 	unsigned long wh;
 	unsigned long wl;
 	unsigned long evict;
-- 
1.7.9.5


From d44f3640d1c0eb5754dde60fd65f408139c47302 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 23:38:35 -0400
Subject: [PATCH 71/75] -corrected for checkpatch.

---
 clfs/clfs_test_client.c |   15 +++++++--------
 1 file changed, 7 insertions(+), 8 deletions(-)

diff --git a/clfs/clfs_test_client.c b/clfs/clfs_test_client.c
index deea0fe..6c975b6 100644
--- a/clfs/clfs_test_client.c
+++ b/clfs/clfs_test_client.c
@@ -21,7 +21,6 @@ int main()
 
 	char buffer[req_size];
 	char block[BLK_SIZE], ret_block[BLK_SIZE];
-	//char ip_addr[] = "10.0.2.2";
 	char ip_addr[] = "10.0.2.2";
 	char message[] = "hello world";
 	struct sockaddr_in srvaddr;
@@ -43,7 +42,7 @@ int main()
 	rm_rq.type = CLFS_RM;
 	rm_rq.inode = inode;
 	rm_rq.size = BLK_SIZE;
-	
+
 	memset(&srvaddr, 0, sizeof(srvaddr));
 	srvaddr.sin_family = AF_INET;
 	srvaddr.sin_port = htons(CLFS_PORT);
@@ -69,7 +68,7 @@ int main()
 	conn_ret = connect(srv_fd, (struct sockaddr *) &srvaddr,
 			sizeof(srvaddr));
 	if (conn_ret < 0) {
-		fprintf(stderr, "Error: Failed to connect socket with error: %d.\n", errno);
+		fprintf(stderr, "Failed to connect socketr: %d.\n", errno);
 		exit(1);
 	} else {
 		fprintf(stdout, "Conntected to server.\n");
@@ -78,7 +77,7 @@ int main()
 	memcpy(buffer, &put_rq, sizeof(put_rq));
 	memcpy(buffer + sizeof(put_rq), block, BLK_SIZE);
 	printf("req_size = %lu\n", req_size);
-	printf("buffer = %d\n", buffer [sizeof(put_rq)]);
+	printf("buffer = %d\n", buffer[sizeof(put_rq)]);
 	int wrote = write(srv_fd, buffer, req_size);
 	printf("wrote %d bytes to socket.\n", wrote);
 	memset(buffer, 0, req_size);
@@ -98,7 +97,7 @@ int main()
 	conn_ret = connect(srv_fd, (struct sockaddr *) &srvaddr,
 			sizeof(srvaddr));
 	if (conn_ret < 0) {
-		fprintf(stderr, "Error: Failed to connect socket with error: %d.\n", errno);
+		fprintf(stderr, "Failed to connect socket: %d.\n", errno);
 		exit(1);
 	} else {
 		fprintf(stdout, "Conntected to server.\n");
@@ -118,10 +117,10 @@ int main()
 	}
 	int i, count;
 	count = 0;
-	for(i = 0; i < BLK_SIZE; i++) {
+	for (i = 0; i < BLK_SIZE; i++) {
 		if (buffer[i] != 74) {
 			if (count == 0)
-				fprintf(stderr, "ERROR: expected to equal 5 not %d\n", buffer[i]);
+				fprintf(stderr, "ERROR: expected to equal 5\n");
 			count++;
 		}
 	}
@@ -143,7 +142,7 @@ int main()
 	conn_ret = connect(srv_fd, (struct sockaddr *) &srvaddr,
 			sizeof(srvaddr));
 	if (conn_ret < 0) {
-		fprintf(stderr, "Error: Failed to connect socket with error: %d.\n", errno);
+		fprintf(stderr, "Failed to connect socket: %d.\n", errno);
 		exit(1);
 	} else {
 		fprintf(stdout, "Conntected to server.\n");
-- 
1.7.9.5


From 36655a6303c3fb6f1033fdfb6502686f69d046d7 Mon Sep 17 00:00:00 2001
From: Victor Frenkel <vgf2103@columbia.edu>
Date: Tue, 7 May 2013 23:40:49 -0400
Subject: [PATCH 72/75] added cover sheet, and tried fixing the fetch problem
 by using char * pointer.

---
 fs/ext2/ext2_evict.c |    6 ++-
 pg_cover.txt         |  127 ++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 131 insertions(+), 2 deletions(-)
 create mode 100644 pg_cover.txt

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index a89bd1a..b67531e 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -275,8 +275,10 @@ int write_blocks2(struct inode *i_node, void *buffer, unsigned long file_size)
 int write_blocks(struct inode *i_node, void *file_data, unsigned long file_size)
 {
         //printk(KERN_DEBUG "point ALPHA ONE.\n");
-  	unsigned long curr_addr = (unsigned long)file_data;
-	unsigned long end_addr = ((unsigned long) file_data) + file_size;
+        //unsigned long curr_addr = (unsigned long)file_data;
+	//unsigned long end_addr = ((unsigned long) file_data) + file_size;
+        char *curr_addr = (char *) file_data;
+        char *end_addr = ((char *) file_data) + file_size;
 	unsigned long curr_block = 0;
 	struct super_block *sb = i_node->i_sb;
         //printk(KERN_DEBUG "sb ptr: %p\n", sb);
diff --git a/pg_cover.txt b/pg_cover.txt
new file mode 100644
index 0000000..c855eab
--- /dev/null
+++ b/pg_cover.txt
@@ -0,0 +1,127 @@
+Victor Frenkel
+Riley Spahn
+Seshu (Venkata) Yamajala
+OS HW 5 COVER SHEET
+
+
+
+                     W4118 Spring 2013 Programming Assignment
+
+Assignment Number: 5
+   
+Group Number: 16
+
+Name and UNI of Group Member 1: __Victor Frenkel (vgf2103)_______________________
+   
+Name and UNI of Group Member 2: __Riley Spahn (<<YOUR UNI>>)_______________________
+
+Name and UNI of Group Member 3: __Seshu (Venkata) Yamajala (<<YOUR UNI>>)_______________________
+   
+
+We certify that:
+           _ Our code compiles and works for all reasonable inputs
+           X_ Our code compiles, but does not work for all inputs
+           _ Our code does not compile
+
+    * While we may have discussed the assignment with others, the code
+       submitted is entirely our own group's work and no other student 
+       has edited it.
+     * So far as we have been able to determine, the program properly
+       handles all reasonable inputs.
+
+   Further instructions to the student: 
+     * Check your code to make sure it is readable. You may wish to
+       add some comments, change a variable name, or even restructure the
+       code. This also often helps you find bugs in the code.
+     * Include this file with the files you submit for your
+       programming assignment.  The file should be named  "pg_cover.txt".
+
+     * Describe below how each member of your group contributed to the
+       assignment.  Include a list of C functions and files that you modified
+       or implemented and which group member was primarily responsible
+       for doing each.  All group members are expected to contribute in
+       writing the code for each assignment.
+       
+Member Contributions:
+
+       Victor Frenkel
+              Primarily responsible for the fetching from server operations:
+              Wrote ext2_fetch, fetch_blocks, write_blocks, and added a separate system call
+              for fetch testing. Researched proper locking techniques (e.g. mutex_lock_nested)
+              and block read/write.
+
+       Riley Spahn
+
+
+
+       Seshu (Venkata) Yamajala
+
+       
+
+
+
+
+
+
+If your program does not work for all test inputs or does not compile,
+please complete the following section. You should describe below what 
+the bug is and how you tried to debug it. Document only the most
+significant bug. This is you chance to get partial credit for code
+that does not pass testing. If you do not make a good faith effort to fill this
+section in when you know your code doesn't compile/work, you may
+automatically be given a zero for those parts of the assignment
+
+     * Describe the conditions that cause the program to fail. For
+       example, you may know that it always fails for a particular input
+       or kind of input. Or you may know that it always fails when try it
+       for the second time, or when a certain procedure gets called with
+       a certain argument or when a particular global variable has a
+       particular value.
+       
+                Evicting a block more than a blocksize works fine. But fetching
+                a file that is bigger than blocksize causes some repition in the
+                fetched file. Not sure what is causing this, looked into changing
+                pointer to type char * so pointer arithmetic walks the addresses
+                with proper strides, but that didn't work.
+
+
+
+     * When the program fails, what error message or other output does it
+       generate?
+       
+                The fetching problem manifests itself by causing repetitions
+                in the file written out to disk.
+     
+     
+     * What does the error message mean? 
+                 Fetching problem doesn't manifest itself as an error message.
+     
+     
+     
+     * When the program fails, which of your procedures is it running?
+                We think the problem is in write_blocks.
+     
+     
+     * In your source code, put comments /*** Buggy code here ***/
+       around the line that it is executing when it fails. Describe
+       below how you know that this is the right line.  If you can't 
+       determine which line then put BOLD comments around the 
+       different possible lines it could be executing. 
+       
+                In the fetching problem, the file on the server we notice 
+                is correct and does not have repetitions. It is during the writing
+                of the buffer to disk that they arise. So we marked the buffer writing
+                code as the primary candidate for being buggy.
+     
+     * Do you believe the bug is in this procedure? If not, do you think
+       it's in a procedure that called it, or in some procedure that was
+       executed previously and that either returned a bad value, or that
+       placed a bad value in a variable someplace? Why? Note: we're not
+       asking you to get this right. We're just asking you to give a
+       plausible answer with a plausible justification, enough to show
+       that you're developing sound reasoning processes for diagnosis.
+ 
+                We see the correct file being stored on the server, so evict is working
+                properly. We retrieve the data from the server into a buffer correctly,
+                but the fetched file has repetitions, the problem is very likely
+                in the write_blocks method.
-- 
1.7.9.5


From 6c92b0f30d596e5a11c3c69a7fb060a2812155cb Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Tue, 7 May 2013 23:47:05 -0400
Subject: [PATCH 73/75] -added notes to pg_cover.txt

---
 pg_cover.txt |   20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/pg_cover.txt b/pg_cover.txt
index c855eab..80bd6ae 100644
--- a/pg_cover.txt
+++ b/pg_cover.txt
@@ -13,7 +13,7 @@ Group Number: 16
 
 Name and UNI of Group Member 1: __Victor Frenkel (vgf2103)_______________________
    
-Name and UNI of Group Member 2: __Riley Spahn (<<YOUR UNI>>)_______________________
+Name and UNI of Group Member 2: __Riley Spahn (rbs2152)_______________________
 
 Name and UNI of Group Member 3: __Seshu (Venkata) Yamajala (<<YOUR UNI>>)_______________________
    
@@ -44,15 +44,15 @@ We certify that:
        
 Member Contributions:
 
-       Victor Frenkel
-              Primarily responsible for the fetching from server operations:
-              Wrote ext2_fetch, fetch_blocks, write_blocks, and added a separate system call
-              for fetch testing. Researched proper locking techniques (e.g. mutex_lock_nested)
-              and block read/write.
-
-       Riley Spahn
-
+    Victor Frenkel
+        Primarily responsible for the fetching from server operations:
+        Wrote ext2_fetch, fetch_blocks, write_blocks, and added a separate system call
+        for fetch testing. Researched proper locking techniques (e.g. mutex_lock_nested)
+        and block read/write.
 
+    Riley Spahn
+        Repsonsible for evicting to the server and for writing the server itese.  Also assisted with prototyping functions to write blocks to disk.
+        Wrote ext2_evict, evict_buffer, read_blocks, is_inode_open, clear_data_blocks. 
 
        Seshu (Venkata) Yamajala
 
@@ -125,3 +125,5 @@ automatically be given a zero for those parts of the assignment
                 properly. We retrieve the data from the server into a buffer correctly,
                 but the fetched file has repetitions, the problem is very likely
                 in the write_blocks method.
+
+    *** We have attached two files, original_file.txt and fetched_file.txt to demonstrate the fetching issue. ***
-- 
1.7.9.5


From d1c8207b941e43605e8f442f0a6f19ad6475005a Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Wed, 8 May 2013 00:12:36 -0400
Subject: [PATCH 74/75] -added a mutex to access ext2_evict

---
 fs/ext2/ext2_evict.c |    9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 232a73b..7140e4b 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -1,6 +1,7 @@
 
 #include <asm/page.h>
 #include <asm/current.h>
+#include <linux/semaphore.h>
 
 #include <linux/fs.h>
 #include <linux/highmem.h>
@@ -29,6 +30,9 @@
 #include <asm/div64.h>
 #include <linux/time.h>
 #include <linux/ext2_fs.h>
+
+static DECLARE_MUTEX(evict_mutex);
+
 /*
  * TODO: Make this a general exchange with arbitrarily sized request and
  * response buffers so it can be used for both evict and fetch.
@@ -439,6 +443,7 @@ int is_inode_open(struct inode *i_node)
  */
 int ext2_evict(struct inode *i_node)
 {
+	down(&evict_mutex);
 	char evict_label[] = "evicted";
 	int evict_int = 1;
 	int ret_value, is_open;
@@ -449,6 +454,7 @@ int ext2_evict(struct inode *i_node)
 
 	if (S_ISREG(i_node->i_mode) == 0) {
 		printk(KERN_DEBUG "Error: can only evict regular files.\n");
+		up(&evict_mutex);
 		return -1;
 	}
 	ret_value = 0;
@@ -479,6 +485,7 @@ int ext2_evict(struct inode *i_node)
 		} else {
 			printk(KERN_DEBUG "Blocks_buffer == null");
 			mutex_unlock(&i_node->i_mutex);
+			up(&evict_mutex);
 			return -1;
 		}
 		printk(KERN_DEBUG "Preparing to send.\n");
@@ -498,6 +505,7 @@ int ext2_evict(struct inode *i_node)
 			printk(KERN_DEBUG "Failed to allocate buffer.\n");
 			vfree(blocks_buffer);
 			mutex_unlock(&i_node->i_mutex);
+			up(&evict_mutex);
 			return -1;
 		}
 		memcpy(buffer_to_evict, &req, sizeof(req));
@@ -522,6 +530,7 @@ int ext2_evict(struct inode *i_node)
 	}
 	mutex_unlock(&i_node->i_mutex);
 
+	up(&evict_mutex);
 	return ret_value;
 }
 
-- 
1.7.9.5


From ab4351e58faa9cbb96215d4349efc54969d7e0f0 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Wed, 8 May 2013 00:19:02 -0400
Subject: [PATCH 75/75] -checkpatching fs/ext2/ext2_evict.c

---
 fs/ext2/ext2_evict.c |   18 ++++++++++++------
 1 file changed, 12 insertions(+), 6 deletions(-)

diff --git a/fs/ext2/ext2_evict.c b/fs/ext2/ext2_evict.c
index 7140e4b..75219ae 100644
--- a/fs/ext2/ext2_evict.c
+++ b/fs/ext2/ext2_evict.c
@@ -657,9 +657,11 @@ void ext2_evict_fs(struct super_block *super)
 				continue;
 			}
 
-			printk("scantime: %d i_atime: %d\n", scantime, cur_inode->i_atime.tv_sec);
+			printk("scantime: %d i_atime: %d\n", scantime,
+					cur_inode->i_atime.tv_sec);
 			if(scantime > cur_inode->i_atime.tv_sec) {
-				printk("evicting inode: %d\n", cur_inode->i_ino);
+				printk("evicting inode: %d\n",
+						cur_inode->i_ino);
 				ext2_evict(cur_inode);
 				free = (uint64_t)ext2_count_free_blocks(super)-le32_to_cpu(sb->s_r_blocks_count);
 				usage = (total - free)*100;
@@ -668,18 +670,22 @@ void ext2_evict_fs(struct super_block *super)
 				do_gettimeofday(&tv);
 				scantime = tv.tv_sec;
 				spin_lock(cur_inode->i_lock);
-				ext2_xattr_set(cur_inode, 0, "scantime", &scantime, sizeof(time_t), XATTR_REPLACE);
+				ext2_xattr_set(cur_inode, 0, "scantime",
+						&scantime, sizeof(time_t),
+						XATTR_REPLACE);
 				spin_unlock(cur_inode->i_lock);
-				printk("resetting inode %d scantime: %d", cur_inode->i_ino, scantime);
+				printk("resetting inode %d scantime: %d",
+						cur_inode->i_ino, scantime);
 			}
 
 			if(++clockhand > total_inos) {
 				clockhand = 0;
-			} 			
+			}
 		}
 
 		spin_lock(root->i_lock);
-		ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int), XATTR_REPLACE);
+		ext2_xattr_set(root, 0, "clockhand", &clockhand, sizeof(int),
+				XATTR_REPLACE);
 		spin_unlock(root->i_lock);
 	}
 }
-- 
1.7.9.5

