From 903b9a136da5c3a66925a3f8a91c86e2a519b8e5 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Mon, 18 Feb 2013 21:06:53 -0500
Subject: [PATCH 01/64] -added color to the task_struct.

---
 include/linux/sched.h |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/include/linux/sched.h b/include/linux/sched.h
index 011db2f..9d112d8 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1417,6 +1417,9 @@ struct task_struct {
 	/* state flags for use by tracers */
 	unsigned long trace;
 #endif
+
+        /* added color for some sort of security. Added 2/18/13 */
+        u_int16_t color;
 };
 
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
-- 
1.7.9.5


From f09dc3204862347bb8f0711014c1010d0a4d733b Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 19 Feb 2013 18:31:30 -0500
Subject: [PATCH 02/64] -added stub functions in kernel/color.c -updated the
 kernel/Makefile to build color.o

---
 kernel/Makefile |    3 ++-
 kernel/color.c  |   16 ++++++++++++++++
 2 files changed, 18 insertions(+), 1 deletion(-)
 create mode 100644 kernel/color.c

diff --git a/kernel/Makefile b/kernel/Makefile
index e4791b3..b81322b 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -2,6 +2,7 @@
 # Makefile for the linux kernel.
 #
 
+# color.o added by: Riley Spahn, 2/19/13
 obj-y     = sched.o fork.o exec_domain.o panic.o printk.o \
 	    cpu.o exit.o itimer.o time.o softirq.o resource.o \
 	    sysctl.o capability.o ptrace.o timer.o user.o \
@@ -10,7 +11,7 @@ obj-y     = sched.o fork.o exec_domain.o panic.o printk.o \
 	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
 	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
 	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
-	    async.o
+	    async.o color.o
 
 ifdef CONFIG_FUNCTION_TRACER
 # Do not trace debug files and internal ftrace files
diff --git a/kernel/color.c b/kernel/color.c
new file mode 100644
index 0000000..775a4fe
--- /dev/null
+++ b/kernel/color.c
@@ -0,0 +1,16 @@
+#include <linux/errno.h>
+#include <linux/types.h>
+
+/*
+ * TODO
+ */
+int set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
+        return -EACCES;
+}
+
+/*
+ * TODO
+ */
+int get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
+        return -EACCES;
+}
-- 
1.7.9.5


From 4ccd29ad3fa57ee8bde66ac6d0425752a735a570 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 19 Feb 2013 18:55:20 -0500
Subject: [PATCH 03/64] -added system calls 223 and 251 to asm/unistd_32.h
 -added system calls 295 and 296 to asm/unistd_64.h

---
 arch/x86/include/asm/unistd_32.h |    4 ++--
 arch/x86/include/asm/unistd_64.h |    5 +++++
 2 files changed, 7 insertions(+), 2 deletions(-)

diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index f2bba78..1b8251f 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -228,7 +228,7 @@
 #define __NR_madvise1		219	/* delete when C lib stub is removed */
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
-/* 223 is unused */
+#define __NR_set_colors         223 /* Added 2/19/13 */
 #define __NR_gettid		224
 #define __NR_readahead		225
 #define __NR_setxattr		226
@@ -256,7 +256,7 @@
 #define __NR_io_submit		248
 #define __NR_io_cancel		249
 #define __NR_fadvise64		250
-/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
+#define __NR_get_colors         251 /* Added 2/19/13 */
 #define __NR_exit_group		252
 #define __NR_lookup_dcookie	253
 #define __NR_epoll_create	254
diff --git a/arch/x86/include/asm/unistd_64.h b/arch/x86/include/asm/unistd_64.h
index d2e415e..f3c27ec 100644
--- a/arch/x86/include/asm/unistd_64.h
+++ b/arch/x86/include/asm/unistd_64.h
@@ -654,6 +654,11 @@ __SYSCALL(__NR_pipe2, sys_pipe2)
 #define __NR_inotify_init1			294
 __SYSCALL(__NR_inotify_init1, sys_inotify_init1)
 
+/* Added 2/19/13 */
+#define __NR_set_colors4                        295
+__SYSCALL(__NR_set_colors4, sys_set_colors4)
+#define __NR_get_colors4                        296
+__SYSCALL(__NR_get_colors4, sys_get_colors4)
 
 #ifndef __NO_STUBS
 #define __ARCH_WANT_OLD_READDIR
-- 
1.7.9.5


From 8c9fbe9de9872aa82c422b9e21e20c3d994dfdcb Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 19 Feb 2013 18:56:20 -0500
Subject: [PATCH 04/64] -correct set_colors -> sys_set_colors. -corrected
 get_colors -> sys_get_colors. -this is to be in line
 with the LKD book.

---
 kernel/color.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 775a4fe..d2438d3 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -4,13 +4,13 @@
 /*
  * TODO
  */
-int set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
+int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
         return -EACCES;
 }
 
 /*
  * TODO
  */
-int get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
+int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
         return -EACCES;
 }
-- 
1.7.9.5


From 3f7545e214c73b825963e9c37e15cc7f5730af02 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 19 Feb 2013 19:00:41 -0500
Subject: [PATCH 05/64] added system calls 361 and 362 to ARM

---
 arch/arm/include/asm/unistd.h |    4 ++++
 1 file changed, 4 insertions(+)

diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index 0106184..e78a30a 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -388,6 +388,10 @@
 #define __NR_pipe2			(__NR_SYSCALL_BASE+359)
 #define __NR_inotify_init1		(__NR_SYSCALL_BASE+360)
 
+/* Added 2/19/13 */
+#define __NR_set_colors4                (__NR_SYSCALL_BASE+361) 
+#define __NR_get_colors4                (__NR_SYSCALL_BASE+362)
+
 /*
  * The following SWIs are ARM private.
  */
-- 
1.7.9.5


From 34693ea6d00e6eec1f5f4b49c4973d654d75d328 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 19 Feb 2013 19:32:20 -0500
Subject: [PATCH 06/64] -fixed spaces to tabs in arm/include/asm/unistd.h
 -added new system calls to arm/kenel/calls.S, arm
 system call table. -added new system calls to
 x86/kernel/syscall_table_32.S, x86 32 bit sys call
 table.

---
 arch/arm/include/asm/unistd.h      |    4 ++--
 arch/arm/kernel/calls.S            |    2 ++
 arch/x86/kernel/syscall_table_32.S |    4 ++--
 3 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index e78a30a..3baf394 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -389,8 +389,8 @@
 #define __NR_inotify_init1		(__NR_SYSCALL_BASE+360)
 
 /* Added 2/19/13 */
-#define __NR_set_colors4                (__NR_SYSCALL_BASE+361) 
-#define __NR_get_colors4                (__NR_SYSCALL_BASE+362)
+#define __NR_set_colors4		(__NR_SYSCALL_BASE+361) 
+#define __NR_get_colors4		(__NR_SYSCALL_BASE+362)
 
 /*
  * The following SWIs are ARM private.
diff --git a/arch/arm/kernel/calls.S b/arch/arm/kernel/calls.S
index 9ca8d13..06307ff 100644
--- a/arch/arm/kernel/calls.S
+++ b/arch/arm/kernel/calls.S
@@ -370,6 +370,8 @@
 		CALL(sys_dup3)
 		CALL(sys_pipe2)
 /* 360 */	CALL(sys_inotify_init1)
+		CALL(sys_set_colors4) /* 361 Added 2/19/13 */
+		CALL(sys_get_colors4) /* 361 Added 2/19/13 */
 #ifndef syscalls_counted
 .equ syscalls_padding, ((NR_syscalls + 3) & ~3) - NR_syscalls
 #define syscalls_counted
diff --git a/arch/x86/kernel/syscall_table_32.S b/arch/x86/kernel/syscall_table_32.S
index e2e86a0..5d3e87f 100644
--- a/arch/x86/kernel/syscall_table_32.S
+++ b/arch/x86/kernel/syscall_table_32.S
@@ -222,7 +222,7 @@ ENTRY(sys_call_table)
 	.long sys_getdents64	/* 220 */
 	.long sys_fcntl64
 	.long sys_ni_syscall	/* reserved for TUX */
-	.long sys_ni_syscall
+	.long sys_set_colors	/* Added 2/19/13 */
 	.long sys_gettid
 	.long sys_readahead	/* 225 */
 	.long sys_setxattr
@@ -250,7 +250,7 @@ ENTRY(sys_call_table)
 	.long sys_io_submit
 	.long sys_io_cancel
 	.long sys_fadvise64	/* 250 */
-	.long sys_ni_syscall
+	.long sys_get_colors	/* added 2/19/13 */
 	.long sys_exit_group
 	.long sys_lookup_dcookie
 	.long sys_epoll_create
-- 
1.7.9.5


From f78e765453a1440b38b07a5c5b394828bfc5da89 Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Tue, 19 Feb 2013 19:53:30 -0500
Subject: [PATCH 07/64] added syscall numbers to x86 32bit

---
 arch/x86/include/asm/unistd_32.h |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/arch/x86/include/asm/unistd_32.h b/arch/x86/include/asm/unistd_32.h
index f2bba78..df059a6 100644
--- a/arch/x86/include/asm/unistd_32.h
+++ b/arch/x86/include/asm/unistd_32.h
@@ -228,7 +228,7 @@
 #define __NR_madvise1		219	/* delete when C lib stub is removed */
 #define __NR_getdents64		220
 #define __NR_fcntl64		221
-/* 223 is unused */
+#define __NR_set_colors         223/* 223 is unused */
 #define __NR_gettid		224
 #define __NR_readahead		225
 #define __NR_setxattr		226
@@ -256,7 +256,7 @@
 #define __NR_io_submit		248
 #define __NR_io_cancel		249
 #define __NR_fadvise64		250
-/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
+#define __NR_get_colors         251/* 251 is available for reuse (was briefly sys_set_zone_reclaim) */
 #define __NR_exit_group		252
 #define __NR_lookup_dcookie	253
 #define __NR_epoll_create	254
-- 
1.7.9.5


From 26bfaf1f870eb9a5effb820c3917bf8f69a50c52 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rbs2152@columbia.edu>
Date: Thu, 21 Feb 2013 18:41:53 -0500
Subject: [PATCH 08/64] -added asmlinkage to each system call in color.c

---
 kernel/color.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index d2438d3..8bb3b49 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -1,16 +1,17 @@
 #include <linux/errno.h>
+#include <linux/linkage.h>
 #include <linux/types.h>
 
 /*
  * TODO
  */
-int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
+asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
         return -EACCES;
 }
 
 /*
  * TODO
  */
-int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
+asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
         return -EACCES;
 }
-- 
1.7.9.5


From 114d3a8ef01b01fdaab3343c2c31a0e9a9588509 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Fri, 22 Feb 2013 17:51:36 -0500
Subject: [PATCH 09/64] -added allocation to set_colors function.

---
 kernel/color.c |   53 +++++++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 49 insertions(+), 4 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index d2438d3..74c6b62 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -1,16 +1,61 @@
 #include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
 #include <linux/types.h>
 
 /*
  * TODO
  */
-int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
-        return -EACCES;
+int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+{
+	pid_t *k_pids;
+	u_int16_t *k_colors;
+	int *k_retval;
+	unsigned long bytes_copied;
+	/* Must have root privledges, TODO */
+
+	k_pids = kmalloc(sizeof(pid_t *) * nr_pids, GFP_KERNEL);
+	if (k_pids == NULL) {
+		printk(KERN_ERR, "Failed to kallocate for k_pids\n");
+		return -EINVAL;
+	}
+	k_colors = kmalloc(sizeof(u_int16_t) * nr_pids, GFP_KERNEL);
+	if (k_colors == NULL) {
+		printk(KERN_ERR, "Failed to kallocate for k_colors\n");
+		return -EINVAL;
+	}
+	k_retval = kmalloc(sizeof(int) * nr_pids, GFP_KERNEL);
+	if (k_retval == NULL) {
+		printk(KERN_ERR, "Failed to kallocate for k_retval\n");
+		return -EINVAL;
+	}
+
+	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
+	if (bytes_copied != 0) {
+		printk(KERN_ERR, "Failed to copy bytes for k_pids\n");
+		return -EINVAL;
+	}
+
+	bytes_copied = copy_from_user(k_colors, colors, sizeof(u_int16_t) *
+			nr_pids);
+	if (bytes_copied != 0) {
+		printk(KERN_ERR, "Failed to copy bytes for k_bytes\n");
+		return -EINVAL;
+	}
+
+	kfree(k_pids);
+	kfree(k_colors);
+	kfree(k_retval);
+
+	printk(KERN_ERR, "Finished set_color function\n");
+	return 0;
 }
 
 /*
  * TODO
  */
-int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval){
-        return -EACCES;
+int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+{
+	return -EACCES;
 }
-- 
1.7.9.5


From 31b692ab5a7977a99389ca77b8a680982115d584 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Fri, 22 Feb 2013 19:00:55 -0500
Subject: [PATCH 10/64] -added color setting for a given file. -need to check
 locking.

---
 kernel/color.c |   38 ++++++++++++++++++++++++++++++++++++++
 1 file changed, 38 insertions(+)

diff --git a/kernel/color.c b/kernel/color.c
index 74c6b62..cd7d9e4 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -4,6 +4,31 @@
 #include <linux/uaccess.h>
 #include <linux/types.h>
 
+
+int set_color(pid_t pid, u_int16_t color)
+{
+	struct task_struct *crnt_tsk;
+	crnt_tsk = kmalloc(sizeof(struct task_struct), GFP_KERNEL);
+	if (crnt_tsk == NULL) {
+		printk(KERN_ERR, "Failed to allocate task_struct memory.\n");
+		return -EINVAL;
+	}
+
+	crnt_tsk = find_task_by_vpid(pid);
+	if (crnt_tsk == NULL) {
+		return -EINVAL;
+	} else {
+		/* Set the color */
+		crnt_tsk->color = color;
+		/* Propogate to threads */
+
+		kfree(crnt_tsk);
+		return 0;
+	}
+}
+
+
+
 /*
  * TODO
  */
@@ -11,6 +36,7 @@ int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
+	int i;
 	int *k_retval;
 	unsigned long bytes_copied;
 	/* Must have root privledges, TODO */
@@ -23,17 +49,23 @@ int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 	k_colors = kmalloc(sizeof(u_int16_t) * nr_pids, GFP_KERNEL);
 	if (k_colors == NULL) {
 		printk(KERN_ERR, "Failed to kallocate for k_colors\n");
+		kfree(k_pids);
 		return -EINVAL;
 	}
 	k_retval = kmalloc(sizeof(int) * nr_pids, GFP_KERNEL);
 	if (k_retval == NULL) {
 		printk(KERN_ERR, "Failed to kallocate for k_retval\n");
+		kfree(k_pids);
+		kfree(k_colors);
 		return -EINVAL;
 	}
 
 	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
 	if (bytes_copied != 0) {
 		printk(KERN_ERR, "Failed to copy bytes for k_pids\n");
+		kfree(k_pids);
+		kfree(k_colors);
+		kfree(k_retval);
 		return -EINVAL;
 	}
 
@@ -41,9 +73,15 @@ int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 			nr_pids);
 	if (bytes_copied != 0) {
 		printk(KERN_ERR, "Failed to copy bytes for k_bytes\n");
+		kfree(k_pids);
+		kfree(k_colors);
+		kfree(k_retval);
 		return -EINVAL;
 	}
 
+	for (i = 0; i < nr_pids; i++)
+		k_retval[i] = set_color(k_pids[i], k_colors[i]);
+
 	kfree(k_pids);
 	kfree(k_colors);
 	kfree(k_retval);
-- 
1.7.9.5


From 1211d27006a41ff4af5cb5c320695297dd390faf Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Fri, 22 Feb 2013 22:29:09 -0500
Subject: [PATCH 11/64] -wrote basic functionality of get_colors and
 set_colors. -added get_color and set_color functions
 to set and get colors for individual processes.
 -added function to do memory allocation and error
 handling. -need to check returns.

---
 kernel/color.c |  125 +++++++++++++++++++++++++++++++++++++++++---------------
 1 file changed, 92 insertions(+), 33 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index cd7d9e4..c240b76 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -8,12 +8,6 @@
 int set_color(pid_t pid, u_int16_t color)
 {
 	struct task_struct *crnt_tsk;
-	crnt_tsk = kmalloc(sizeof(struct task_struct), GFP_KERNEL);
-	if (crnt_tsk == NULL) {
-		printk(KERN_ERR, "Failed to allocate task_struct memory.\n");
-		return -EINVAL;
-	}
-
 	crnt_tsk = find_task_by_vpid(pid);
 	if (crnt_tsk == NULL) {
 		return -EINVAL;
@@ -21,79 +15,144 @@ int set_color(pid_t pid, u_int16_t color)
 		/* Set the color */
 		crnt_tsk->color = color;
 		/* Propogate to threads */
-
-		kfree(crnt_tsk);
 		return 0;
 	}
 }
 
+int get_color(pid_t pid)
+{
+	struct task_struct *crnt_tsk;
+	crnt_tsk = find_task_by_vpid(pid);
+	if (crnt_tsk == NULL)
+		return -EINVAL;
+	else
+		return crnt_tsk->color;
+}
 
-
-/*
- * TODO
- */
-int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+int allocate_color_mem(int nr_pids, pid_t *pids, pid_t *k_pids,
+		u_int16_t *colors, u_int16_t *k_colors, int *retval,
+		int *k_retval)
 {
-	pid_t *k_pids;
-	u_int16_t *k_colors;
-	int i;
-	int *k_retval;
-	unsigned long bytes_copied;
-	/* Must have root privledges, TODO */
 
 	k_pids = kmalloc(sizeof(pid_t *) * nr_pids, GFP_KERNEL);
 	if (k_pids == NULL) {
-		printk(KERN_ERR, "Failed to kallocate for k_pids\n");
+		printk("Failed to kallocate for k_pids\n");
 		return -EINVAL;
 	}
 	k_colors = kmalloc(sizeof(u_int16_t) * nr_pids, GFP_KERNEL);
 	if (k_colors == NULL) {
-		printk(KERN_ERR, "Failed to kallocate for k_colors\n");
+		printk("Failed to kallocate for k_colors\n");
 		kfree(k_pids);
 		return -EINVAL;
 	}
 	k_retval = kmalloc(sizeof(int) * nr_pids, GFP_KERNEL);
 	if (k_retval == NULL) {
-		printk(KERN_ERR, "Failed to kallocate for k_retval\n");
+		printk("Failed to kallocate for k_retval\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		return -EINVAL;
 	}
+	return 0;
+}
 
-	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
+/*
+ * TODO
+ */
+int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+{
+	pid_t *k_pids;
+	u_int16_t *k_colors;
+	int i;
+	int mem_ret;
+	int *k_retval;
+	int ret_value;
+	unsigned long bytes_copied;
+	/* Must have root privledges, TODO */
+
+	k_pids = NULL;
+	k_colors = NULL;
+	k_retval = NULL;
+	mem_ret = allocate_color_mem(nr_pids, pids, k_pids, colors, k_colors,
+			retval, k_retval);
+	if (mem_ret == -EINVAL)
+		return mem_ret;
+
+	bytes_copied = copy_from_user(k_colors, colors, sizeof(u_int16_t) *
+			nr_pids);
 	if (bytes_copied != 0) {
-		printk(KERN_ERR, "Failed to copy bytes for k_pids\n");
+		printk("Failed to copy bytes for k_bytes\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		kfree(k_retval);
 		return -EINVAL;
 	}
 
-	bytes_copied = copy_from_user(k_colors, colors, sizeof(u_int16_t) *
-			nr_pids);
+	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
 	if (bytes_copied != 0) {
-		printk(KERN_ERR, "Failed to copy bytes for k_bytes\n");
+		printk("Failed to copy bytes for k_pids\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		kfree(k_retval);
 		return -EINVAL;
 	}
-
-	for (i = 0; i < nr_pids; i++)
+	ret_value = 0;
+	for (i = 0; i < nr_pids; i++) {
 		k_retval[i] = set_color(k_pids[i], k_colors[i]);
+		if (k_retval[i] != 0)
+			ret_value = k_retval[i];
+	}
+
+	bytes_copied = copy_to_user(retval, k_retval, sizeof(pid_t) * nr_pids);
+	if (bytes_copied != 0)
+		ret_value = -EINVAL;
 
 	kfree(k_pids);
 	kfree(k_colors);
 	kfree(k_retval);
-
-	printk(KERN_ERR, "Finished set_color function\n");
-	return 0;
+	printk("Finished set_color function\n");
+	return ret_value;
 }
 
+
 /*
  * TODO
  */
 int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 {
-	return -EACCES;
+	pid_t *k_pids;
+	u_int16_t *k_colors;
+	int i;
+	int mem_ret;
+	int *k_retval;
+	int ret_value;
+	unsigned long bytes_copied;
+
+	k_pids = NULL;
+	k_colors = NULL;
+	k_retval = NULL;
+	mem_ret = allocate_color_mem(nr_pids, pids, k_pids, colors, k_colors,
+			retval, k_retval);
+	if (mem_ret == -EINVAL)
+		return mem_ret;
+	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
+	if (bytes_copied != 0) {
+		kfree(k_pids);
+		kfree(k_colors);
+		kfree(k_retval);
+	}
+	ret_value = 0;
+	for (i = 0; i < nr_pids; i++) {
+		retval[i] = get_color(pids[i]);
+		if (retval[i] != 0)
+			ret_value = retval[i];
+	}
+
+	bytes_copied = copy_to_user(retval, k_retval, sizeof(pid_t) * nr_pids);
+	if (bytes_copied != 0)
+		ret_value = -EINVAL;
+
+	kfree(k_pids);
+	kfree(k_colors);
+	kfree(k_retval);
+	return ret_value;
 }
-- 
1.7.9.5


From e568c8fc341cea760418676ebc6583450ba3f1a6 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Fri, 22 Feb 2013 22:34:16 -0500
Subject: [PATCH 12/64] -added asmlinkage tag.

---
 kernel/color.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index c240b76..61f8548 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -58,7 +58,7 @@ int allocate_color_mem(int nr_pids, pid_t *pids, pid_t *k_pids,
 /*
  * TODO
  */
-int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
@@ -117,7 +117,7 @@ int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 /*
  * TODO
  */
-int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
-- 
1.7.9.5


From 4f857be8c792559cb6f61ccd5a1ae1f4f7da166c Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 23 Feb 2013 15:53:49 -0500
Subject: [PATCH 13/64] -added functionality to copy colors to array. Before
 it was only returning the return value and not the
 color.

---
 kernel/color.c |   35 +++++++++++++++++++++++++++--------
 1 file changed, 27 insertions(+), 8 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 61f8548..e1767d0 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -4,7 +4,11 @@
 #include <linux/uaccess.h>
 #include <linux/types.h>
 
-
+/*
+ * Sets the color of the pid to color.  Will also propogate the color to all
+ * other processes in the thread group.  Returns 0 if successful and -EINVAL
+ * if unsucessful.
+ */
 int set_color(pid_t pid, u_int16_t color)
 {
 	struct task_struct *crnt_tsk;
@@ -19,16 +23,26 @@ int set_color(pid_t pid, u_int16_t color)
 	}
 }
 
-int get_color(pid_t pid)
+/*
+ * TODO
+ */
+int get_color(pid_t pid, u_int16_t *color)
 {
 	struct task_struct *crnt_tsk;
 	crnt_tsk = find_task_by_vpid(pid);
 	if (crnt_tsk == NULL)
 		return -EINVAL;
-	else
-		return crnt_tsk->color;
+	else {
+		*color = crnt_tsk->color;
+		return 0;
+	}
 }
 
+/**
+ * Allocates memory needed for color operations.  Returns 0 if successful and
+ * -EINVAL if not.  If not successful it will clean up memory previously
+ *  allocated in the function.
+ */
 int allocate_color_mem(int nr_pids, pid_t *pids, pid_t *k_pids,
 		u_int16_t *colors, u_int16_t *k_colors, int *retval,
 		int *k_retval)
@@ -58,7 +72,8 @@ int allocate_color_mem(int nr_pids, pid_t *pids, pid_t *k_pids,
 /*
  * TODO
  */
-asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
+		int *retval)
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
@@ -117,7 +132,8 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *
 /*
  * TODO
  */
-asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval)
+asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
+		int *retval)
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
@@ -142,12 +158,15 @@ asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors, int *
 	}
 	ret_value = 0;
 	for (i = 0; i < nr_pids; i++) {
-		retval[i] = get_color(pids[i]);
-		if (retval[i] != 0)
+		k_retval[i] = get_color(k_pids[i], k_colors + i);
+		if (k_retval[i] != 0)
 			ret_value = retval[i];
 	}
 
 	bytes_copied = copy_to_user(retval, k_retval, sizeof(pid_t) * nr_pids);
+	bytes_copied = copy_to_user(colors, k_colors, sizeof(u_int16_t) *
+			nr_pids);
+
 	if (bytes_copied != 0)
 		ret_value = -EINVAL;
 
-- 
1.7.9.5


From 9cdf6a77b9a7003f671b7e9c44ba7e889f760dea Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sun, 24 Feb 2013 00:05:57 -0500
Subject: [PATCH 14/64] -removed memory allocation function. -it obfuscated
 what was going on.

---
 kernel/color.c |   72 ++++++++++++++++++++++++++++----------------------------
 1 file changed, 36 insertions(+), 36 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index e1767d0..7a588db 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -38,15 +38,24 @@ int get_color(pid_t pid, u_int16_t *color)
 	}
 }
 
-/**
- * Allocates memory needed for color operations.  Returns 0 if successful and
- * -EINVAL if not.  If not successful it will clean up memory previously
- *  allocated in the function.
+/*
+ * TODO
  */
-int allocate_color_mem(int nr_pids, pid_t *pids, pid_t *k_pids,
-		u_int16_t *colors, u_int16_t *k_colors, int *retval,
-		int *k_retval)
+asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
+		int *retval)
 {
+	pid_t *k_pids;
+	u_int16_t *k_colors;
+	int i;
+	int mem_ret;
+	int *k_retval;
+	int ret_value;
+	unsigned long bytes_copied;
+	/* Must have root privledges, TODO */
+
+	k_pids = NULL;
+	k_colors = NULL;
+	k_retval = NULL;
 
 	k_pids = kmalloc(sizeof(pid_t *) * nr_pids, GFP_KERNEL);
 	if (k_pids == NULL) {
@@ -66,31 +75,6 @@ int allocate_color_mem(int nr_pids, pid_t *pids, pid_t *k_pids,
 		kfree(k_colors);
 		return -EINVAL;
 	}
-	return 0;
-}
-
-/*
- * TODO
- */
-asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
-		int *retval)
-{
-	pid_t *k_pids;
-	u_int16_t *k_colors;
-	int i;
-	int mem_ret;
-	int *k_retval;
-	int ret_value;
-	unsigned long bytes_copied;
-	/* Must have root privledges, TODO */
-
-	k_pids = NULL;
-	k_colors = NULL;
-	k_retval = NULL;
-	mem_ret = allocate_color_mem(nr_pids, pids, k_pids, colors, k_colors,
-			retval, k_retval);
-	if (mem_ret == -EINVAL)
-		return mem_ret;
 
 	bytes_copied = copy_from_user(k_colors, colors, sizeof(u_int16_t) *
 			nr_pids);
@@ -146,15 +130,31 @@ asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 	k_pids = NULL;
 	k_colors = NULL;
 	k_retval = NULL;
-	mem_ret = allocate_color_mem(nr_pids, pids, k_pids, colors, k_colors,
-			retval, k_retval);
-	if (mem_ret == -EINVAL)
-		return mem_ret;
+
+	k_pids = kmalloc(sizeof(pid_t *) * nr_pids, GFP_KERNEL);
+	if (k_pids == NULL) {
+		printk("Failed to kallocate for k_pids\n");
+		return -EINVAL;
+	}
+	k_colors = kmalloc(sizeof(u_int16_t) * nr_pids, GFP_KERNEL);
+	if (k_colors == NULL) {
+		printk("Failed to kallocate for k_colors\n");
+		kfree(k_pids);
+		return -EINVAL;
+	}
+	k_retval = kmalloc(sizeof(int) * nr_pids, GFP_KERNEL);
+	if (k_retval == NULL) {
+		printk("Failed to kallocate for k_retval\n");
+		kfree(k_pids);
+		kfree(k_colors);
+		return -EINVAL;
+	}
 	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
 	if (bytes_copied != 0) {
 		kfree(k_pids);
 		kfree(k_colors);
 		kfree(k_retval);
+		return -EINVAL;
 	}
 	ret_value = 0;
 	for (i = 0; i < nr_pids; i++) {
-- 
1.7.9.5


From ff84cd0cbefeb042a7e5a6308199726c84a62613 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rbs2152@columbia.edu>
Date: Sun, 24 Feb 2013 00:47:41 -0500
Subject: [PATCH 15/64] -system calls are working for 1 pid at least.

---
 kernel/color.c |   26 +++++++++++++++++---------
 1 file changed, 17 insertions(+), 9 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 70b8ebc..020db32 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -18,8 +18,10 @@ int set_color(pid_t pid, u_int16_t color)
 		return -EINVAL;
 	} else {
 		/* Set the color */
+		printk("Setting %d color: %d\n", pid, color);
 		crnt_tsk->color = color;
 		/* Propogate to threads */
+		printk("crnttsk color = %d\n", crnt_tsk->color);
 		return 0;
 	}
 }
@@ -27,16 +29,14 @@ int set_color(pid_t pid, u_int16_t color)
 /*
  * TODO
  */
-int get_color(pid_t pid, u_int16_t *color)
+int get_color(pid_t pid)
 {
 	struct task_struct *crnt_tsk;
 	crnt_tsk = find_task_by_vpid(pid);
 	if (crnt_tsk == NULL)
 		return -EINVAL;
-	else {
-		*color = crnt_tsk->color;
-		return 0;
-	}
+	else
+		return crnt_tsk->color;
 }
 
 /*
@@ -123,6 +123,7 @@ asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
+	u_int16_t color_return;
 	int i;
 	int mem_ret;
 	int *k_retval;
@@ -160,13 +161,20 @@ asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 	}
 	ret_value = 0;
 	for (i = 0; i < nr_pids; i++) {
-		k_retval[i] = get_color(k_pids[i], k_colors + i);
-		if (k_retval[i] != 0)
-			ret_value = retval[i];
+		color_return = get_color(k_pids[i]);
+		printk("color_return = %d\n", color_return);
+		if (color_return == -EINVAL) {
+			ret_value = -EINVAL;
+			k_retval[i] = -EINVAL;
+			k_colors[i] = -EINVAL;
+		} else {
+			k_retval[i] = 0;
+			k_colors[i] = color_return;
+		}
 	}
 
 	bytes_copied = copy_to_user(retval, k_retval, sizeof(pid_t) * nr_pids);
-	bytes_copied = copy_to_user(colors, k_colors, sizeof(u_int16_t) *
+	bytes_copied = copy_to_user(colors, k_colors, sizeof(u_int16_t *) *
 			nr_pids);
 
 	if (bytes_copied != 0)
-- 
1.7.9.5


From d6e1b179b52f350327881757849f3c184f939421 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@vanilla.clic.cs.columbia.edu>
Date: Mon, 25 Feb 2013 14:36:53 -0500
Subject: [PATCH 16/64] Add two test programs to test the setcolors and
 getcolors system calls.

---
 test_getcolors.c |  162 ++++++++++++++++++++++++++++++++++++++++++++++++
 test_setcolors.c |  180 ++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 342 insertions(+)
 create mode 100644 test_getcolors.c
 create mode 100644 test_setcolors.c

diff --git a/test_getcolors.c b/test_getcolors.c
new file mode 100644
index 0000000..9fbd304
--- /dev/null
+++ b/test_getcolors.c
@@ -0,0 +1,162 @@
+/******************************************************
+ *This is a test program that is used to test getcolors
+ ******************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+
+#define MAX_CMD_LEN 100
+#define MAX_CMD_NAME_LEN 50
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_get_colors 251
+
+//_syscall4(int, get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+    struct dirent *d;
+    FILE *fp;
+    DIR *dir;
+    char filepath[FILE_LEN];
+    char filetext[FILE_LEN];
+    int index;
+    dir = opendir("/proc");
+    if (!dir) {
+        perror("Open proc directory failed!");
+        exit(EXIT_FAILURE);
+    }
+    while ((d = readdir(dir)) != NULL) {
+        if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0)) {
+            continue;
+        }
+        sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+        fp = fopen(filepath, "r");
+        if (fp != NULL) {
+            fread(filetext, 1, FILE_LEN, fp);
+            filetext[FILE_LEN-1]='\0';
+            for (index = 0; index < nr_pids; index++) {
+                if (filetext == strstr(filetext, procName[index])) {
+                    pids[index]=atoi(d->d_name);
+                }
+            }
+            fclose(fp);
+        }
+    }
+    closedir(dir);
+    return 0;
+}
+
+int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
+{
+    int index;
+    for (index = 0; index < MAX_PROC_NUM; index++) {
+        pids[index] = 0;
+        colors[index] = 0;
+        retval[index] = 0;
+    }
+    return 0;
+}
+
+int clear_record(int nr_pids, int spaceFlag, int cmdLen, char *str)
+{
+    nr_pids = 0;
+    spaceFlag = 1;
+    cmdLen = 0;
+    memset(str, 0, strlen(str));
+    return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
+{
+    int index;
+    printf("**************************************************************************\n");
+    for (index = 0; index < nr_pids; index++) {
+        if (pids[index] == 0) {
+            printf("Process %s does not exist\n", procName[index]);
+        } else {
+            printf("[%d]",index);
+            printf("process name:%s      ", procName[index]);
+            printf("pid:%d      ",pids[index]);
+            printf("color:%d     ",colors[index]);
+            printf("set status:%d\n",retval[index]);
+        }
+    }
+    printf("**************************************************************************\n");
+}
+
+int main(int argc,const char **argv)
+{
+    char *str;
+    char *cmdName;
+    char *procName[MAX_PROC_NUM];
+    char *tmp;
+    char inputChar;
+    int nr_pids = 0;
+    int retval[MAX_PROC_NUM];
+    int cmdLen = 0;
+    int spaceFlag = 1;
+    u_int16_t colors[MAX_PROC_NUM];
+    pid_t pids[MAX_PROC_NUM];
+    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN);
+    if (str == NULL) {
+        perror("Failed to allocate for str");
+        exit(EXIT_FAILURE);
+    }
+    printf("********You can now use only getcolors command.********\n\n");
+    while (1) {
+        inputChar = getchar();
+        if (inputChar == '\n') {
+            if (cmdLen > MAX_CMD_LEN) {
+                clear_record(nr_pids, spaceFlag, cmdLen, str);
+                printf("Your command is too long!\n");
+                continue;
+            }
+            init_arrays(pids, colors, retval);
+            cmdName = strtok(str, " \n");
+            if (strcmp(cmdName, "getcolors") == 0 ) {
+                while ((tmp = strtok(NULL, " \n")) != NULL) {
+                    procName[nr_pids] = tmp;
+                    nr_pids++;
+                }
+                find_pid_by_name(nr_pids, procName, pids);
+                if (nr_pids == 0) {
+                    printf("Please provide the name of a process\n");
+                    clear_record(nr_pids, spaceFlag, cmdLen, str);
+                    continue;
+                }
+                syscall(251, nr_pids, pids, colors, retval);
+                print_cmd_info(nr_pids, pids, colors, retval, procName);
+            } else if (strcmp(cmdName, "exit") == 0) {
+                clear_record(nr_pids, spaceFlag, cmdLen, str);
+                free(str);
+                exit(0);
+            } else {
+                printf("Wrong command!\n");
+            }
+            clear_record(nr_pids, spaceFlag, cmdLen, str);
+        } else {
+            cmdLen++;
+            if (cmdLen > MAX_CMD_LEN) {
+                memset(str, 0, strlen(str));
+                continue;
+            }
+            if (spaceFlag == 0) {
+                strncat(str, &inputChar, 1);
+                if (inputChar == ' ') {
+                    spaceFlag = 1;
+                }
+            } else {
+                if (inputChar != ' ') {
+                    strncat(str, &inputChar, 1);
+                    spaceFlag = 0;
+                }
+            }
+        }
+    }
+    free(str);
+    return 0;
+}
+
diff --git a/test_setcolors.c b/test_setcolors.c
new file mode 100644
index 0000000..fc4f86c
--- /dev/null
+++ b/test_setcolors.c
@@ -0,0 +1,180 @@
+/******************************************************
+ *This is a test program that is used to test setcolors
+ ******************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+
+#define MAX_CMD_LEN 100
+#define MAX_CMD_NAME_LEN 50
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_set_colors 223
+
+//_syscall4(int, set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+    struct dirent *d;
+    FILE *fp;
+    DIR *dir;
+    char filepath[FILE_LEN];
+    char filetext[FILE_LEN];
+    int index;
+    dir = opendir("/proc");
+    if (!dir) {
+        perror("Open proc directory failed!");
+        exit(EXIT_FAILURE);
+    }
+    while ((d = readdir(dir)) != NULL) {
+        if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0)) {
+            continue;
+        }
+        sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+        fp = fopen(filepath, "r");
+        if (fp != NULL) {
+            fread(filetext, 1, FILE_LEN, fp);
+            filetext[FILE_LEN-1]='\0';
+            for (index = 0; index < nr_pids; index++) {
+                if (filetext == strstr(filetext, procName[index])) {
+                    pids[index]=atoi(d->d_name);
+                }
+            }
+            fclose(fp);
+        }
+    }
+    closedir(dir);
+    return 0;
+}
+
+int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
+{
+    int index;
+    for (index = 0; index < MAX_PROC_NUM; index++) {
+        pids[index] = 0;
+        colors[index] = 0;
+        retval[index] = 0;
+    }
+    return 0;
+}
+
+int clear_record(int nr_pids, int procNo, int colorNo, int spaceFlag, int cmdLen, char *str)
+{
+    nr_pids = 0;
+    procNo = 0;
+    colorNo = 0;
+    spaceFlag = 1;
+    cmdLen = 0;
+    memset(str, 0, strlen(str));
+    return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
+{
+    int index;
+    printf("**************This output does not indicate set_colors works!*************\n");
+    for (index = 0; index < nr_pids; index++) {
+        if (pids[index] == 0) {
+            printf("Process %s does not exist\n", procName[index]);
+        } else {
+            printf("[%d]",index);
+            printf("process name:%s      ", procName[index]);
+            printf("pid:%d      ",pids[index]);
+            printf("color:%d     ",colors[index]);
+            printf("set status:%d\n",retval[index]);
+        }
+    }
+    printf("**************************************************************************\n");
+}
+
+int main(int argc,const char **argv)
+{
+    char *str;
+    char *cmdName;
+    char *procName[MAX_PROC_NUM];
+    char *tmp;
+    char inputChar;
+    int nr_pids;
+    int retval[MAX_PROC_NUM];
+    int cmdLen = 0;
+    int index;
+    int colorNo = 0;
+    int procNo = 0;
+    int spaceFlag = 1;
+    u_int16_t colors[MAX_PROC_NUM];
+    pid_t pids[MAX_PROC_NUM];
+    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN); 
+    if (str == NULL) {
+        perror("Failed to allocate for str");
+        exit(EXIT_FAILURE);
+    }
+    cmdName = (char*)malloc(sizeof(char)*MAX_CMD_NAME_LEN);
+    printf("********You can now use only setcolors command.********\n\n);
+    while (1) {
+        inputChar = getchar();
+        if (inputChar == '\n') {
+            if (cmdLen > MAX_CMD_LEN) {
+                clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
+                printf("Your command is too long!\n");
+                continue;
+            }
+            init_arrays(pids, colors, retval);
+            cmdName = strtok(str, " \n");
+            if (strcmp(cmdName, "setcolors") == 0 ) {
+		index = 1;
+		while ((tmp = strtok(NULL, " \n")) != NULL) {
+                if (index % 2 == 1 ) {
+                    procName[procNo] = tmp;
+                    procNo++;
+                } else {
+                    colors[colorNo] = atoi(tmp);;
+                    colorNo++;
+                }
+                index++;
+            }
+            if (procNo == colorNo && procNo != 0 ) {
+                nr_pids = procNo;
+            } else {
+                if (procNo == 0) {
+                    printf("Please provide the name of a process\n");
+                } else {
+                    printf("The number of processes and colors must be indentical!\n");
+                }
+                clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
+                continue;
+            }
+            find_pid_by_name(nr_pids, procName, pids);
+            print_cmd_info(nr_pids, pids, colors, retval, procName);
+            syscall(223, nr_pids, pids, colors, retval);
+            } else if (strcmp(cmdName, "exit") == 0) {
+		free(str);
+		clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
+		exit(0);
+	    } else {
+		printf("Wrong command!\n");
+	    }
+            clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
+            } else {
+            cmdLen++;
+            if (cmdLen > MAX_CMD_LEN) {
+                memset(str, 0, strlen(str));
+                continue;
+            }
+            if (spaceFlag == 0) {
+                strncat(str, &inputChar, 1);
+                if (inputChar == ' ') {
+                    spaceFlag = 1;
+                }
+            } else {
+                if (inputChar != ' ') {
+                    strncat(str, &inputChar, 1);
+                    spaceFlag = 0;
+                }
+            }
+        }
+    }
+    free(str);
+    return 0;
+}
-- 
1.7.9.5


From a9da857f6f2706a076647356df2b60942084c44e Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Mon, 25 Feb 2013 23:15:35 -0500
Subject: [PATCH 17/64] Fixed bugs that some flags cannot be cleared after
 each command.

---
 test_getcolors.c |   29 ++++++++++--------
 test_setcolors.c |   89 +++++++++++++++++++++++++++---------------------------
 2 files changed, 61 insertions(+), 57 deletions(-)

diff --git a/test_getcolors.c b/test_getcolors.c
index 9fbd304..45b9e94 100644
--- a/test_getcolors.c
+++ b/test_getcolors.c
@@ -60,15 +60,6 @@ int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
     return 0;
 }
 
-int clear_record(int nr_pids, int spaceFlag, int cmdLen, char *str)
-{
-    nr_pids = 0;
-    spaceFlag = 1;
-    cmdLen = 0;
-    memset(str, 0, strlen(str));
-    return 0;
-}
-
 void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
 {
     int index;
@@ -110,7 +101,9 @@ int main(int argc,const char **argv)
         inputChar = getchar();
         if (inputChar == '\n') {
             if (cmdLen > MAX_CMD_LEN) {
-                clear_record(nr_pids, spaceFlag, cmdLen, str);
+                spaceFlag = 1;
+                cmdLen = 0;
+                memset(str, 0, strlen(str));
                 printf("Your command is too long!\n");
                 continue;
             }
@@ -124,19 +117,28 @@ int main(int argc,const char **argv)
                 find_pid_by_name(nr_pids, procName, pids);
                 if (nr_pids == 0) {
                     printf("Please provide the name of a process\n");
-                    clear_record(nr_pids, spaceFlag, cmdLen, str);
+                    nr_pids = 0;
+                    spaceFlag = 1;
+                    cmdLen = 0;
+                    memset(str, 0, strlen(str));
                     continue;
                 }
                 syscall(251, nr_pids, pids, colors, retval);
                 print_cmd_info(nr_pids, pids, colors, retval, procName);
             } else if (strcmp(cmdName, "exit") == 0) {
-                clear_record(nr_pids, spaceFlag, cmdLen, str);
+                nr_pids = 0;
+                spaceFlag = 1;
+                cmdLen = 0;
+                memset(str, 0, strlen(str));
                 free(str);
                 exit(0);
             } else {
                 printf("Wrong command!\n");
             }
-            clear_record(nr_pids, spaceFlag, cmdLen, str);
+            nr_pids = 0;
+            spaceFlag = 1;
+            cmdLen = 0;
+            memset(str, 0, strlen(str));
         } else {
             cmdLen++;
             if (cmdLen > MAX_CMD_LEN) {
@@ -160,3 +162,4 @@ int main(int argc,const char **argv)
     return 0;
 }
 
+
diff --git a/test_setcolors.c b/test_setcolors.c
index fc4f86c..2f59f08 100644
--- a/test_setcolors.c
+++ b/test_setcolors.c
@@ -60,17 +60,6 @@ int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
     return 0;
 }
 
-int clear_record(int nr_pids, int procNo, int colorNo, int spaceFlag, int cmdLen, char *str)
-{
-    nr_pids = 0;
-    procNo = 0;
-    colorNo = 0;
-    spaceFlag = 1;
-    cmdLen = 0;
-    memset(str, 0, strlen(str));
-    return 0;
-}
-
 void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
 {
     int index;
@@ -105,57 +94,68 @@ int main(int argc,const char **argv)
     int spaceFlag = 1;
     u_int16_t colors[MAX_PROC_NUM];
     pid_t pids[MAX_PROC_NUM];
-    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN); 
+    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN);
     if (str == NULL) {
         perror("Failed to allocate for str");
         exit(EXIT_FAILURE);
     }
-    cmdName = (char*)malloc(sizeof(char)*MAX_CMD_NAME_LEN);
-    printf("********You can now use only setcolors command.********\n\n);
+    printf("********You can now use only setcolors command.********\n\n");
     while (1) {
         inputChar = getchar();
         if (inputChar == '\n') {
             if (cmdLen > MAX_CMD_LEN) {
-                clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
+		spaceFlag = 1;
+                cmdLen = 0;
+                memset(str, 0, strlen(str));
                 printf("Your command is too long!\n");
+                printf("%d\n", cmdLen);
                 continue;
             }
             init_arrays(pids, colors, retval);
             cmdName = strtok(str, " \n");
             if (strcmp(cmdName, "setcolors") == 0 ) {
-		index = 1;
-		while ((tmp = strtok(NULL, " \n")) != NULL) {
-                if (index % 2 == 1 ) {
-                    procName[procNo] = tmp;
-                    procNo++;
-                } else {
-                    colors[colorNo] = atoi(tmp);;
-                    colorNo++;
+                index = 1;
+                while ((tmp = strtok(NULL, " \n")) != NULL) {
+                    if (index % 2 == 1 ) {
+                        procName[procNo] = tmp;
+                        procNo++;
+                    } else {
+                        colors[colorNo] = atoi(tmp);;
+                        colorNo++;
+                    }
+                    index++;
                 }
-                index++;
-            }
-            if (procNo == colorNo && procNo != 0 ) {
-                nr_pids = procNo;
-            } else {
-                if (procNo == 0) {
-                    printf("Please provide the name of a process\n");
+                if (procNo == colorNo && procNo != 0 ) {
+                    nr_pids = procNo;
                 } else {
-                    printf("The number of processes and colors must be indentical!\n");
+                    if (procNo == 0) {
+                        printf("Please provide the name of a process\n");
+                    } else {
+                        printf("The number of processes and colors must be indentical!\n");
+                    }
+                    nr_pids = 0;
+                    procNo = 0;
+                    colorNo = 0;
+                    spaceFlag = 1;
+                    cmdLen = 0;
+                    memset(str, 0, strlen(str));
+                    continue;
                 }
-                clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
-                continue;
-            }
-            find_pid_by_name(nr_pids, procName, pids);
-            print_cmd_info(nr_pids, pids, colors, retval, procName);
-            syscall(223, nr_pids, pids, colors, retval);
+                find_pid_by_name(nr_pids, procName, pids);
+                print_cmd_info(nr_pids, pids, colors, retval, procName);
+                syscall(223, nr_pids, pids, colors, retval);
             } else if (strcmp(cmdName, "exit") == 0) {
-		free(str);
-		clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
-		exit(0);
-	    } else {
-		printf("Wrong command!\n");
-	    }
-            clear_record(nr_pids, procNo, colorNo, spaceFlag, cmdLen, str);
+                free(str);
+                exit(0);
+            } else {
+                printf("Wrong command!\n");
+            }
+            nr_pids = 0;
+            procNo = 0;
+            colorNo = 0;
+            spaceFlag = 1;
+            cmdLen = 0;
+            memset(str, 0, strlen(str));
             } else {
             cmdLen++;
             if (cmdLen > MAX_CMD_LEN) {
@@ -178,3 +178,4 @@ int main(int argc,const char **argv)
     free(str);
     return 0;
 }
+
-- 
1.7.9.5


From af826e6bbed6575ea2400d7b89a9bcde0d5c43e2 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Tue, 26 Feb 2013 14:00:48 -0500
Subject: [PATCH 18/64] added two header files:unistd.h and sys/syscall.h

---
 test_getcolors.c |    5 +++--
 test_setcolors.c |    5 +++--
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/test_getcolors.c b/test_getcolors.c
index 45b9e94..8ef6822 100644
--- a/test_getcolors.c
+++ b/test_getcolors.c
@@ -6,7 +6,8 @@
 #include <stdlib.h>
 #include <dirent.h>
 #include <sys/types.h>
-
+#include <sys/syscall.h>
+#include <unistd.h>
 #define MAX_CMD_LEN 100
 #define MAX_CMD_NAME_LEN 50
 #define MAX_PROC_NUM 20
@@ -123,7 +124,7 @@ int main(int argc,const char **argv)
                     memset(str, 0, strlen(str));
                     continue;
                 }
-                syscall(251, nr_pids, pids, colors, retval);
+                syscall(__NR_get_colors, nr_pids, pids, colors, retval);
                 print_cmd_info(nr_pids, pids, colors, retval, procName);
             } else if (strcmp(cmdName, "exit") == 0) {
                 nr_pids = 0;
diff --git a/test_setcolors.c b/test_setcolors.c
index 2f59f08..42d17a6 100644
--- a/test_setcolors.c
+++ b/test_setcolors.c
@@ -6,7 +6,8 @@
 #include <stdlib.h>
 #include <dirent.h>
 #include <sys/types.h>
-
+#include <sys/syscall.h>
+#include <unistd.h>
 #define MAX_CMD_LEN 100
 #define MAX_CMD_NAME_LEN 50
 #define MAX_PROC_NUM 20
@@ -143,7 +144,7 @@ int main(int argc,const char **argv)
                 }
                 find_pid_by_name(nr_pids, procName, pids);
                 print_cmd_info(nr_pids, pids, colors, retval, procName);
-                syscall(223, nr_pids, pids, colors, retval);
+                syscall(__NR_set_colors, nr_pids, pids, colors, retval);
             } else if (strcmp(cmdName, "exit") == 0) {
                 free(str);
                 exit(0);
-- 
1.7.9.5


From 1441f5ba19e5a5b20f56408f1f3186bd7c9529e9 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Tue, 26 Feb 2013 14:20:45 -0500
Subject: [PATCH 19/64] Added test.c that can test both setcolors and
 getcolors

---
 test.c |  207 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 207 insertions(+)
 create mode 100644 test.c

diff --git a/test.c b/test.c
new file mode 100644
index 0000000..3d87619
--- /dev/null
+++ b/test.c
@@ -0,0 +1,207 @@
+/*********************************************************************
+ *This is a test program that is used to test setcolors and getcolors
+ *********************************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#define MAX_CMD_LEN 100
+#define MAX_CMD_NAME_LEN 50
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_set_colors 223
+#define __NR_get_colors 251
+
+//_syscall4(int, set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
+//_syscall4(int, get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
+
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+    struct dirent *d;
+    FILE *fp;
+    DIR *dir;
+    char filepath[FILE_LEN];
+    char filetext[FILE_LEN];
+    int index;
+    dir = opendir("/proc");
+    if (!dir) {
+        perror("Open proc directory failed!");
+        exit(EXIT_FAILURE);
+    }
+    while ((d = readdir(dir)) != NULL) {
+        if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0)) {
+            continue;
+        }
+        sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+        fp = fopen(filepath, "r");
+        if (fp != NULL) {
+            fread(filetext, 1, FILE_LEN, fp);
+            filetext[FILE_LEN-1]='\0';
+            for (index = 0; index < nr_pids; index++) {
+                if (filetext == strstr(filetext, procName[index])) {
+                    pids[index]=atoi(d->d_name);
+                }
+            }
+            fclose(fp);
+        }
+    }
+    closedir(dir);
+    return 0;
+}
+
+int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
+{
+    int index;
+    for (index = 0; index < MAX_PROC_NUM; index++) {
+        pids[index] = 0;
+        colors[index] = 0;
+        retval[index] = 0;
+    }
+    return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
+{
+    int index;
+    printf("\n**************************************************************************\n");
+    for (index = 0; index < nr_pids; index++) {
+        if (pids[index] == 0) {
+            printf("Process %s does not exist\n", procName[index]);
+        } else {
+            printf("[%d]",index);
+            printf("process name:%s      ", procName[index]);
+            printf("pid:%d      ",pids[index]);
+            printf("color:%d     ",colors[index]);
+            printf("set status:%d\n",retval[index]);
+        }
+    }
+    printf("**************************************************************************\n\n");
+}
+
+int main(int argc,const char **argv)
+{
+    char *str;
+    char *cmdName;
+    char *procName[MAX_PROC_NUM];
+    char *tmp;
+    char inputChar;
+    int nr_pids;
+    int retval[MAX_PROC_NUM];
+    int cmdLen = 0;
+    int index;
+    int colorNo = 0;
+    int procNo = 0;
+    int spaceFlag = 1;
+    u_int16_t colors[MAX_PROC_NUM];
+    pid_t pids[MAX_PROC_NUM];
+    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN);
+    if (str == NULL) {
+        perror("Failed to allocate for str");
+        exit(EXIT_FAILURE);
+    }
+    cmdName = (char*)malloc(sizeof(char)*MAX_CMD_NAME_LEN);
+    printf("********You can now use setcolors and getcolors command.********\n\n");
+    while (1) {
+        inputChar = getchar();
+        if (inputChar == '\n') {
+            if (cmdLen > MAX_CMD_LEN) {
+                spaceFlag = 1;
+                cmdLen = 0;
+                memset(str, 0, strlen(str));
+                printf("Your command is too long!\n");
+                continue;
+            } else if (cmdLen == 0) {
+                continue;
+            }
+            init_arrays(pids, colors, retval);
+            cmdName = strtok(str, " \n");
+            if (strcmp(cmdName, "setcolors") == 0 ) {
+                index = 1;
+                while ((tmp = strtok(NULL, " \n")) != NULL) {
+                    if (index % 2 == 1 ) {
+                        procName[procNo] = tmp;
+                        procNo++;
+                    } else {
+                        colors[colorNo] = atoi(tmp);;
+                        colorNo++;
+                    }
+                    index++;
+                }
+                if (procNo == colorNo && procNo != 0 ) {
+                    nr_pids = procNo;
+                } else {
+                    if (procNo == 0) {
+                        printf("Please provide the name of a process\n");
+                    } else {
+                        printf("The number of processes and colors must be indentical!\n");
+                    }
+                    nr_pids = 0;
+                    procNo = 0;
+                    colorNo = 0;
+                    spaceFlag = 1;
+                    cmdLen = 0;
+                    memset(str, 0, strlen(str));
+                    continue;
+                }
+                find_pid_by_name(nr_pids, procName, pids);
+                print_cmd_info(nr_pids, pids, colors, retval, procName);
+                syscall(__NR_set_colors, nr_pids, pids, colors, retval);
+            } else if (strcmp(cmdName, "getcolors") == 0 ) {
+                while ((tmp = strtok(NULL, " \n")) != NULL) {
+                    procName[nr_pids] = tmp;
+                    nr_pids++;
+                }
+                find_pid_by_name(nr_pids, procName, pids);
+                if (nr_pids == 0) {
+                    printf("Please provide the name of a process\n");
+                    nr_pids = 0;
+                    procNo = 0;
+                    colorNo = 0;
+                    spaceFlag = 1;
+                    cmdLen = 0;
+                    memset(str, 0, strlen(str));
+                    continue;
+                }
+                syscall(__NR_get_colors, nr_pids, pids, colors, retval);
+                print_cmd_info(nr_pids, pids, colors, retval, procName);
+            } else if (strcmp(cmdName, "exit") == 0) {
+                free(str);
+                exit(0);
+            } else {
+                printf("Wrong command!\n");
+            }
+            nr_pids = 0;
+            procNo = 0;
+            colorNo = 0;
+            spaceFlag = 1;
+            cmdLen = 0;
+            memset(str, 0, strlen(str));
+        } else {
+            cmdLen++;
+            if (cmdLen > MAX_CMD_LEN) {
+                memset(str, 0, strlen(str));
+                continue;
+            }
+            if (spaceFlag == 0) {
+                strncat(str, &inputChar, 1);
+                if (inputChar == ' ') {
+                    spaceFlag = 1;
+                }
+            } else {
+                if (inputChar != ' ') {
+                    strncat(str, &inputChar, 1);
+                    spaceFlag = 0;
+                }
+            }
+        }
+    }
+    free(str);
+    return 0;
+}
+
+
+
-- 
1.7.9.5


From bd4526b2414d3ccc46c10e6cbbc343e85c4338a9 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 26 Feb 2013 21:05:53 -0500
Subject: [PATCH 20/64] system calls now check for root user. -added access_ok
 checks. -added convienent variables for array size.

---
 kernel/color.c |  107 +++++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 86 insertions(+), 21 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 020db32..70d2f03 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -1,3 +1,4 @@
+#include <linux/cred.h>
 #include <linux/errno.h>
 #include <linux/linkage.h>
 #include <linux/sched.h>
@@ -39,6 +40,7 @@ int get_color(pid_t pid)
 		return crnt_tsk->color;
 }
 
+
 /*
  * TODO
  */
@@ -48,28 +50,41 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 	pid_t *k_pids;
 	u_int16_t *k_colors;
 	int i;
-	int mem_ret;
 	int *k_retval;
 	int ret_value;
 	unsigned long bytes_copied;
-	/* Must have root privledges, TODO */
+
+	size_t pids_size;
+	size_t colors_size;
+	size_t retval_size;
+
+	pids_size = sizeof(pid_t) * nr_pids;
+	colors_size = sizeof(u_int16_t) * nr_pids;
+	retval_size = sizeof(int) * nr_pids;
+
+	/* Must have root privledges */
+	if (current_uid() != 0) {
+		printk("User must be root.\n");
+		return -EACCES;
+	}
 
 	k_pids = NULL;
 	k_colors = NULL;
 	k_retval = NULL;
 
-	k_pids = kmalloc(sizeof(pid_t *) * nr_pids, GFP_KERNEL);
+	/* Allocate memory for all needed arrays. */
+	k_pids = kmalloc(pids_size, GFP_KERNEL);
 	if (k_pids == NULL) {
 		printk("Failed to kallocate for k_pids\n");
 		return -EINVAL;
 	}
-	k_colors = kmalloc(sizeof(u_int16_t) * nr_pids, GFP_KERNEL);
+	k_colors = kmalloc(colors_size, GFP_KERNEL);
 	if (k_colors == NULL) {
 		printk("Failed to kallocate for k_colors\n");
 		kfree(k_pids);
 		return -EINVAL;
 	}
-	k_retval = kmalloc(sizeof(int) * nr_pids, GFP_KERNEL);
+	k_retval = kmalloc(retval_size, GFP_KERNEL);
 	if (k_retval == NULL) {
 		printk("Failed to kallocate for k_retval\n");
 		kfree(k_pids);
@@ -77,8 +92,13 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 		return -EINVAL;
 	}
 
-	bytes_copied = copy_from_user(k_colors, colors, sizeof(u_int16_t) *
-			nr_pids);
+	/* Copy the data from user space. */
+	if (access_ok(VERIFY_READ, colors, pids_size) == 0) {
+		printk("Colors not ok to read from user space.");
+		bytes_copied = 1;
+	} else {
+		bytes_copied = copy_from_user(k_colors, colors, colors_size);
+	}
 	if (bytes_copied != 0) {
 		printk("Failed to copy bytes for k_bytes\n");
 		kfree(k_pids);
@@ -86,8 +106,12 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 		kfree(k_retval);
 		return -EINVAL;
 	}
-
-	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
+	if (access_ok(VERIFY_READ, pids, pids_size) == 0) {
+		printk("pids not ok to read from user space\n");
+		bytes_copied = 1;
+	} else {
+		bytes_copied = copy_from_user(k_pids, pids, pids_size);
+	}
 	if (bytes_copied != 0) {
 		printk("Failed to copy bytes for k_pids\n");
 		kfree(k_pids);
@@ -102,9 +126,18 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 			ret_value = k_retval[i];
 	}
 
-	bytes_copied = copy_to_user(retval, k_retval, sizeof(pid_t) * nr_pids);
-	if (bytes_copied != 0)
+	if (access_ok(VERIFY_WRITE, retval, retval_size) == 0) {
+		printk("retval not ok to write.\n");
+		bytes_copied = 1;
+	} else {
+		bytes_copied = copy_to_user(retval, k_retval, retval_size);
+	}
+	if (bytes_copied != 0) {
+		kfree(k_pids);
+		kfree(k_colors);
+		kfree(k_retval);
 		ret_value = -EINVAL;
+	}
 
 	kfree(k_pids);
 	kfree(k_colors);
@@ -125,34 +158,53 @@ asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 	u_int16_t *k_colors;
 	u_int16_t color_return;
 	int i;
-	int mem_ret;
 	int *k_retval;
 	int ret_value;
 	unsigned long bytes_copied;
 
+	size_t pids_size;
+	size_t colors_size;
+	size_t retval_size;
+
+	pids_size = sizeof(pid_t) * nr_pids;
+	colors_size = sizeof(u_int16_t) * nr_pids;
+	retval_size = sizeof(int) * nr_pids;
+
+	/* Must be root. */
+	if (current_uid() != 0) {
+		printk("Must be root to get colors.\n");
+		return -EACCES;
+	}
+
 	k_pids = NULL;
 	k_colors = NULL;
 	k_retval = NULL;
 
-	k_pids = kmalloc(sizeof(pid_t *) * nr_pids, GFP_KERNEL);
+	k_pids = kmalloc(pids_size, GFP_KERNEL);
 	if (k_pids == NULL) {
 		printk("Failed to kallocate for k_pids\n");
 		return -EINVAL;
 	}
-	k_colors = kmalloc(sizeof(u_int16_t) * nr_pids, GFP_KERNEL);
+	k_colors = kmalloc(colors_size, GFP_KERNEL);
 	if (k_colors == NULL) {
 		printk("Failed to kallocate for k_colors\n");
 		kfree(k_pids);
 		return -EINVAL;
 	}
-	k_retval = kmalloc(sizeof(int) * nr_pids, GFP_KERNEL);
+	k_retval = kmalloc(retval_size, GFP_KERNEL);
 	if (k_retval == NULL) {
 		printk("Failed to kallocate for k_retval\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		return -EINVAL;
 	}
-	bytes_copied = copy_from_user(k_pids, pids, sizeof(pid_t) * nr_pids);
+
+	if (access_ok(VERIFY_READ, pids, pids_size) == 0) {
+		printk("pids not ok to read.\n");
+		bytes_copied = 1;
+	} else {
+		bytes_copied = copy_from_user(k_pids, pids, pids_size);
+	}
 	if (bytes_copied != 0) {
 		kfree(k_pids);
 		kfree(k_colors);
@@ -173,12 +225,25 @@ asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 		}
 	}
 
-	bytes_copied = copy_to_user(retval, k_retval, sizeof(pid_t) * nr_pids);
-	bytes_copied = copy_to_user(colors, k_colors, sizeof(u_int16_t *) *
-			nr_pids);
+	if (access_ok(VERIFY_WRITE, retval, retval_size) == 0) {
+		printk("retval not ok to write.\n");
+		bytes_copied = 1;
+	} else {
+		bytes_copied = copy_to_user(retval, k_retval, retval_size);
+	}
+	if (bytes_copied != 0) {
+		kfree(k_pids);
+		kfree(k_colors);
+		kfree(k_retval);
+		return -EINVAL;
+	}
 
-	if (bytes_copied != 0)
-		ret_value = -EINVAL;
+	if (access_ok(VERIFY_WRITE, colors, colors_size) == 0) {
+		printk("colors not ok to write.");
+		bytes_copied = 1;
+	} else {
+		bytes_copied = copy_to_user(colors, k_colors, colors_size);
+	}
 
 	kfree(k_pids);
 	kfree(k_colors);
-- 
1.7.9.5


From 018427661f91e85b1f2420c78879071323b11648 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 26 Feb 2013 22:16:36 -0500
Subject: [PATCH 21/64] -added locks to the set color. -added a function to
 set all of the processes in a group to a given color.
 -we need to read more about the different types of
 locks.  I think right now I'm blocking too much.

---
 kernel/color.c |   54 ++++++++++++++++++++++++++++++++++++++++++++++--------
 1 file changed, 46 insertions(+), 8 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 70d2f03..9a44e67 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -6,25 +6,56 @@
 #include <linux/uaccess.h>
 #include <linux/types.h>
 
+/**
+ * TODO: Look into locking and thread traversal.
+ */
+int set_tg_color(pid_t tgid, u_int16_t color)
+{
+	/* TODO - look at locks*/
+	struct task_struct *p;
+	write_lock(&tasklist_lock);
+	for_each_process(p) {
+		if (p->tgid == tgid)
+			p->color = color;
+	}
+
+	write_unlock(&tasklist_lock);
+
+	return 0;
+}
+
 /*
  * Sets the color of the pid to color.  Will also propogate the color to all
- * other processes in the thread group.  Returns 0 if successful and -EINVAL
+ * other processes in the thread group.  Returns tgid if success full and -1
  * if unsucessful.
+ * Note: look into for_each_process and do_each_thread for propogation.
  */
 int set_color(pid_t pid, u_int16_t color)
 {
 	struct task_struct *crnt_tsk;
+	int return_val;
+
+	/* lock the task list
+	 * In the linux source code it says that find_task_by_pid can be
+	 * called using rcu_read_lock so I may be locking too much and
+	 * need to give it some thought.
+	 * */
+	write_lock(&tasklist_lock);
 	crnt_tsk = find_task_by_vpid(pid);
 	if (crnt_tsk == NULL) {
-		return -EINVAL;
+		write_unlock(&tasklist_lock);
+		return_val = -EINVAL;
 	} else {
 		/* Set the color */
-		printk("Setting %d color: %d\n", pid, color);
 		crnt_tsk->color = color;
-		/* Propogate to threads */
+		return_val = crnt_tsk->tgid;
+		write_unlock(&tasklist_lock);
+		printk("Setting %d color: %d\n", pid, color);
 		printk("crnttsk color = %d\n", crnt_tsk->color);
-		return 0;
 	}
+	/* unlock the task list */
+
+	return return_val;
 }
 
 /*
@@ -47,6 +78,7 @@ int get_color(pid_t pid)
 asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 		int *retval)
 {
+	pid_t tgid;
 	pid_t *k_pids;
 	u_int16_t *k_colors;
 	int i;
@@ -121,9 +153,15 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 	}
 	ret_value = 0;
 	for (i = 0; i < nr_pids; i++) {
-		k_retval[i] = set_color(k_pids[i], k_colors[i]);
-		if (k_retval[i] != 0)
-			ret_value = k_retval[i];
+		tgid = set_color(k_pids[i], k_colors[i]);
+		if (tgid < 0) {
+			ret_value = -EINVAL;
+			k_retval[i] = -EINVAL;
+		} else {
+			k_retval[i] = 0;
+			if (set_tg_color(tgid, k_colors[i]) < 0)
+				ret_value = -EINVAL;
+		}
 	}
 
 	if (access_ok(VERIFY_WRITE, retval, retval_size) == 0) {
-- 
1.7.9.5


From 5aae8d0bfaed3c2445bc2ed48c5915c3224699c5 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Tue, 26 Feb 2013 22:21:05 -0500
Subject: [PATCH 22/64] modified two test programs to meet Linux coding style

---
 test.c           |  207 ---------------------------------------------
 test_getcolors.c |  187 +++++++++++++----------------------------
 test_setcolors.c |  247 ++++++++++++++++++++----------------------------------
 3 files changed, 148 insertions(+), 493 deletions(-)
 delete mode 100644 test.c

diff --git a/test.c b/test.c
deleted file mode 100644
index 3d87619..0000000
--- a/test.c
+++ /dev/null
@@ -1,207 +0,0 @@
-/*********************************************************************
- *This is a test program that is used to test setcolors and getcolors
- *********************************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-#define MAX_CMD_LEN 100
-#define MAX_CMD_NAME_LEN 50
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-#define __NR_set_colors 223
-#define __NR_get_colors 251
-
-//_syscall4(int, set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
-//_syscall4(int, get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
-
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-    struct dirent *d;
-    FILE *fp;
-    DIR *dir;
-    char filepath[FILE_LEN];
-    char filetext[FILE_LEN];
-    int index;
-    dir = opendir("/proc");
-    if (!dir) {
-        perror("Open proc directory failed!");
-        exit(EXIT_FAILURE);
-    }
-    while ((d = readdir(dir)) != NULL) {
-        if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0)) {
-            continue;
-        }
-        sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-        fp = fopen(filepath, "r");
-        if (fp != NULL) {
-            fread(filetext, 1, FILE_LEN, fp);
-            filetext[FILE_LEN-1]='\0';
-            for (index = 0; index < nr_pids; index++) {
-                if (filetext == strstr(filetext, procName[index])) {
-                    pids[index]=atoi(d->d_name);
-                }
-            }
-            fclose(fp);
-        }
-    }
-    closedir(dir);
-    return 0;
-}
-
-int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
-{
-    int index;
-    for (index = 0; index < MAX_PROC_NUM; index++) {
-        pids[index] = 0;
-        colors[index] = 0;
-        retval[index] = 0;
-    }
-    return 0;
-}
-
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
-{
-    int index;
-    printf("\n**************************************************************************\n");
-    for (index = 0; index < nr_pids; index++) {
-        if (pids[index] == 0) {
-            printf("Process %s does not exist\n", procName[index]);
-        } else {
-            printf("[%d]",index);
-            printf("process name:%s      ", procName[index]);
-            printf("pid:%d      ",pids[index]);
-            printf("color:%d     ",colors[index]);
-            printf("set status:%d\n",retval[index]);
-        }
-    }
-    printf("**************************************************************************\n\n");
-}
-
-int main(int argc,const char **argv)
-{
-    char *str;
-    char *cmdName;
-    char *procName[MAX_PROC_NUM];
-    char *tmp;
-    char inputChar;
-    int nr_pids;
-    int retval[MAX_PROC_NUM];
-    int cmdLen = 0;
-    int index;
-    int colorNo = 0;
-    int procNo = 0;
-    int spaceFlag = 1;
-    u_int16_t colors[MAX_PROC_NUM];
-    pid_t pids[MAX_PROC_NUM];
-    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN);
-    if (str == NULL) {
-        perror("Failed to allocate for str");
-        exit(EXIT_FAILURE);
-    }
-    cmdName = (char*)malloc(sizeof(char)*MAX_CMD_NAME_LEN);
-    printf("********You can now use setcolors and getcolors command.********\n\n");
-    while (1) {
-        inputChar = getchar();
-        if (inputChar == '\n') {
-            if (cmdLen > MAX_CMD_LEN) {
-                spaceFlag = 1;
-                cmdLen = 0;
-                memset(str, 0, strlen(str));
-                printf("Your command is too long!\n");
-                continue;
-            } else if (cmdLen == 0) {
-                continue;
-            }
-            init_arrays(pids, colors, retval);
-            cmdName = strtok(str, " \n");
-            if (strcmp(cmdName, "setcolors") == 0 ) {
-                index = 1;
-                while ((tmp = strtok(NULL, " \n")) != NULL) {
-                    if (index % 2 == 1 ) {
-                        procName[procNo] = tmp;
-                        procNo++;
-                    } else {
-                        colors[colorNo] = atoi(tmp);;
-                        colorNo++;
-                    }
-                    index++;
-                }
-                if (procNo == colorNo && procNo != 0 ) {
-                    nr_pids = procNo;
-                } else {
-                    if (procNo == 0) {
-                        printf("Please provide the name of a process\n");
-                    } else {
-                        printf("The number of processes and colors must be indentical!\n");
-                    }
-                    nr_pids = 0;
-                    procNo = 0;
-                    colorNo = 0;
-                    spaceFlag = 1;
-                    cmdLen = 0;
-                    memset(str, 0, strlen(str));
-                    continue;
-                }
-                find_pid_by_name(nr_pids, procName, pids);
-                print_cmd_info(nr_pids, pids, colors, retval, procName);
-                syscall(__NR_set_colors, nr_pids, pids, colors, retval);
-            } else if (strcmp(cmdName, "getcolors") == 0 ) {
-                while ((tmp = strtok(NULL, " \n")) != NULL) {
-                    procName[nr_pids] = tmp;
-                    nr_pids++;
-                }
-                find_pid_by_name(nr_pids, procName, pids);
-                if (nr_pids == 0) {
-                    printf("Please provide the name of a process\n");
-                    nr_pids = 0;
-                    procNo = 0;
-                    colorNo = 0;
-                    spaceFlag = 1;
-                    cmdLen = 0;
-                    memset(str, 0, strlen(str));
-                    continue;
-                }
-                syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-                print_cmd_info(nr_pids, pids, colors, retval, procName);
-            } else if (strcmp(cmdName, "exit") == 0) {
-                free(str);
-                exit(0);
-            } else {
-                printf("Wrong command!\n");
-            }
-            nr_pids = 0;
-            procNo = 0;
-            colorNo = 0;
-            spaceFlag = 1;
-            cmdLen = 0;
-            memset(str, 0, strlen(str));
-        } else {
-            cmdLen++;
-            if (cmdLen > MAX_CMD_LEN) {
-                memset(str, 0, strlen(str));
-                continue;
-            }
-            if (spaceFlag == 0) {
-                strncat(str, &inputChar, 1);
-                if (inputChar == ' ') {
-                    spaceFlag = 1;
-                }
-            } else {
-                if (inputChar != ' ') {
-                    strncat(str, &inputChar, 1);
-                    spaceFlag = 0;
-                }
-            }
-        }
-    }
-    free(str);
-    return 0;
-}
-
-
-
diff --git a/test_getcolors.c b/test_getcolors.c
index 8ef6822..6b898f0 100644
--- a/test_getcolors.c
+++ b/test_getcolors.c
@@ -8,13 +8,11 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
-#define MAX_CMD_LEN 100
-#define MAX_CMD_NAME_LEN 50
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
 #define __NR_get_colors 251
 
-//_syscall4(int, get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
+
 
 int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 {
@@ -26,141 +24,74 @@ int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
     int index;
     dir = opendir("/proc");
     if (!dir) {
-        perror("Open proc directory failed!");
-        exit(EXIT_FAILURE);
+	perror("Open proc directory failed!");
+	exit(EXIT_FAILURE);
     }
     while ((d = readdir(dir)) != NULL) {
-        if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0)) {
-            continue;
-        }
-        sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-        fp = fopen(filepath, "r");
-        if (fp != NULL) {
-            fread(filetext, 1, FILE_LEN, fp);
-            filetext[FILE_LEN-1]='\0';
-            for (index = 0; index < nr_pids; index++) {
-                if (filetext == strstr(filetext, procName[index])) {
-                    pids[index]=atoi(d->d_name);
-                }
-            }
-            fclose(fp);
-        }
+	if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0))
+		continue;
+	sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+	fp = fopen(filepath, "r");
+	if (fp != NULL) {
+		fread(filetext, 1, FILE_LEN, fp);
+		filetext[FILE_LEN-1] = '\0';
+	for (index = 0; index < nr_pids; index++) {
+		if (filetext == strstr(filetext, procName[index]))
+			pids[index] = atoi(d->d_name);
+	}
+	fclose(fp);
+	}
     }
     closedir(dir);
     return 0;
 }
 
-int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
+			int *retval, char *procName[])
 {
-    int index;
-    for (index = 0; index < MAX_PROC_NUM; index++) {
-        pids[index] = 0;
-        colors[index] = 0;
-        retval[index] = 0;
-    }
-    return 0;
+	int index;
+	printf("\n************************************************************
+		**************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (pids[index] == 0)
+			printf("Process %s does not exist\n", procName[index]);
+		else {
+			printf("[%d]", index);
+			printf("process name:%s      ", procName[index]);
+			printf("pid:%d      ", pids[index]);
+			printf("color:%d     ", colors[index]);
+			printf("set status:%d\n", retval[index]);
+			}
+	}
+	printf("**************************************************************
+		************\n\n");
 }
 
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
+int main(int argc, char *argv[])
 {
-    int index;
-    printf("**************************************************************************\n");
-    for (index = 0; index < nr_pids; index++) {
-        if (pids[index] == 0) {
-            printf("Process %s does not exist\n", procName[index]);
-        } else {
-            printf("[%d]",index);
-            printf("process name:%s      ", procName[index]);
-            printf("pid:%d      ",pids[index]);
-            printf("color:%d     ",colors[index]);
-            printf("set status:%d\n",retval[index]);
-        }
-    }
-    printf("**************************************************************************\n");
+	int nr_pids;
+	int retval[MAX_PROC_NUM];
+	int i;
+	char *procName[MAX_PROC_NUM];
+	pid_t pids[MAX_PROC_NUM];
+	u_int16_t colors[MAX_PROC_NUM];
+	if (strcmp(argv[0], "./getcolors") != 0) {
+		printf("Invalid command!\n");
+		return -1;
+	}
+	if (argc == 1) {
+		printf("Please provide a name of a process.\n");
+		return -1;
+	}
+	nr_pids = argc - 1;
+	for (i = 0; i < nr_pids; i++) {
+		procName[i] = argv[i + 1];
+		retval[i] = 0;
+		colors[i] = 0;
+	}
+	find_pid_by_name(nr_pids, procName, pids);
+	syscall(__NR_get_colors, nr_pids, pids, colors, retval);
+	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	return 0;
 }
 
-int main(int argc,const char **argv)
-{
-    char *str;
-    char *cmdName;
-    char *procName[MAX_PROC_NUM];
-    char *tmp;
-    char inputChar;
-    int nr_pids = 0;
-    int retval[MAX_PROC_NUM];
-    int cmdLen = 0;
-    int spaceFlag = 1;
-    u_int16_t colors[MAX_PROC_NUM];
-    pid_t pids[MAX_PROC_NUM];
-    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN);
-    if (str == NULL) {
-        perror("Failed to allocate for str");
-        exit(EXIT_FAILURE);
-    }
-    printf("********You can now use only getcolors command.********\n\n");
-    while (1) {
-        inputChar = getchar();
-        if (inputChar == '\n') {
-            if (cmdLen > MAX_CMD_LEN) {
-                spaceFlag = 1;
-                cmdLen = 0;
-                memset(str, 0, strlen(str));
-                printf("Your command is too long!\n");
-                continue;
-            }
-            init_arrays(pids, colors, retval);
-            cmdName = strtok(str, " \n");
-            if (strcmp(cmdName, "getcolors") == 0 ) {
-                while ((tmp = strtok(NULL, " \n")) != NULL) {
-                    procName[nr_pids] = tmp;
-                    nr_pids++;
-                }
-                find_pid_by_name(nr_pids, procName, pids);
-                if (nr_pids == 0) {
-                    printf("Please provide the name of a process\n");
-                    nr_pids = 0;
-                    spaceFlag = 1;
-                    cmdLen = 0;
-                    memset(str, 0, strlen(str));
-                    continue;
-                }
-                syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-                print_cmd_info(nr_pids, pids, colors, retval, procName);
-            } else if (strcmp(cmdName, "exit") == 0) {
-                nr_pids = 0;
-                spaceFlag = 1;
-                cmdLen = 0;
-                memset(str, 0, strlen(str));
-                free(str);
-                exit(0);
-            } else {
-                printf("Wrong command!\n");
-            }
-            nr_pids = 0;
-            spaceFlag = 1;
-            cmdLen = 0;
-            memset(str, 0, strlen(str));
-        } else {
-            cmdLen++;
-            if (cmdLen > MAX_CMD_LEN) {
-                memset(str, 0, strlen(str));
-                continue;
-            }
-            if (spaceFlag == 0) {
-                strncat(str, &inputChar, 1);
-                if (inputChar == ' ') {
-                    spaceFlag = 1;
-                }
-            } else {
-                if (inputChar != ' ') {
-                    strncat(str, &inputChar, 1);
-                    spaceFlag = 0;
-                }
-            }
-        }
-    }
-    free(str);
-    return 0;
-}
-
-
diff --git a/test_setcolors.c b/test_setcolors.c
index 42d17a6..70a8f96 100644
--- a/test_setcolors.c
+++ b/test_setcolors.c
@@ -8,175 +8,106 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
-#define MAX_CMD_LEN 100
-#define MAX_CMD_NAME_LEN 50
+
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
 #define __NR_set_colors 223
+#define __NR_get_colors 251
 
-//_syscall4(int, set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors, int *, retval)
 
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-    struct dirent *d;
-    FILE *fp;
-    DIR *dir;
-    char filepath[FILE_LEN];
-    char filetext[FILE_LEN];
-    int index;
-    dir = opendir("/proc");
-    if (!dir) {
-        perror("Open proc directory failed!");
-        exit(EXIT_FAILURE);
-    }
-    while ((d = readdir(dir)) != NULL) {
-        if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0)) {
-            continue;
-        }
-        sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-        fp = fopen(filepath, "r");
-        if (fp != NULL) {
-            fread(filetext, 1, FILE_LEN, fp);
-            filetext[FILE_LEN-1]='\0';
-            for (index = 0; index < nr_pids; index++) {
-                if (filetext == strstr(filetext, procName[index])) {
-                    pids[index]=atoi(d->d_name);
-                }
-            }
-            fclose(fp);
-        }
-    }
-    closedir(dir);
-    return 0;
-}
 
-int init_arrays(pid_t *pids, u_int16_t *colors, int *retval)
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 {
-    int index;
-    for (index = 0; index < MAX_PROC_NUM; index++) {
-        pids[index] = 0;
-        colors[index] = 0;
-        retval[index] = 0;
-    }
-    return 0;
+	struct dirent *d;
+	FILE *fp;
+	DIR *dir;
+	char filepath[FILE_LEN];
+	char filetext[FILE_LEN];
+	int index;
+	dir = opendir("/proc");
+	if (!dir) {
+		perror("Open proc directory failed!");
+		exit(EXIT_FAILURE);
+	}
+	while ((d = readdir(dir)) != NULL) {
+		if ((strcmp(d->d_name, ".") == 0) ||
+			(strcmp(d->d_name, "..") == 0))
+			continue;
+		sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+		fp = fopen(filepath, "r");
+		if (fp != NULL) {
+			fread(filetext, 1, FILE_LEN, fp);
+			filetext[FILE_LEN-1] = '\0';
+			for (index = 0; index < nr_pids; index++) {
+				if (filetext == strstr(filetext,
+					 procName[index]))
+					pids[index] = atoi(d->d_name);
+			}
+		fclose(fp);
+		}
+	}
+	closedir(dir);
+	return 0;
 }
 
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors, int *retval, char *procName[])
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
+			int *retval, char *procName[])
 {
-    int index;
-    printf("**************This output does not indicate set_colors works!*************\n");
-    for (index = 0; index < nr_pids; index++) {
-        if (pids[index] == 0) {
-            printf("Process %s does not exist\n", procName[index]);
-        } else {
-            printf("[%d]",index);
-            printf("process name:%s      ", procName[index]);
-            printf("pid:%d      ",pids[index]);
-            printf("color:%d     ",colors[index]);
-            printf("set status:%d\n",retval[index]);
-        }
-    }
-    printf("**************************************************************************\n");
+	int index;
+	printf("**************************************************************
+			************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (pids[index] == 0)
+			printf("Process %s does not exist\n", procName[index]);
+		else {
+			printf("[%d]", index);
+			printf("process name:%s      ", procName[index]);
+			printf("pid:%d      ", pids[index]);
+			printf("color:%d     ", colors[index]);
+			printf("set status:%d\n", retval[index]);
+		}
+	}
+	printf("**************************************************************
+			************\n");
 }
 
-int main(int argc,const char **argv)
+int main(int argc, char *argv[])
 {
-    char *str;
-    char *cmdName;
-    char *procName[MAX_PROC_NUM];
-    char *tmp;
-    char inputChar;
-    int nr_pids;
-    int retval[MAX_PROC_NUM];
-    int cmdLen = 0;
-    int index;
-    int colorNo = 0;
-    int procNo = 0;
-    int spaceFlag = 1;
-    u_int16_t colors[MAX_PROC_NUM];
-    pid_t pids[MAX_PROC_NUM];
-    str = (char*)malloc(sizeof(char)*MAX_CMD_LEN);
-    if (str == NULL) {
-        perror("Failed to allocate for str");
-        exit(EXIT_FAILURE);
-    }
-    printf("********You can now use only setcolors command.********\n\n");
-    while (1) {
-        inputChar = getchar();
-        if (inputChar == '\n') {
-            if (cmdLen > MAX_CMD_LEN) {
-		spaceFlag = 1;
-                cmdLen = 0;
-                memset(str, 0, strlen(str));
-                printf("Your command is too long!\n");
-                printf("%d\n", cmdLen);
-                continue;
-            }
-            init_arrays(pids, colors, retval);
-            cmdName = strtok(str, " \n");
-            if (strcmp(cmdName, "setcolors") == 0 ) {
-                index = 1;
-                while ((tmp = strtok(NULL, " \n")) != NULL) {
-                    if (index % 2 == 1 ) {
-                        procName[procNo] = tmp;
-                        procNo++;
-                    } else {
-                        colors[colorNo] = atoi(tmp);;
-                        colorNo++;
-                    }
-                    index++;
-                }
-                if (procNo == colorNo && procNo != 0 ) {
-                    nr_pids = procNo;
-                } else {
-                    if (procNo == 0) {
-                        printf("Please provide the name of a process\n");
-                    } else {
-                        printf("The number of processes and colors must be indentical!\n");
-                    }
-                    nr_pids = 0;
-                    procNo = 0;
-                    colorNo = 0;
-                    spaceFlag = 1;
-                    cmdLen = 0;
-                    memset(str, 0, strlen(str));
-                    continue;
-                }
-                find_pid_by_name(nr_pids, procName, pids);
-                print_cmd_info(nr_pids, pids, colors, retval, procName);
-                syscall(__NR_set_colors, nr_pids, pids, colors, retval);
-            } else if (strcmp(cmdName, "exit") == 0) {
-                free(str);
-                exit(0);
-            } else {
-                printf("Wrong command!\n");
-            }
-            nr_pids = 0;
-            procNo = 0;
-            colorNo = 0;
-            spaceFlag = 1;
-            cmdLen = 0;
-            memset(str, 0, strlen(str));
-            } else {
-            cmdLen++;
-            if (cmdLen > MAX_CMD_LEN) {
-                memset(str, 0, strlen(str));
-                continue;
-            }
-            if (spaceFlag == 0) {
-                strncat(str, &inputChar, 1);
-                if (inputChar == ' ') {
-                    spaceFlag = 1;
-                }
-            } else {
-                if (inputChar != ' ') {
-                    strncat(str, &inputChar, 1);
-                    spaceFlag = 0;
-                }
-            }
-        }
-    }
-    free(str);
-    return 0;
+	int nr_pids;
+	int retval[MAX_PROC_NUM];
+	int i;
+	int j = 0;
+	int k = 0;
+	char *procName[MAX_PROC_NUM];
+	pid_t pids[MAX_PROC_NUM];
+	u_int16_t colors[MAX_PROC_NUM];
+	if (strcmp(argv[0], "./setcolors") != 0) {
+		printf("Invalid command!\n");
+		return -1;
+	}
+	if (argc == 1) {
+		printf("Please provide a name of a process.\n");
+		return -1;
+	}
+	if (argc % 2 == 0) {
+		printf("The number of processes and colors should be
+			 identical.\n");
+		return -1;
+	}
+	nr_pids = argc / 2;
+	for (i = 0; i < nr_pids; i++)
+		retval[i] = 0;
+	for (i = 1; i <= argc; i++) {
+		if (i % 2 == 1) {
+			procName[j] = argv[i];
+			j++;
+		} else {
+			colors[k] = atoi(argv[i]);
+			k++;
+		}
+	}
+	find_pid_by_name(nr_pids, procName, pids);
+	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	syscall(__NR_set_colors, nr_pids, pids, colors, retval);
+	return 0;
 }
-
-- 
1.7.9.5


From c73ba37f40cc1f61d23110947446fc4fb5c6d665 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Tue, 26 Feb 2013 23:01:22 -0500
Subject: [PATCH 23/64] -added color propogation across forks. -need to check
 vfork. -need to check locking.

---
 kernel/color.c |    1 +
 kernel/fork.c  |    5 +++++
 2 files changed, 6 insertions(+)

diff --git a/kernel/color.c b/kernel/color.c
index 9a44e67..6c0a332 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -8,6 +8,7 @@
 
 /**
  * TODO: Look into locking and thread traversal.
+ * optimize this!!!
  */
 int set_tg_color(pid_t tgid, u_int16_t color)
 {
diff --git a/kernel/fork.c b/kernel/fork.c
index 820f0ff..e9404fa 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -983,6 +983,11 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	if (!p)
 		goto fork_out;
 
+	/*** Added by: Riley Spahn, Date: 2/26/13 
+	 * TODO: LOCK IT!
+	 * */
+	p->color = current->color;
+
 	rt_mutex_init_task(p);
 
 #ifdef CONFIG_PROVE_LOCKING
-- 
1.7.9.5


From 76925424e67a19b75ad8f64f6d9247fca1cda8f8 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Wed, 27 Feb 2013 13:34:22 -0500
Subject: [PATCH 24/64] -replaced asmlinkage with macro SYSCALL_DEFINE in
 color.c -added asmlinkage in syscalls.h

---
 arch/x86/include/asm/syscalls.h |    5 +++++
 kernel/color.c                  |   11 ++++++-----
 test_getcolors.c                |    8 ++++----
 test_setcolors.c                |   13 ++++++-------
 4 files changed, 21 insertions(+), 16 deletions(-)

diff --git a/arch/x86/include/asm/syscalls.h b/arch/x86/include/asm/syscalls.h
index c0b0bda..8cb6fbd 100644
--- a/arch/x86/include/asm/syscalls.h
+++ b/arch/x86/include/asm/syscalls.h
@@ -89,5 +89,10 @@ asmlinkage long sys_mmap(unsigned long, unsigned long, unsigned long,
 struct new_utsname;
 asmlinkage long sys_uname(struct new_utsname __user *);
 
+/* kernel/sys_color.c -Added on 2/27/13*/
+amslinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
+				int *retval);
+amslinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
+				int *retval);
 #endif /* CONFIG_X86_32 */
 #endif /* _ASM_X86_SYSCALLS_H */
diff --git a/kernel/color.c b/kernel/color.c
index 9a44e67..d585cb6 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -1,6 +1,6 @@
 #include <linux/cred.h>
 #include <linux/errno.h>
-#include <linux/linkage.h>
+#include <linux/syscalls.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
@@ -75,8 +75,8 @@ int get_color(pid_t pid)
 /*
  * TODO
  */
-asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
-		int *retval)
+SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
+		int, *retval)
 {
 	pid_t tgid;
 	pid_t *k_pids;
@@ -189,8 +189,9 @@ asmlinkage int sys_set_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
 /*
  * TODO
  */
-asmlinkage int sys_get_colors(int nr_pids, pid_t *pids, u_int16_t *colors,
-		int *retval)
+
+SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
+		int, *retval)
 {
 	pid_t *k_pids;
 	u_int16_t *k_colors;
diff --git a/test_getcolors.c b/test_getcolors.c
index 6b898f0..72f4b92 100644
--- a/test_getcolors.c
+++ b/test_getcolors.c
@@ -50,8 +50,8 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			int *retval, char *procName[])
 {
 	int index;
-	printf("\n************************************************************
-		**************\n");
+	printf("\n*********************************************************");
+	printf("*****************\n");
 	for (index = 0; index < nr_pids; index++) {
 		if (pids[index] == 0)
 			printf("Process %s does not exist\n", procName[index]);
@@ -63,8 +63,8 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			printf("set status:%d\n", retval[index]);
 			}
 	}
-	printf("**************************************************************
-		************\n\n");
+	printf("***********************************************************");
+	printf("************\n\n");
 }
 
 int main(int argc, char *argv[])
diff --git a/test_setcolors.c b/test_setcolors.c
index 70a8f96..26b9211 100644
--- a/test_setcolors.c
+++ b/test_setcolors.c
@@ -12,7 +12,6 @@
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
 #define __NR_set_colors 223
-#define __NR_get_colors 251
 
 
 
@@ -54,8 +53,8 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			int *retval, char *procName[])
 {
 	int index;
-	printf("**************************************************************
-			************\n");
+	printf("***********************************************************");
+	printf("************\n");
 	for (index = 0; index < nr_pids; index++) {
 		if (pids[index] == 0)
 			printf("Process %s does not exist\n", procName[index]);
@@ -67,8 +66,8 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			printf("set status:%d\n", retval[index]);
 		}
 	}
-	printf("**************************************************************
-			************\n");
+	printf("***********************************************************");
+	printf("************\n");
 }
 
 int main(int argc, char *argv[])
@@ -90,8 +89,8 @@ int main(int argc, char *argv[])
 		return -1;
 	}
 	if (argc % 2 == 0) {
-		printf("The number of processes and colors should be
-			 identical.\n");
+		printf("The number of processes and colors should be ");
+		printf("identical.\n");
 		return -1;
 	}
 	nr_pids = argc / 2;
-- 
1.7.9.5


From acae9f66a9186edd4d6fb9c381e24365d0123d91 Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Wed, 27 Feb 2013 20:45:23 -0500
Subject: [PATCH 25/64] added test file forktest including fork(),vfork()

---
 forktest.c |   86 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 86 insertions(+)
 create mode 100644 forktest.c

diff --git a/forktest.c b/forktest.c
new file mode 100644
index 0000000..ea1f9c9
--- /dev/null
+++ b/forktest.c
@@ -0,0 +1,86 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sched.h>
+#include <signal.h>
+
+void forktest(int agm_num, char *agm[])
+{
+	char *tmp[10];
+	int delay;
+	int pid;
+	int index = 0;
+	int i, j;
+	index = 0;
+	delay = atoi(agm[index + 1]);
+	sleep(delay);
+	if (strcmp(agm[index + 2], "fork") == 0) {
+		pid = fork();
+		if (pid < 0)
+			perror("failed to fork");
+		else {
+			if (pid == 0) {
+				if (strcmp(agm[index + 3], "forktest") == 0) {
+					for (i = 0; i < agm_num - 3; i++)
+						agm[i] = agm[i + 3];
+					agm_num = agm_num - 3;
+					forktest(agm_num, agm);
+				} else {
+					for (j = 0; j < agm_num - 3; j++)
+						tmp[j] = agm[3 + j];
+					tmp[j] = NULL;
+					execvp(tmp[0], tmp);
+					perror("Command not found");
+					exit(0);
+				 }
+			} else
+				waitpid(pid, NULL, 0);
+		}
+	} else if (strcmp(agm[index + 2], "vfork") == 0) {
+		pid = vfork();
+		if (pid < 0)
+			perror("failed to vfork");
+		else {
+			if (pid == 0) {
+				if (strcmp(agm[index + 3], "forktest") == 0) {
+					for (i = 0; i < agm_num - 3; i++)
+						agm[i] = agm[i + 3];
+					agm_num = agm_num - 3;
+					forktest(agm_num, agm);
+				} else {
+					for (j = 0; j < agm_num - 3; j++)
+						tmp[j] = agm[3 + j];
+					tmp[j] = NULL;
+					execvp(tmp[0], tmp);
+					perror("Command not found");
+					exit(0);
+				}
+			} else
+				waitpid(pid, NULL, 0);
+		}
+	} else
+		printf("Not a valid command!\n");
+}
+
+int main(int argc, char *argv[])
+{
+	char *str[argc];
+	int i, j;
+
+	if (strcmp(argv[0], "./forktest") == 0) {
+		if (argc < 4) {
+			printf("Please provide a complete command.\n");
+			return -1;
+		}
+		for (i = 0; i < argc; i++)
+			str[i] = argv[i];
+		j = argc;
+		forktest(j, str);
+		return 0;
+	}
+}
-- 
1.7.9.5


From b106e480c92091ae4f19d23e4d57c049c380ee09 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Thu, 28 Feb 2013 09:06:13 -0500
Subject: [PATCH 26/64] -added color copying/not copying to fork.

---
 kernel/fork.c |   16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/kernel/fork.c b/kernel/fork.c
index e9404fa..b491fa0 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -983,11 +983,6 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	if (!p)
 		goto fork_out;
 
-	/*** Added by: Riley Spahn, Date: 2/26/13 
-	 * TODO: LOCK IT!
-	 * */
-	p->color = current->color;
-
 	rt_mutex_init_task(p);
 
 #ifdef CONFIG_PROVE_LOCKING
@@ -1021,6 +1016,14 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 	if (p->binfmt && !try_module_get(p->binfmt->module))
 		goto bad_fork_cleanup_put_domain;
 
+	/**
+	 * Added by: Riley Spahn, Date: 2/26/13 
+	 */
+	rcu_read_lock();
+	p->color = current->color;
+	rcu_read_unlock();
+
+
 	p->did_exec = 0;
 	delayacct_tsk_init(p);	/* Must remain after dup_task_struct() */
 	copy_flags(clone_flags, p);
@@ -1421,6 +1424,9 @@ long do_fork(unsigned long clone_flags,
 			put_user(nr, parent_tidptr);
 
 		if (clone_flags & CLONE_VFORK) {
+			/** Added by: Riley Spahn */
+			p->color = 0;
+
 			p->vfork_done = &vfork;
 			init_completion(&vfork);
 		}
-- 
1.7.9.5


From 815950c42360221018acab3b23ed1709062d8227 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Thu, 28 Feb 2013 10:10:13 -0500
Subject: [PATCH 27/64] -added notes to binder source code annotating where we
 should be able to plug in to test for colors.

---
 drivers/staging/android/binder.c |   27 +++++++++++++++++++++++++++
 1 file changed, 27 insertions(+)

diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 2d097aa..b3905ef 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -1257,6 +1257,26 @@ static void
 binder_transaction_buffer_release(struct binder_proc *proc,
 			struct binder_buffer *buffer, size_t *failed_at);
 
+/**
+ * Notes by Riley Spahn
+ *
+ * t - binder_trancsaction being built. mallocated around 1400, we should be
+ * able to check before this point.
+ * proc - binder_proc calling process
+ *
+ * To modify binder:
+ * - Get the origin PID from thread parameter, maybe proc parameter. 2nd parameter
+ *   When the binder_transaction is built we can get the pid of the calling process
+ *   and the pid of the receiving process.  When this is built we can then do the
+ *   checks to determine if the processes are the same color.
+ *
+ * - We can add an error at the bottom of the function and use a goto to clear
+ *   throw the error if the processes are not colored correctly.
+ *
+ * - It lookds like target_proc is assigned around 1370.  Should be able to test
+ *   after this.
+ */
+
 static void
 binder_transaction(struct binder_proc *proc, struct binder_thread *thread,
 	struct binder_transaction_data *tr, int reply)
@@ -1349,6 +1369,13 @@ binder_transaction(struct binder_proc *proc, struct binder_thread *thread,
 			return_error = BR_DEAD_REPLY;
 			goto err_dead_binder;
 		}
+
+		/** 
+		 * Added by: Riley Spahn
+		 * We should be able to test for the same pids here and throw
+		 * and errof if needed.
+		 */
+
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
 			struct binder_transaction *tmp;
 			tmp = thread->transaction_stack;
-- 
1.7.9.5


From 6921ad563ba4296102d7eee5680bdce4ba4d5209 Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Thu, 28 Feb 2013 19:14:41 -0500
Subject: [PATCH 28/64] modified binder.c to do permissions check

---
 drivers/staging/android/binder.c |    8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index b3905ef..2efd6d4 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -1375,6 +1375,14 @@ binder_transaction(struct binder_proc *proc, struct binder_thread *thread,
 		 * We should be able to test for the same pids here and throw
 		 * and errof if needed.
 		 */
+		/*
+		*Code added by Meng Yao
+		*/
+		if ((target_proc->tsk->color != 0) && (proc->tsk->color != 0) 
+		&& (target_proc->tsk->color != proc->tsk->color)) {
+				return_error = BR_FAILED_REPLY;
+				goto err_dead_binder;		
+		}
 
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
 			struct binder_transaction *tmp;
-- 
1.7.9.5


From e7cc3b3567f1f4b34990b5df2dd8495bc7c69705 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Thu, 28 Feb 2013 20:23:33 -0500
Subject: [PATCH 29/64] Added a readme for homework 2.  Right now it mostly
 containts notes but we will augment it with the
 needed information.

---
 README_HW2.md  |   49 +++++++++++++++++++++++++++++++++++++++++++++++++
 kernel/color.c |    1 -
 2 files changed, 49 insertions(+), 1 deletion(-)
 create mode 100644 README_HW2.md

diff --git a/README_HW2.md b/README_HW2.md
new file mode 100644
index 0000000..175af3b
--- /dev/null
+++ b/README_HW2.md
@@ -0,0 +1,49 @@
+
+TODO:
+* assign system call number to each architecture.
+* 
+* add ability to call from user space using the macro.
+* implementation will go in /kernel.color.c
+* in `arch/<architecture>/kernel/syscall_table..
+        * must add at the correct line and replace sys_ni_syscall
+        * on x86 32 using syscalls 223 and 251.  It looks like x86 and i386 use the same system call numbers
+        * arm - 361 and 362
+        * on x86 64 can use 295, 296
+* x86 syscall table uses a preprocessor def to determine if 64 or 32 bit.
+
+* make sure that only root can modify task_structo
+* get all processes in tgid and set all of their colors as well
+
+* update fork and clone to fork to propogate the color.
+* vfork need not propogate color because the processes contents will be immediately replaced.
+
+* All makefiles are kbuild makefiles
+
+## System Call Numbers
+* x86_32:
+    * set_colors - 223
+    * get_colors - 251
+* x86_64:
+    * set_colors - 295
+    * get_colors - 296
+* i386 (same as x86 32 bit):
+    * set_colors - 223
+    * get_colors - 251
+* arm:
+    * set_colors - 361
+    * get_colors - 362
+
+## Notes:
+* tasklist_lock is the lock used, not the function
+* task_lock
+
+
+* Blog entry zhangsen.org ... mentioned there is a difference for defining system calls.  Says to edit `include/asm/unistd_64.h` which does not exist in our version of the kernel.
+* Check on system call 222 in x86
+
+### Binder:
+You know the bin
+
+
+## References
+https://lwn.net/Articles/21835/
diff --git a/kernel/color.c b/kernel/color.c
index e08c08a..ef180ad 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -19,7 +19,6 @@ int set_tg_color(pid_t tgid, u_int16_t color)
 		if (p->tgid == tgid)
 			p->color = color;
 	}
-
 	write_unlock(&tasklist_lock);
 
 	return 0;
-- 
1.7.9.5


From e031dda200e756918c416301b5f40f5d6c93cab7 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Thu, 28 Feb 2013 20:28:00 -0500
Subject: [PATCH 30/64] -added the compile time to the README after
 reinstalling OS.

---
 README_HW2.md |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/README_HW2.md b/README_HW2.md
index 175af3b..ed4f4a8 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -47,3 +47,6 @@ You know the bin
 
 ## References
 https://lwn.net/Articles/21835/
+
+## Part 1
+2.6.29, riley@algiers #32 Thu Feb 28 09:11:03 EST 2013
-- 
1.7.9.5


From 0d4f046d1a999a013fd0a3b8223265ffe95e4b74 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Thu, 28 Feb 2013 20:42:30 -0500
Subject: [PATCH 31/64] -added all user space programes to their own
 directory.

---
 forktest.c                  |   86 ---------------------------------
 test_getcolors.c            |   97 -------------------------------------
 test_setcolors.c            |  112 -------------------------------------------
 user_tests/Makefile.ndk     |   51 ++++++++++++++++++++
 user_tests/forktest.c       |   86 +++++++++++++++++++++++++++++++++
 user_tests/test_getcolors.c |   97 +++++++++++++++++++++++++++++++++++++
 user_tests/test_setcolors.c |  112 +++++++++++++++++++++++++++++++++++++++++++
 7 files changed, 346 insertions(+), 295 deletions(-)
 delete mode 100644 forktest.c
 delete mode 100644 test_getcolors.c
 delete mode 100644 test_setcolors.c
 create mode 100644 user_tests/Makefile.ndk
 create mode 100644 user_tests/forktest.c
 create mode 100644 user_tests/test_getcolors.c
 create mode 100644 user_tests/test_setcolors.c

diff --git a/forktest.c b/forktest.c
deleted file mode 100644
index ea1f9c9..0000000
--- a/forktest.c
+++ /dev/null
@@ -1,86 +0,0 @@
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-#include <sys/wait.h>
-#include <sched.h>
-#include <signal.h>
-
-void forktest(int agm_num, char *agm[])
-{
-	char *tmp[10];
-	int delay;
-	int pid;
-	int index = 0;
-	int i, j;
-	index = 0;
-	delay = atoi(agm[index + 1]);
-	sleep(delay);
-	if (strcmp(agm[index + 2], "fork") == 0) {
-		pid = fork();
-		if (pid < 0)
-			perror("failed to fork");
-		else {
-			if (pid == 0) {
-				if (strcmp(agm[index + 3], "forktest") == 0) {
-					for (i = 0; i < agm_num - 3; i++)
-						agm[i] = agm[i + 3];
-					agm_num = agm_num - 3;
-					forktest(agm_num, agm);
-				} else {
-					for (j = 0; j < agm_num - 3; j++)
-						tmp[j] = agm[3 + j];
-					tmp[j] = NULL;
-					execvp(tmp[0], tmp);
-					perror("Command not found");
-					exit(0);
-				 }
-			} else
-				waitpid(pid, NULL, 0);
-		}
-	} else if (strcmp(agm[index + 2], "vfork") == 0) {
-		pid = vfork();
-		if (pid < 0)
-			perror("failed to vfork");
-		else {
-			if (pid == 0) {
-				if (strcmp(agm[index + 3], "forktest") == 0) {
-					for (i = 0; i < agm_num - 3; i++)
-						agm[i] = agm[i + 3];
-					agm_num = agm_num - 3;
-					forktest(agm_num, agm);
-				} else {
-					for (j = 0; j < agm_num - 3; j++)
-						tmp[j] = agm[3 + j];
-					tmp[j] = NULL;
-					execvp(tmp[0], tmp);
-					perror("Command not found");
-					exit(0);
-				}
-			} else
-				waitpid(pid, NULL, 0);
-		}
-	} else
-		printf("Not a valid command!\n");
-}
-
-int main(int argc, char *argv[])
-{
-	char *str[argc];
-	int i, j;
-
-	if (strcmp(argv[0], "./forktest") == 0) {
-		if (argc < 4) {
-			printf("Please provide a complete command.\n");
-			return -1;
-		}
-		for (i = 0; i < argc; i++)
-			str[i] = argv[i];
-		j = argc;
-		forktest(j, str);
-		return 0;
-	}
-}
diff --git a/test_getcolors.c b/test_getcolors.c
deleted file mode 100644
index 72f4b92..0000000
--- a/test_getcolors.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/******************************************************
- *This is a test program that is used to test getcolors
- ******************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-#define __NR_get_colors 251
-
-
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-    struct dirent *d;
-    FILE *fp;
-    DIR *dir;
-    char filepath[FILE_LEN];
-    char filetext[FILE_LEN];
-    int index;
-    dir = opendir("/proc");
-    if (!dir) {
-	perror("Open proc directory failed!");
-	exit(EXIT_FAILURE);
-    }
-    while ((d = readdir(dir)) != NULL) {
-	if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0))
-		continue;
-	sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-	fp = fopen(filepath, "r");
-	if (fp != NULL) {
-		fread(filetext, 1, FILE_LEN, fp);
-		filetext[FILE_LEN-1] = '\0';
-	for (index = 0; index < nr_pids; index++) {
-		if (filetext == strstr(filetext, procName[index]))
-			pids[index] = atoi(d->d_name);
-	}
-	fclose(fp);
-	}
-    }
-    closedir(dir);
-    return 0;
-}
-
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
-			int *retval, char *procName[])
-{
-	int index;
-	printf("\n*********************************************************");
-	printf("*****************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0)
-			printf("Process %s does not exist\n", procName[index]);
-		else {
-			printf("[%d]", index);
-			printf("process name:%s      ", procName[index]);
-			printf("pid:%d      ", pids[index]);
-			printf("color:%d     ", colors[index]);
-			printf("set status:%d\n", retval[index]);
-			}
-	}
-	printf("***********************************************************");
-	printf("************\n\n");
-}
-
-int main(int argc, char *argv[])
-{
-	int nr_pids;
-	int retval[MAX_PROC_NUM];
-	int i;
-	char *procName[MAX_PROC_NUM];
-	pid_t pids[MAX_PROC_NUM];
-	u_int16_t colors[MAX_PROC_NUM];
-	if (strcmp(argv[0], "./getcolors") != 0) {
-		printf("Invalid command!\n");
-		return -1;
-	}
-	if (argc == 1) {
-		printf("Please provide a name of a process.\n");
-		return -1;
-	}
-	nr_pids = argc - 1;
-	for (i = 0; i < nr_pids; i++) {
-		procName[i] = argv[i + 1];
-		retval[i] = 0;
-		colors[i] = 0;
-	}
-	find_pid_by_name(nr_pids, procName, pids);
-	syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-	print_cmd_info(nr_pids, pids, colors, retval, procName);
-	return 0;
-}
-
diff --git a/test_setcolors.c b/test_setcolors.c
deleted file mode 100644
index 26b9211..0000000
--- a/test_setcolors.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/******************************************************
- *This is a test program that is used to test setcolors
- ******************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-#define __NR_set_colors 223
-
-
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-	struct dirent *d;
-	FILE *fp;
-	DIR *dir;
-	char filepath[FILE_LEN];
-	char filetext[FILE_LEN];
-	int index;
-	dir = opendir("/proc");
-	if (!dir) {
-		perror("Open proc directory failed!");
-		exit(EXIT_FAILURE);
-	}
-	while ((d = readdir(dir)) != NULL) {
-		if ((strcmp(d->d_name, ".") == 0) ||
-			(strcmp(d->d_name, "..") == 0))
-			continue;
-		sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-		fp = fopen(filepath, "r");
-		if (fp != NULL) {
-			fread(filetext, 1, FILE_LEN, fp);
-			filetext[FILE_LEN-1] = '\0';
-			for (index = 0; index < nr_pids; index++) {
-				if (filetext == strstr(filetext,
-					 procName[index]))
-					pids[index] = atoi(d->d_name);
-			}
-		fclose(fp);
-		}
-	}
-	closedir(dir);
-	return 0;
-}
-
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
-			int *retval, char *procName[])
-{
-	int index;
-	printf("***********************************************************");
-	printf("************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0)
-			printf("Process %s does not exist\n", procName[index]);
-		else {
-			printf("[%d]", index);
-			printf("process name:%s      ", procName[index]);
-			printf("pid:%d      ", pids[index]);
-			printf("color:%d     ", colors[index]);
-			printf("set status:%d\n", retval[index]);
-		}
-	}
-	printf("***********************************************************");
-	printf("************\n");
-}
-
-int main(int argc, char *argv[])
-{
-	int nr_pids;
-	int retval[MAX_PROC_NUM];
-	int i;
-	int j = 0;
-	int k = 0;
-	char *procName[MAX_PROC_NUM];
-	pid_t pids[MAX_PROC_NUM];
-	u_int16_t colors[MAX_PROC_NUM];
-	if (strcmp(argv[0], "./setcolors") != 0) {
-		printf("Invalid command!\n");
-		return -1;
-	}
-	if (argc == 1) {
-		printf("Please provide a name of a process.\n");
-		return -1;
-	}
-	if (argc % 2 == 0) {
-		printf("The number of processes and colors should be ");
-		printf("identical.\n");
-		return -1;
-	}
-	nr_pids = argc / 2;
-	for (i = 0; i < nr_pids; i++)
-		retval[i] = 0;
-	for (i = 1; i <= argc; i++) {
-		if (i % 2 == 1) {
-			procName[j] = argv[i];
-			j++;
-		} else {
-			colors[k] = atoi(argv[i]);
-			k++;
-		}
-	}
-	find_pid_by_name(nr_pids, procName, pids);
-	print_cmd_info(nr_pids, pids, colors, retval, procName);
-	syscall(__NR_set_colors, nr_pids, pids, colors, retval);
-	return 0;
-}
diff --git a/user_tests/Makefile.ndk b/user_tests/Makefile.ndk
new file mode 100644
index 0000000..fea6101
--- /dev/null
+++ b/user_tests/Makefile.ndk
@@ -0,0 +1,51 @@
+APP := test
+ROOT:=$(HOME)
+NDK_PLATFORM_VER := 14
+INSTALL_DIR := /data/tmp
+
+ANDROID_SDK_ROOT:=$(ROOT)/android-sdk-linux
+ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8d
+ANDROID_NDK_HOST:=linux-x86
+ANDROID_TARGET:=i686-linux-android
+ANDROID_TARGET_ARCH:=x86
+ANDROID_TOOLCHAIN:=x86-4.4.3
+
+BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
+LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
+INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
+BIN := $(BINDIR)/bin
+ 
+CPP := $(BIN)/$(ANDROID_TARGET)-g++
+CC := $(BIN)/$(ANDROID_TARGET)-gcc
+CFLAGS := -I$(INCDIR)
+LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
+ 
+ 
+all: $(APP)
+ 
+OBJS += $(APP).o
+ 
+$(APP): $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $^
+ 
+%.o: %.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+install: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+ 
+shell:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
+ 
+run:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+r: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+clean:
+	@rm -f $(APP).o $(APP)
+
diff --git a/user_tests/forktest.c b/user_tests/forktest.c
new file mode 100644
index 0000000..ea1f9c9
--- /dev/null
+++ b/user_tests/forktest.c
@@ -0,0 +1,86 @@
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#include <sys/wait.h>
+#include <sched.h>
+#include <signal.h>
+
+void forktest(int agm_num, char *agm[])
+{
+	char *tmp[10];
+	int delay;
+	int pid;
+	int index = 0;
+	int i, j;
+	index = 0;
+	delay = atoi(agm[index + 1]);
+	sleep(delay);
+	if (strcmp(agm[index + 2], "fork") == 0) {
+		pid = fork();
+		if (pid < 0)
+			perror("failed to fork");
+		else {
+			if (pid == 0) {
+				if (strcmp(agm[index + 3], "forktest") == 0) {
+					for (i = 0; i < agm_num - 3; i++)
+						agm[i] = agm[i + 3];
+					agm_num = agm_num - 3;
+					forktest(agm_num, agm);
+				} else {
+					for (j = 0; j < agm_num - 3; j++)
+						tmp[j] = agm[3 + j];
+					tmp[j] = NULL;
+					execvp(tmp[0], tmp);
+					perror("Command not found");
+					exit(0);
+				 }
+			} else
+				waitpid(pid, NULL, 0);
+		}
+	} else if (strcmp(agm[index + 2], "vfork") == 0) {
+		pid = vfork();
+		if (pid < 0)
+			perror("failed to vfork");
+		else {
+			if (pid == 0) {
+				if (strcmp(agm[index + 3], "forktest") == 0) {
+					for (i = 0; i < agm_num - 3; i++)
+						agm[i] = agm[i + 3];
+					agm_num = agm_num - 3;
+					forktest(agm_num, agm);
+				} else {
+					for (j = 0; j < agm_num - 3; j++)
+						tmp[j] = agm[3 + j];
+					tmp[j] = NULL;
+					execvp(tmp[0], tmp);
+					perror("Command not found");
+					exit(0);
+				}
+			} else
+				waitpid(pid, NULL, 0);
+		}
+	} else
+		printf("Not a valid command!\n");
+}
+
+int main(int argc, char *argv[])
+{
+	char *str[argc];
+	int i, j;
+
+	if (strcmp(argv[0], "./forktest") == 0) {
+		if (argc < 4) {
+			printf("Please provide a complete command.\n");
+			return -1;
+		}
+		for (i = 0; i < argc; i++)
+			str[i] = argv[i];
+		j = argc;
+		forktest(j, str);
+		return 0;
+	}
+}
diff --git a/user_tests/test_getcolors.c b/user_tests/test_getcolors.c
new file mode 100644
index 0000000..72f4b92
--- /dev/null
+++ b/user_tests/test_getcolors.c
@@ -0,0 +1,97 @@
+/******************************************************
+ *This is a test program that is used to test getcolors
+ ******************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_get_colors 251
+
+
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+    struct dirent *d;
+    FILE *fp;
+    DIR *dir;
+    char filepath[FILE_LEN];
+    char filetext[FILE_LEN];
+    int index;
+    dir = opendir("/proc");
+    if (!dir) {
+	perror("Open proc directory failed!");
+	exit(EXIT_FAILURE);
+    }
+    while ((d = readdir(dir)) != NULL) {
+	if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0))
+		continue;
+	sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+	fp = fopen(filepath, "r");
+	if (fp != NULL) {
+		fread(filetext, 1, FILE_LEN, fp);
+		filetext[FILE_LEN-1] = '\0';
+	for (index = 0; index < nr_pids; index++) {
+		if (filetext == strstr(filetext, procName[index]))
+			pids[index] = atoi(d->d_name);
+	}
+	fclose(fp);
+	}
+    }
+    closedir(dir);
+    return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
+			int *retval, char *procName[])
+{
+	int index;
+	printf("\n*********************************************************");
+	printf("*****************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (pids[index] == 0)
+			printf("Process %s does not exist\n", procName[index]);
+		else {
+			printf("[%d]", index);
+			printf("process name:%s      ", procName[index]);
+			printf("pid:%d      ", pids[index]);
+			printf("color:%d     ", colors[index]);
+			printf("set status:%d\n", retval[index]);
+			}
+	}
+	printf("***********************************************************");
+	printf("************\n\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int nr_pids;
+	int retval[MAX_PROC_NUM];
+	int i;
+	char *procName[MAX_PROC_NUM];
+	pid_t pids[MAX_PROC_NUM];
+	u_int16_t colors[MAX_PROC_NUM];
+	if (strcmp(argv[0], "./getcolors") != 0) {
+		printf("Invalid command!\n");
+		return -1;
+	}
+	if (argc == 1) {
+		printf("Please provide a name of a process.\n");
+		return -1;
+	}
+	nr_pids = argc - 1;
+	for (i = 0; i < nr_pids; i++) {
+		procName[i] = argv[i + 1];
+		retval[i] = 0;
+		colors[i] = 0;
+	}
+	find_pid_by_name(nr_pids, procName, pids);
+	syscall(__NR_get_colors, nr_pids, pids, colors, retval);
+	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	return 0;
+}
+
diff --git a/user_tests/test_setcolors.c b/user_tests/test_setcolors.c
new file mode 100644
index 0000000..26b9211
--- /dev/null
+++ b/user_tests/test_setcolors.c
@@ -0,0 +1,112 @@
+/******************************************************
+ *This is a test program that is used to test setcolors
+ ******************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_set_colors 223
+
+
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+	struct dirent *d;
+	FILE *fp;
+	DIR *dir;
+	char filepath[FILE_LEN];
+	char filetext[FILE_LEN];
+	int index;
+	dir = opendir("/proc");
+	if (!dir) {
+		perror("Open proc directory failed!");
+		exit(EXIT_FAILURE);
+	}
+	while ((d = readdir(dir)) != NULL) {
+		if ((strcmp(d->d_name, ".") == 0) ||
+			(strcmp(d->d_name, "..") == 0))
+			continue;
+		sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+		fp = fopen(filepath, "r");
+		if (fp != NULL) {
+			fread(filetext, 1, FILE_LEN, fp);
+			filetext[FILE_LEN-1] = '\0';
+			for (index = 0; index < nr_pids; index++) {
+				if (filetext == strstr(filetext,
+					 procName[index]))
+					pids[index] = atoi(d->d_name);
+			}
+		fclose(fp);
+		}
+	}
+	closedir(dir);
+	return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
+			int *retval, char *procName[])
+{
+	int index;
+	printf("***********************************************************");
+	printf("************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (pids[index] == 0)
+			printf("Process %s does not exist\n", procName[index]);
+		else {
+			printf("[%d]", index);
+			printf("process name:%s      ", procName[index]);
+			printf("pid:%d      ", pids[index]);
+			printf("color:%d     ", colors[index]);
+			printf("set status:%d\n", retval[index]);
+		}
+	}
+	printf("***********************************************************");
+	printf("************\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int nr_pids;
+	int retval[MAX_PROC_NUM];
+	int i;
+	int j = 0;
+	int k = 0;
+	char *procName[MAX_PROC_NUM];
+	pid_t pids[MAX_PROC_NUM];
+	u_int16_t colors[MAX_PROC_NUM];
+	if (strcmp(argv[0], "./setcolors") != 0) {
+		printf("Invalid command!\n");
+		return -1;
+	}
+	if (argc == 1) {
+		printf("Please provide a name of a process.\n");
+		return -1;
+	}
+	if (argc % 2 == 0) {
+		printf("The number of processes and colors should be ");
+		printf("identical.\n");
+		return -1;
+	}
+	nr_pids = argc / 2;
+	for (i = 0; i < nr_pids; i++)
+		retval[i] = 0;
+	for (i = 1; i <= argc; i++) {
+		if (i % 2 == 1) {
+			procName[j] = argv[i];
+			j++;
+		} else {
+			colors[k] = atoi(argv[i]);
+			k++;
+		}
+	}
+	find_pid_by_name(nr_pids, procName, pids);
+	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	syscall(__NR_set_colors, nr_pids, pids, colors, retval);
+	return 0;
+}
-- 
1.7.9.5


From c137f8e4221717eea5b743c961fb453017788407 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 28 Feb 2013 21:56:16 -0500
Subject: [PATCH 32/64] -moved test_setcolor -> setcolor. -moved test_getcolor
 -> getcolor

---
 user_tests/getcolors.c      |   97 +++++++++++++++++++++++++++++++++++++
 user_tests/setcolors.c      |  112 +++++++++++++++++++++++++++++++++++++++++++
 user_tests/test_getcolors.c |   97 -------------------------------------
 user_tests/test_setcolors.c |  112 -------------------------------------------
 4 files changed, 209 insertions(+), 209 deletions(-)
 create mode 100644 user_tests/getcolors.c
 create mode 100644 user_tests/setcolors.c
 delete mode 100644 user_tests/test_getcolors.c
 delete mode 100644 user_tests/test_setcolors.c

diff --git a/user_tests/getcolors.c b/user_tests/getcolors.c
new file mode 100644
index 0000000..72f4b92
--- /dev/null
+++ b/user_tests/getcolors.c
@@ -0,0 +1,97 @@
+/******************************************************
+ *This is a test program that is used to test getcolors
+ ******************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_get_colors 251
+
+
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+    struct dirent *d;
+    FILE *fp;
+    DIR *dir;
+    char filepath[FILE_LEN];
+    char filetext[FILE_LEN];
+    int index;
+    dir = opendir("/proc");
+    if (!dir) {
+	perror("Open proc directory failed!");
+	exit(EXIT_FAILURE);
+    }
+    while ((d = readdir(dir)) != NULL) {
+	if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0))
+		continue;
+	sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+	fp = fopen(filepath, "r");
+	if (fp != NULL) {
+		fread(filetext, 1, FILE_LEN, fp);
+		filetext[FILE_LEN-1] = '\0';
+	for (index = 0; index < nr_pids; index++) {
+		if (filetext == strstr(filetext, procName[index]))
+			pids[index] = atoi(d->d_name);
+	}
+	fclose(fp);
+	}
+    }
+    closedir(dir);
+    return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
+			int *retval, char *procName[])
+{
+	int index;
+	printf("\n*********************************************************");
+	printf("*****************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (pids[index] == 0)
+			printf("Process %s does not exist\n", procName[index]);
+		else {
+			printf("[%d]", index);
+			printf("process name:%s      ", procName[index]);
+			printf("pid:%d      ", pids[index]);
+			printf("color:%d     ", colors[index]);
+			printf("set status:%d\n", retval[index]);
+			}
+	}
+	printf("***********************************************************");
+	printf("************\n\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int nr_pids;
+	int retval[MAX_PROC_NUM];
+	int i;
+	char *procName[MAX_PROC_NUM];
+	pid_t pids[MAX_PROC_NUM];
+	u_int16_t colors[MAX_PROC_NUM];
+	if (strcmp(argv[0], "./getcolors") != 0) {
+		printf("Invalid command!\n");
+		return -1;
+	}
+	if (argc == 1) {
+		printf("Please provide a name of a process.\n");
+		return -1;
+	}
+	nr_pids = argc - 1;
+	for (i = 0; i < nr_pids; i++) {
+		procName[i] = argv[i + 1];
+		retval[i] = 0;
+		colors[i] = 0;
+	}
+	find_pid_by_name(nr_pids, procName, pids);
+	syscall(__NR_get_colors, nr_pids, pids, colors, retval);
+	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	return 0;
+}
+
diff --git a/user_tests/setcolors.c b/user_tests/setcolors.c
new file mode 100644
index 0000000..26b9211
--- /dev/null
+++ b/user_tests/setcolors.c
@@ -0,0 +1,112 @@
+/******************************************************
+ *This is a test program that is used to test setcolors
+ ******************************************************/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/syscall.h>
+#include <unistd.h>
+
+#define MAX_PROC_NUM 20
+#define FILE_LEN 50
+#define __NR_set_colors 223
+
+
+
+int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
+{
+	struct dirent *d;
+	FILE *fp;
+	DIR *dir;
+	char filepath[FILE_LEN];
+	char filetext[FILE_LEN];
+	int index;
+	dir = opendir("/proc");
+	if (!dir) {
+		perror("Open proc directory failed!");
+		exit(EXIT_FAILURE);
+	}
+	while ((d = readdir(dir)) != NULL) {
+		if ((strcmp(d->d_name, ".") == 0) ||
+			(strcmp(d->d_name, "..") == 0))
+			continue;
+		sprintf(filepath, "/proc/%s/cmdline", d->d_name);
+		fp = fopen(filepath, "r");
+		if (fp != NULL) {
+			fread(filetext, 1, FILE_LEN, fp);
+			filetext[FILE_LEN-1] = '\0';
+			for (index = 0; index < nr_pids; index++) {
+				if (filetext == strstr(filetext,
+					 procName[index]))
+					pids[index] = atoi(d->d_name);
+			}
+		fclose(fp);
+		}
+	}
+	closedir(dir);
+	return 0;
+}
+
+void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
+			int *retval, char *procName[])
+{
+	int index;
+	printf("***********************************************************");
+	printf("************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (pids[index] == 0)
+			printf("Process %s does not exist\n", procName[index]);
+		else {
+			printf("[%d]", index);
+			printf("process name:%s      ", procName[index]);
+			printf("pid:%d      ", pids[index]);
+			printf("color:%d     ", colors[index]);
+			printf("set status:%d\n", retval[index]);
+		}
+	}
+	printf("***********************************************************");
+	printf("************\n");
+}
+
+int main(int argc, char *argv[])
+{
+	int nr_pids;
+	int retval[MAX_PROC_NUM];
+	int i;
+	int j = 0;
+	int k = 0;
+	char *procName[MAX_PROC_NUM];
+	pid_t pids[MAX_PROC_NUM];
+	u_int16_t colors[MAX_PROC_NUM];
+	if (strcmp(argv[0], "./setcolors") != 0) {
+		printf("Invalid command!\n");
+		return -1;
+	}
+	if (argc == 1) {
+		printf("Please provide a name of a process.\n");
+		return -1;
+	}
+	if (argc % 2 == 0) {
+		printf("The number of processes and colors should be ");
+		printf("identical.\n");
+		return -1;
+	}
+	nr_pids = argc / 2;
+	for (i = 0; i < nr_pids; i++)
+		retval[i] = 0;
+	for (i = 1; i <= argc; i++) {
+		if (i % 2 == 1) {
+			procName[j] = argv[i];
+			j++;
+		} else {
+			colors[k] = atoi(argv[i]);
+			k++;
+		}
+	}
+	find_pid_by_name(nr_pids, procName, pids);
+	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	syscall(__NR_set_colors, nr_pids, pids, colors, retval);
+	return 0;
+}
diff --git a/user_tests/test_getcolors.c b/user_tests/test_getcolors.c
deleted file mode 100644
index 72f4b92..0000000
--- a/user_tests/test_getcolors.c
+++ /dev/null
@@ -1,97 +0,0 @@
-/******************************************************
- *This is a test program that is used to test getcolors
- ******************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-#define __NR_get_colors 251
-
-
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-    struct dirent *d;
-    FILE *fp;
-    DIR *dir;
-    char filepath[FILE_LEN];
-    char filetext[FILE_LEN];
-    int index;
-    dir = opendir("/proc");
-    if (!dir) {
-	perror("Open proc directory failed!");
-	exit(EXIT_FAILURE);
-    }
-    while ((d = readdir(dir)) != NULL) {
-	if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0))
-		continue;
-	sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-	fp = fopen(filepath, "r");
-	if (fp != NULL) {
-		fread(filetext, 1, FILE_LEN, fp);
-		filetext[FILE_LEN-1] = '\0';
-	for (index = 0; index < nr_pids; index++) {
-		if (filetext == strstr(filetext, procName[index]))
-			pids[index] = atoi(d->d_name);
-	}
-	fclose(fp);
-	}
-    }
-    closedir(dir);
-    return 0;
-}
-
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
-			int *retval, char *procName[])
-{
-	int index;
-	printf("\n*********************************************************");
-	printf("*****************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0)
-			printf("Process %s does not exist\n", procName[index]);
-		else {
-			printf("[%d]", index);
-			printf("process name:%s      ", procName[index]);
-			printf("pid:%d      ", pids[index]);
-			printf("color:%d     ", colors[index]);
-			printf("set status:%d\n", retval[index]);
-			}
-	}
-	printf("***********************************************************");
-	printf("************\n\n");
-}
-
-int main(int argc, char *argv[])
-{
-	int nr_pids;
-	int retval[MAX_PROC_NUM];
-	int i;
-	char *procName[MAX_PROC_NUM];
-	pid_t pids[MAX_PROC_NUM];
-	u_int16_t colors[MAX_PROC_NUM];
-	if (strcmp(argv[0], "./getcolors") != 0) {
-		printf("Invalid command!\n");
-		return -1;
-	}
-	if (argc == 1) {
-		printf("Please provide a name of a process.\n");
-		return -1;
-	}
-	nr_pids = argc - 1;
-	for (i = 0; i < nr_pids; i++) {
-		procName[i] = argv[i + 1];
-		retval[i] = 0;
-		colors[i] = 0;
-	}
-	find_pid_by_name(nr_pids, procName, pids);
-	syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-	print_cmd_info(nr_pids, pids, colors, retval, procName);
-	return 0;
-}
-
diff --git a/user_tests/test_setcolors.c b/user_tests/test_setcolors.c
deleted file mode 100644
index 26b9211..0000000
--- a/user_tests/test_setcolors.c
+++ /dev/null
@@ -1,112 +0,0 @@
-/******************************************************
- *This is a test program that is used to test setcolors
- ******************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-#define __NR_set_colors 223
-
-
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-	struct dirent *d;
-	FILE *fp;
-	DIR *dir;
-	char filepath[FILE_LEN];
-	char filetext[FILE_LEN];
-	int index;
-	dir = opendir("/proc");
-	if (!dir) {
-		perror("Open proc directory failed!");
-		exit(EXIT_FAILURE);
-	}
-	while ((d = readdir(dir)) != NULL) {
-		if ((strcmp(d->d_name, ".") == 0) ||
-			(strcmp(d->d_name, "..") == 0))
-			continue;
-		sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-		fp = fopen(filepath, "r");
-		if (fp != NULL) {
-			fread(filetext, 1, FILE_LEN, fp);
-			filetext[FILE_LEN-1] = '\0';
-			for (index = 0; index < nr_pids; index++) {
-				if (filetext == strstr(filetext,
-					 procName[index]))
-					pids[index] = atoi(d->d_name);
-			}
-		fclose(fp);
-		}
-	}
-	closedir(dir);
-	return 0;
-}
-
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
-			int *retval, char *procName[])
-{
-	int index;
-	printf("***********************************************************");
-	printf("************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0)
-			printf("Process %s does not exist\n", procName[index]);
-		else {
-			printf("[%d]", index);
-			printf("process name:%s      ", procName[index]);
-			printf("pid:%d      ", pids[index]);
-			printf("color:%d     ", colors[index]);
-			printf("set status:%d\n", retval[index]);
-		}
-	}
-	printf("***********************************************************");
-	printf("************\n");
-}
-
-int main(int argc, char *argv[])
-{
-	int nr_pids;
-	int retval[MAX_PROC_NUM];
-	int i;
-	int j = 0;
-	int k = 0;
-	char *procName[MAX_PROC_NUM];
-	pid_t pids[MAX_PROC_NUM];
-	u_int16_t colors[MAX_PROC_NUM];
-	if (strcmp(argv[0], "./setcolors") != 0) {
-		printf("Invalid command!\n");
-		return -1;
-	}
-	if (argc == 1) {
-		printf("Please provide a name of a process.\n");
-		return -1;
-	}
-	if (argc % 2 == 0) {
-		printf("The number of processes and colors should be ");
-		printf("identical.\n");
-		return -1;
-	}
-	nr_pids = argc / 2;
-	for (i = 0; i < nr_pids; i++)
-		retval[i] = 0;
-	for (i = 1; i <= argc; i++) {
-		if (i % 2 == 1) {
-			procName[j] = argv[i];
-			j++;
-		} else {
-			colors[k] = atoi(argv[i]);
-			k++;
-		}
-	}
-	find_pid_by_name(nr_pids, procName, pids);
-	print_cmd_info(nr_pids, pids, colors, retval, procName);
-	syscall(__NR_set_colors, nr_pids, pids, colors, retval);
-	return 0;
-}
-- 
1.7.9.5


From 5c175c29344d01e592b6762306e8e575d1a5d1b7 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Thu, 28 Feb 2013 22:13:18 -0500
Subject: [PATCH 33/64] -added make file to user_tests.

---
 user_tests/Makefile |   66 +++++++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)
 create mode 100644 user_tests/Makefile

diff --git a/user_tests/Makefile b/user_tests/Makefile
new file mode 100644
index 0000000..30d5cfb
--- /dev/null
+++ b/user_tests/Makefile
@@ -0,0 +1,66 @@
+SET  := setcolors
+GET  := getcolors
+FORK := forktest
+
+APP := test
+ROOT:=$(HOME)
+NDK_PLATFORM_VER := 14
+INSTALL_DIR := /data/tmp
+
+ANDROID_SDK_ROOT:=$(ROOT)/android-sdk-linux
+ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8d
+ANDROID_NDK_HOST:=linux-x86
+ANDROID_TARGET:=i686-linux-android
+ANDROID_TARGET_ARCH:=x86
+ANDROID_TOOLCHAIN:=x86-4.4.3
+
+BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
+LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
+INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
+BIN := $(BINDIR)/bin
+ 
+CPP := $(BIN)/$(ANDROID_TARGET)-g++
+CC := $(BIN)/$(ANDROID_TARGET)-gcc
+CFLAGS := -I$(INCDIR)
+LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
+ 
+ 
+all: setcolors getcolors forktest
+
+setcolors: setcolors.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+getcolors: getcolors.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+forktest: forktest.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+
+ 
+OBJS += $(APP).o
+
+# @ =  left side of ":"
+# ^ = right side of ":"
+# < = first item in dep list
+$(APP): $(OBJS)
+	$(CC) $(LDFLAGS) -o $@ $^
+ 
+%.o: %.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
+install: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+ 
+shell:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
+ 
+run:
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+r: $(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
+clean:
+	@rm -f $(APP).o $(APP)
+
-- 
1.7.9.5


From e23f1ef84871a23fb8cdbf2fdf33e27e6161ceed Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Thu, 28 Feb 2013 22:21:05 -0500
Subject: [PATCH 34/64] -modified make file to build all test programs. -works
 for make, install, and clean

---
 user_tests/Makefile |   33 +++++++++++++++++----------------
 1 file changed, 17 insertions(+), 16 deletions(-)

diff --git a/user_tests/Makefile b/user_tests/Makefile
index 30d5cfb..053d7a6 100644
--- a/user_tests/Makefile
+++ b/user_tests/Makefile
@@ -25,42 +25,43 @@ CFLAGS := -I$(INCDIR)
 LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
 LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
  
+progs: $(FORK) $(SET) $(GET)
  
-all: setcolors getcolors forktest
+all: progs
 
-setcolors: setcolors.c
+$(SET): setcolors.c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-getcolors: getcolors.c
+$(GET): getcolors.c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-forktest: forktest.c
+$(FORK): forktest.c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
 
  
 OBJS += $(APP).o
 
+
 # @ =  left side of ":"
 # ^ = right side of ":"
 # < = first item in dep list
-$(APP): $(OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^
- 
 %.o: %.c
 	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-install: $(APP)
+
+install: progs
 	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(GET)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(SET)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(FORK)
  
 shell:
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
  
-run:
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-r: $(APP)
+#r: $(APP)
 	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+#	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
+#	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
  
 clean:
-	@rm -f $(APP).o $(APP)
+	@rm -f $(APP).o $(APP) $(GET) $(SET) $(FORK)
 
-- 
1.7.9.5


From 14beefbd94659453f2072930f37ea2b5da67e6a5 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Fri, 1 Mar 2013 19:46:53 -0500
Subject: [PATCH 35/64] -Documented changes in the README_HW2 -cleaned up
 comments.

---
 README_HW2.md                    |   68 ++++++++++++++++----------------------
 drivers/staging/android/binder.c |    5 +--
 kernel/color.c                   |    2 ++
 user_tests/Makefile              |    2 +-
 4 files changed, 33 insertions(+), 44 deletions(-)

diff --git a/README_HW2.md b/README_HW2.md
index ed4f4a8..a101d0d 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -1,25 +1,31 @@
-
-TODO:
-* assign system call number to each architecture.
-* 
-* add ability to call from user space using the macro.
-* implementation will go in /kernel.color.c
-* in `arch/<architecture>/kernel/syscall_table..
-        * must add at the correct line and replace sys_ni_syscall
-        * on x86 32 using syscalls 223 and 251.  It looks like x86 and i386 use the same system call numbers
-        * arm - 361 and 362
-        * on x86 64 can use 295, 296
-* x86 syscall table uses a preprocessor def to determine if 64 or 32 bit.
-
-* make sure that only root can modify task_structo
-* get all processes in tgid and set all of their colors as well
-
-* update fork and clone to fork to propogate the color.
-* vfork need not propogate color because the processes contents will be immediately replaced.
-
-* All makefiles are kbuild makefiles
-
-## System Call Numbers
+README for OS Homework Assignment 2
+
+# Files:
+* kernel/color.c
+    * get_colors - the system call that we added that will return the colors of the processes provided.
+    * set_colors - the system call that will will set all of the pids in the parameter list to a given color.  It will also call another function that will propgate that color to all other processes that have the same tgid as the given pid.  This makes sure that all of a processes threads have the same id.
+    * get_color - helper function that returns the color associated with a pid.
+    * set_color - helper function that will set the color of a process.  It locks before called the fin_task_by_pid function and there are unlocks in each of the conditional branches to ensure that the task_list is locked for as short a time as possible.
+    * set_tg_color - sets all of the processes in a given thread group to the color parameter.
+ * kernel/fork.c
+    * Added to the copy_process function that will propogate the parent processes color to the child.
+    * Added to the do_fork function that will ensure that the color does not propogate if vfork is called instead of clone or fork.
+* drivers/stagin/android/binder.c
+    *added conditional to binder_transaction that will test if the src and dest process have the same color or 0 color and if not will return execute the err_dead_binder error condition.
+* include/linux/sched.h
+    * added the u_int16_t color field to the task_struct.
+* user_tests/forktest.c
+    * contains the forktest program that is required for the assignment.
+    * to build: >> make
+* user_tests/getcolors.c
+    * contains the getcolors user program that will get the colors of the given processes.
+    * to build: >> make
+* user_tests/setcolors.c
+    * containts the setcolors program that will set the colors of the given processes.
+    * to build >> make
+* user_tests/Makefile
+
+# System Call Numbers
 * x86_32:
     * set_colors - 223
     * get_colors - 251
@@ -32,21 +38,5 @@ TODO:
 * arm:
     * set_colors - 361
     * get_colors - 362
-
-## Notes:
-* tasklist_lock is the lock used, not the function
-* task_lock
-
-
-* Blog entry zhangsen.org ... mentioned there is a difference for defining system calls.  Says to edit `include/asm/unistd_64.h` which does not exist in our version of the kernel.
-* Check on system call 222 in x86
-
-### Binder:
-You know the bin
-
-
-## References
-https://lwn.net/Articles/21835/
-
-## Part 1
+# Part 1
 2.6.29, riley@algiers #32 Thu Feb 28 09:11:03 EST 2013
diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 2efd6d4..089fd2e 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -1371,13 +1371,10 @@ binder_transaction(struct binder_proc *proc, struct binder_thread *thread,
 		}
 
 		/** 
-		 * Added by: Riley Spahn
+		 * Added by: Riley Spahn and Meng Yao
 		 * We should be able to test for the same pids here and throw
 		 * and errof if needed.
 		 */
-		/*
-		*Code added by Meng Yao
-		*/
 		if ((target_proc->tsk->color != 0) && (proc->tsk->color != 0) 
 		&& (target_proc->tsk->color != proc->tsk->color)) {
 				return_error = BR_FAILED_REPLY;
diff --git a/kernel/color.c b/kernel/color.c
index ef180ad..301c3f9 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -63,6 +63,8 @@ int set_color(pid_t pid, u_int16_t color)
  */
 int get_color(pid_t pid)
 {
+
+	/* add something like an rcu here */
 	struct task_struct *crnt_tsk;
 	crnt_tsk = find_task_by_vpid(pid);
 	if (crnt_tsk == NULL)
diff --git a/user_tests/Makefile b/user_tests/Makefile
index 053d7a6..9cf5f60 100644
--- a/user_tests/Makefile
+++ b/user_tests/Makefile
@@ -22,7 +22,7 @@ BIN := $(BINDIR)/bin
 CPP := $(BIN)/$(ANDROID_TARGET)-g++
 CC := $(BIN)/$(ANDROID_TARGET)-gcc
 CFLAGS := -I$(INCDIR)
-LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS := -Wall -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
 LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
  
 progs: $(FORK) $(SET) $(GET)
-- 
1.7.9.5


From 333f327d60d23b81b5de6a128265a92bafa686f5 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Fri, 1 Mar 2013 20:51:20 -0500
Subject: [PATCH 36/64] -added an rcu to get color. -added correct KERN_
 levels to prinks

---
 kernel/color.c |   52 +++++++++++++++++++++++++++++-----------------------
 1 file changed, 29 insertions(+), 23 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 301c3f9..1f5fdf0 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -50,8 +50,8 @@ int set_color(pid_t pid, u_int16_t color)
 		crnt_tsk->color = color;
 		return_val = crnt_tsk->tgid;
 		write_unlock(&tasklist_lock);
-		printk("Setting %d color: %d\n", pid, color);
-		printk("crnttsk color = %d\n", crnt_tsk->color);
+		printk(KERN_DEBUG "Setting %d color: %d\n", pid, color);
+		printk(KERN_DEBUG "crnttsk color = %d\n", crnt_tsk->color);
 	}
 	/* unlock the task list */
 
@@ -66,11 +66,17 @@ int get_color(pid_t pid)
 
 	/* add something like an rcu here */
 	struct task_struct *crnt_tsk;
+
+	rcu_read_lock();
 	crnt_tsk = find_task_by_vpid(pid);
-	if (crnt_tsk == NULL)
+	if (crnt_tsk == NULL) {
+		rcu_read_unlock();
 		return -EINVAL;
-	else
-		return crnt_tsk->color;
+	} else {
+		u_int16_t ret_color = crnt_tsk->color;
+		rcu_read_unlock();
+		return ret_color;
+	}
 }
 
 
@@ -98,7 +104,7 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 
 	/* Must have root privledges */
 	if (current_uid() != 0) {
-		printk("User must be root.\n");
+		printk(KERN_DEBUG "User must be root.\n");
 		return -EACCES;
 	}
 
@@ -109,18 +115,18 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	/* Allocate memory for all needed arrays. */
 	k_pids = kmalloc(pids_size, GFP_KERNEL);
 	if (k_pids == NULL) {
-		printk("Failed to kallocate for k_pids\n");
+		printk(KERN_DEBUG "Failed to kallocate for k_pids\n");
 		return -EINVAL;
 	}
 	k_colors = kmalloc(colors_size, GFP_KERNEL);
 	if (k_colors == NULL) {
-		printk("Failed to kallocate for k_colors\n");
+		printk(KERN_DEBUG "Failed to kallocate for k_colors\n");
 		kfree(k_pids);
 		return -EINVAL;
 	}
 	k_retval = kmalloc(retval_size, GFP_KERNEL);
 	if (k_retval == NULL) {
-		printk("Failed to kallocate for k_retval\n");
+		printk(KERN_DEBUG "Failed to kallocate for k_retval\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		return -EINVAL;
@@ -128,26 +134,26 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 
 	/* Copy the data from user space. */
 	if (access_ok(VERIFY_READ, colors, pids_size) == 0) {
-		printk("Colors not ok to read from user space.");
+		printk(KERN_DEBUG "Colors not ok to read from user space.");
 		bytes_copied = 1;
 	} else {
 		bytes_copied = copy_from_user(k_colors, colors, colors_size);
 	}
 	if (bytes_copied != 0) {
-		printk("Failed to copy bytes for k_bytes\n");
+		printk(KERN_DEBUG "Failed to copy bytes for k_bytes\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		kfree(k_retval);
 		return -EINVAL;
 	}
 	if (access_ok(VERIFY_READ, pids, pids_size) == 0) {
-		printk("pids not ok to read from user space\n");
+		printk(KERN_DEBUG "pids not ok to read from user space\n");
 		bytes_copied = 1;
 	} else {
 		bytes_copied = copy_from_user(k_pids, pids, pids_size);
 	}
 	if (bytes_copied != 0) {
-		printk("Failed to copy bytes for k_pids\n");
+		printk(KERN_DEBUG "Failed to copy bytes for k_pids\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		kfree(k_retval);
@@ -167,7 +173,7 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	}
 
 	if (access_ok(VERIFY_WRITE, retval, retval_size) == 0) {
-		printk("retval not ok to write.\n");
+		printk(KERN_DEBUG "retval not ok to write.\n");
 		bytes_copied = 1;
 	} else {
 		bytes_copied = copy_to_user(retval, k_retval, retval_size);
@@ -183,7 +189,7 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	kfree(k_colors);
 	kfree(k_retval);
 
-	printk("Finished set_color function\n");
+	printk(KERN_DEBUG "Finished set_color function\n");
 	return ret_value;
 }
 
@@ -213,7 +219,7 @@ SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 
 	/* Must be root. */
 	if (current_uid() != 0) {
-		printk("Must be root to get colors.\n");
+		printk(KERN_DEBUG "Must be root to get colors.\n");
 		return -EACCES;
 	}
 
@@ -223,25 +229,25 @@ SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 
 	k_pids = kmalloc(pids_size, GFP_KERNEL);
 	if (k_pids == NULL) {
-		printk("Failed to kallocate for k_pids\n");
+		printk(KERN_DEBUG "Failed to kallocate for k_pids\n");
 		return -EINVAL;
 	}
 	k_colors = kmalloc(colors_size, GFP_KERNEL);
 	if (k_colors == NULL) {
-		printk("Failed to kallocate for k_colors\n");
+		printk(KERN_DEBUG "Failed to kallocate for k_colors\n");
 		kfree(k_pids);
 		return -EINVAL;
 	}
 	k_retval = kmalloc(retval_size, GFP_KERNEL);
 	if (k_retval == NULL) {
-		printk("Failed to kallocate for k_retval\n");
+		printk(KERN_DEBUG "Failed to kallocate for k_retval\n");
 		kfree(k_pids);
 		kfree(k_colors);
 		return -EINVAL;
 	}
 
 	if (access_ok(VERIFY_READ, pids, pids_size) == 0) {
-		printk("pids not ok to read.\n");
+		printk(KERN_DEBUG "pids not ok to read.\n");
 		bytes_copied = 1;
 	} else {
 		bytes_copied = copy_from_user(k_pids, pids, pids_size);
@@ -255,7 +261,7 @@ SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	ret_value = 0;
 	for (i = 0; i < nr_pids; i++) {
 		color_return = get_color(k_pids[i]);
-		printk("color_return = %d\n", color_return);
+		printk(KERN_DEBUG "color_return = %d\n", color_return);
 		if (color_return == -EINVAL) {
 			ret_value = -EINVAL;
 			k_retval[i] = -EINVAL;
@@ -267,7 +273,7 @@ SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	}
 
 	if (access_ok(VERIFY_WRITE, retval, retval_size) == 0) {
-		printk("retval not ok to write.\n");
+		printk(KERN_DEBUG "retval not ok to write.\n");
 		bytes_copied = 1;
 	} else {
 		bytes_copied = copy_to_user(retval, k_retval, retval_size);
@@ -280,7 +286,7 @@ SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	}
 
 	if (access_ok(VERIFY_WRITE, colors, colors_size) == 0) {
-		printk("colors not ok to write.");
+		printk(KERN_DEBUG "colors not ok to write.");
 		bytes_copied = 1;
 	} else {
 		bytes_copied = copy_to_user(colors, k_colors, colors_size);
-- 
1.7.9.5


From 2d8195feac7a1e727f1c62ee98a5751d92de6879 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sat, 2 Mar 2013 11:00:31 -0500
Subject: [PATCH 37/64] added a warning message if the number of processes in
 colors tests is larger than the value we set

---
 user_tests/getcolors.c |   64 +++++++++++++++++++++++++-----------------------
 user_tests/setcolors.c |   30 ++++++++++++-----------
 2 files changed, 50 insertions(+), 44 deletions(-)

diff --git a/user_tests/getcolors.c b/user_tests/getcolors.c
index 72f4b92..6342b53 100644
--- a/user_tests/getcolors.c
+++ b/user_tests/getcolors.c
@@ -8,44 +8,43 @@
 #include <sys/types.h>
 #include <sys/syscall.h>
 #include <unistd.h>
+
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
 #define __NR_get_colors 251
 
-
-
 int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 {
-    struct dirent *d;
-    FILE *fp;
-    DIR *dir;
-    char filepath[FILE_LEN];
-    char filetext[FILE_LEN];
-    int index;
-    dir = opendir("/proc");
-    if (!dir) {
-	perror("Open proc directory failed!");
-	exit(EXIT_FAILURE);
-    }
-    while ((d = readdir(dir)) != NULL) {
-	if ((strcmp(d->d_name, ".") == 0) || (strcmp(d->d_name, "..") == 0))
-		continue;
-	sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-	fp = fopen(filepath, "r");
-	if (fp != NULL) {
-		fread(filetext, 1, FILE_LEN, fp);
-		filetext[FILE_LEN-1] = '\0';
-	for (index = 0; index < nr_pids; index++) {
-		if (filetext == strstr(filetext, procName[index]))
-			pids[index] = atoi(d->d_name);
+	struct dirent *d;
+	FILE *fp;
+	DIR *dir;
+	char path[FILE_LEN];
+	char cmdline[FILE_LEN];
+	int index;
+	dir = opendir("/proc");
+	if (!dir) {
+		perror("Open proc directory failed!");
+		exit(EXIT_FAILURE);
 	}
-	fclose(fp);
+	while ((d = readdir(dir)) != NULL) {
+		sprintf(path, "/proc/%s/cmdline", d->d_name);
+		fp = fopen(path, "r");
+		if (fp != NULL) {
+			fread(cmdline, 1, FILE_LEN, fp);
+			cmdline[FILE_LEN - 1] = '\0';
+			for (index = 0; index < nr_pids; index++) {
+				if (cmdline == strstr(cmdline,
+					 procName[index]))
+					pids[index] = atoi(d->d_name);
+			}
+		fclose(fp);
+		}
 	}
-    }
-    closedir(dir);
-    return 0;
+	closedir(dir);
+	return 0;
 }
 
+
 void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			int *retval, char *procName[])
 {
@@ -53,9 +52,10 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 	printf("\n*********************************************************");
 	printf("*****************\n");
 	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0)
+		if (pids[index] == 0) {		
+			printf("[%d]", index);
 			printf("Process %s does not exist\n", procName[index]);
-		else {
+		} else {
 			printf("[%d]", index);
 			printf("process name:%s      ", procName[index]);
 			printf("pid:%d      ", pids[index]);
@@ -83,6 +83,10 @@ int main(int argc, char *argv[])
 		printf("Please provide a name of a process.\n");
 		return -1;
 	}
+	if (argc > (MAX_PROC_NUM + 1)) {
+		printf("Too many processes!\n");
+		return -1;
+	}
 	nr_pids = argc - 1;
 	for (i = 0; i < nr_pids; i++) {
 		procName[i] = argv[i + 1];
diff --git a/user_tests/setcolors.c b/user_tests/setcolors.c
index 26b9211..bbd8dac 100644
--- a/user_tests/setcolors.c
+++ b/user_tests/setcolors.c
@@ -20,8 +20,8 @@ int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 	struct dirent *d;
 	FILE *fp;
 	DIR *dir;
-	char filepath[FILE_LEN];
-	char filetext[FILE_LEN];
+	char path[FILE_LEN];
+	char cmdline[FILE_LEN];
 	int index;
 	dir = opendir("/proc");
 	if (!dir) {
@@ -29,16 +29,13 @@ int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 		exit(EXIT_FAILURE);
 	}
 	while ((d = readdir(dir)) != NULL) {
-		if ((strcmp(d->d_name, ".") == 0) ||
-			(strcmp(d->d_name, "..") == 0))
-			continue;
-		sprintf(filepath, "/proc/%s/cmdline", d->d_name);
-		fp = fopen(filepath, "r");
+		sprintf(path, "/proc/%s/cmdline", d->d_name);
+		fp = fopen(path, "r");
 		if (fp != NULL) {
-			fread(filetext, 1, FILE_LEN, fp);
-			filetext[FILE_LEN-1] = '\0';
+			fread(cmdline, 1, FILE_LEN, fp);
+			cmdline[FILE_LEN - 1] = '\0';
 			for (index = 0; index < nr_pids; index++) {
-				if (filetext == strstr(filetext,
+				if (cmdline == strstr(cmdline,
 					 procName[index]))
 					pids[index] = atoi(d->d_name);
 			}
@@ -53,12 +50,13 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			int *retval, char *procName[])
 {
 	int index;
-	printf("***********************************************************");
+	printf("\n***********************************************************");
 	printf("************\n");
 	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0)
+		if (pids[index] == 0) {	
+			printf("[%d]", index);
 			printf("Process %s does not exist\n", procName[index]);
-		else {
+		} else {
 			printf("[%d]", index);
 			printf("process name:%s      ", procName[index]);
 			printf("pid:%d      ", pids[index]);
@@ -67,7 +65,7 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 		}
 	}
 	printf("***********************************************************");
-	printf("************\n");
+	printf("************\n\n");
 }
 
 int main(int argc, char *argv[])
@@ -93,6 +91,10 @@ int main(int argc, char *argv[])
 		printf("identical.\n");
 		return -1;
 	}
+	if (argc > (2 * MAX_PROC_NUM + 1)) {
+		printf("Too many processes!\n");
+		return -1;
+	}
 	nr_pids = argc / 2;
 	for (i = 0; i < nr_pids; i++)
 		retval[i] = 0;
-- 
1.7.9.5


From 6b315c77ddaf31790a6b2e51bba0d960c6846c66 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 11:26:20 -0500
Subject: [PATCH 38/64] -added the framework for cloning. - for some reason
 CLONE_IO is not being found at compile time. -changed
 exit codes to 1 in error situations. -I think we may
 be able to use sys_clone since clone() is just a
 wrapper for it.  Not sure if it is there on android.

---
 user_tests/forktest.c |   49 ++++++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 46 insertions(+), 3 deletions(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index ea1f9c9..64c5868 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -9,13 +9,19 @@
 #include <sched.h>
 #include <signal.h>
 
+/* 64kb stack. 1024 * 64 = 65536 */
+#define STACK_SIZE 65536
+
 void forktest(int agm_num, char *agm[])
 {
 	char *tmp[10];
 	int delay;
 	int pid;
-	int index = 0;
+	int index;
 	int i, j;
+	int flags;
+	void *stack;
+
 	index = 0;
 	delay = atoi(agm[index + 1]);
 	sleep(delay);
@@ -36,7 +42,7 @@ void forktest(int agm_num, char *agm[])
 					tmp[j] = NULL;
 					execvp(tmp[0], tmp);
 					perror("Command not found");
-					exit(0);
+					exit(1);
 				 }
 			} else
 				waitpid(pid, NULL, 0);
@@ -58,11 +64,48 @@ void forktest(int agm_num, char *agm[])
 					tmp[j] = NULL;
 					execvp(tmp[0], tmp);
 					perror("Command not found");
-					exit(0);
+					exit(1);
 				}
 			} else
 				waitpid(pid, NULL, 0);
 		}
+	} else if (strcmp(agm[index + 2], "clone") == 0){
+		stack = malloc(STACK_SIZE);
+		if (stack == NULL) {
+			perror("Failed to allocate memory for stack.\n");
+			exit(1);
+		}
+		/*
+		 * FILES - shared file descriptor table
+		 * FS - shared file system info i.e. cwd, root.
+		 * IO - share IO context so they are treated as the same by
+		 * the scheduler. Need to add bc not compiling with it. TODO
+		 * PARENT - share the same parent pid.
+		 * THREAD - share the same thread group.
+		 * VM - share the same memory space.
+		 *
+		 * look at sys_clone
+		 */
+		flags = CLONE_FILES | CLONE_FS | CLONE_PARENT | CLONE_THREAD |
+			CLONE_VM;
+		/* TODO - need to add function. */
+		pid = clone(NULL, flags, 0);
+		if (pid < 0) {
+			perror("Failed to clone.\n");
+			free(stack);
+			exit(1);
+		} else if (pid == 0) {
+			/* TODO - handle exec */
+			printf("Handling exec.\n");
+			exit(0);
+		} else {
+			if (waitpid(pid, NULL, 0) == -1) {
+				perror("Error waiting for pid: %d\n", pid);
+				free(stack);
+				exit(1);
+			}
+			free(stack);
+		}
 	} else
 		printf("Not a valid command!\n");
 }
-- 
1.7.9.5


From 7059cf5e649cfb545034d22af5d8d707ad635ee4 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 11:28:59 -0500
Subject: [PATCH 39/64] -changed perror to fprintf to use a custom error
 message.

---
 user_tests/forktest.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 64c5868..09c4cf0 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -100,7 +100,8 @@ void forktest(int agm_num, char *agm[])
 			exit(0);
 		} else {
 			if (waitpid(pid, NULL, 0) == -1) {
-				perror("Error waiting for pid: %d\n", pid);
+				fprintf(stderr, "Error waiting for pid: %d\n",
+						pid);
 				free(stack);
 				exit(1);
 			}
-- 
1.7.9.5


From 1d91a1a37bb4b66e1752c13a3a6b7aff1daaa5a4 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 11:35:11 -0500
Subject: [PATCH 40/64] -changed parameter to clone to point to the top of the
 stack.

---
 user_tests/forktest.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 09c4cf0..e78cb6c 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -89,7 +89,7 @@ void forktest(int agm_num, char *agm[])
 		flags = CLONE_FILES | CLONE_FS | CLONE_PARENT | CLONE_THREAD |
 			CLONE_VM;
 		/* TODO - need to add function. */
-		pid = clone(NULL, flags, 0);
+		pid = clone(stack + STACK_SIZE, flags, 0);
 		if (pid < 0) {
 			perror("Failed to clone.\n");
 			free(stack);
-- 
1.7.9.5


From 155615c473729c6a649366be38a4eed88576b2c0 Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Sat, 2 Mar 2013 13:55:42 -0500
Subject: [PATCH 41/64]  modified vfork() in forktest and added coversheet 
 Please enter the commit message for your changes.
 Lines starting

---
 COVER_SHEET_HW2.txt   |  109 +++++++++++++++++++++++++++++++++++++++++++++++++
 user_tests/forktest.c |   11 ++---
 2 files changed, 115 insertions(+), 5 deletions(-)
 create mode 100644 COVER_SHEET_HW2.txt

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
new file mode 100644
index 0000000..fc3359f
--- /dev/null
+++ b/COVER_SHEET_HW2.txt
@@ -0,0 +1,109 @@
+Spring 2013 Programming Assignment
+
+Assignment Number: HW2
+   
+Group Number: Group11
+
+Name and UNI of Group Member 1: ___rbs2152_______________
+   
+Name and UNI of Group Member 2: ___pq2117________________
+
+Name and UNI of Group Member 3: ___my2372_________________
+   
+
+We certify that:
+   	   _ Our code compiles and works for all reasonable inputs
+	   _ Our code compiles, but does not work for all inputs
+	   _ Our code does not compile
+
+    * While we may have discussed the assignment with others, the code
+       submitted is entirely our own group's work and no other student 
+       has edited it.
+     * So far as we have been able to determine, the program properly
+       handles all reasonable inputs.
+
+   Further instructions to the student: 
+     * Check your code to make sure it is readable. You may wish to
+       add some comments, change a variable name, or even restructure the
+       code. This also often helps you find bugs in the code.
+     * Include this file with the files you submit for your
+       programming assignment.  The file should be named  "pg_cover.txt".
+
+     * Describe below how each member of your group contributed to the
+       assignment.  Include a list of C functions and files that you modified
+       or implemented and which group member was primarily responsible
+       for doing each.  All group members are expected to contribute in
+       writing the code for each assignment.
+       
+Member Contributions:
+
+Riley Spahn(rbs2152): 
+
+
+
+
+
+Pei Qin(pq2117):
+
+
+
+
+
+Meng Yao(my2372):
+
+
+
+
+
+
+
+If your program does not work for all test inputs or does not compile,
+please complete the following section. You should describe below what 
+the bug is and how you tried to debug it. Document only the most
+significant bug. This is you chance to get partial credit for code
+that does not pass testing. If you do not make a good faith effort to fill this
+section in when you know your code doesn't compile/work, you may
+automatically be given a zero for those parts of the assignment
+
+     * Describe the conditions that cause the program to fail. For
+       example, you may know that it always fails for a particular input
+       or kind of input. Or you may know that it always fails when try it
+       for the second time, or when a certain procedure gets called with
+       a certain argument or when a particular global variable has a
+       particular value.
+       
+     
+
+
+
+     * When the program fails, what error message or other output does it
+       generate?
+       
+     
+     
+     
+     * What does the error message mean? 
+       
+     
+     
+     
+     * When the program fails, which of your procedures is it running?
+       
+     
+     
+     * In your source code, put comments /*** Buggy code here ***/
+       around the line that it is executing when it fails. Describe
+       below how you know that this is the right line.  If you can't 
+       determine which line then put BOLD comments around the 
+       different possible lines it could be executing. 
+       
+     
+     
+     * Do you believe the bug is in this procedure? If not, do you think
+       it's in a procedure that called it, or in some procedure that was
+       executed previously and that either returned a bad value, or that
+       placed a bad value in a variable someplace? Why? Note: we're not
+       asking you to get this right. We're just asking you to give a
+       plausible answer with a plausible justification, enough to show
+       that you're developing sound reasoning processes for diagnosis.
+ 
diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index ea1f9c9..a0426e4 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -15,7 +15,9 @@ void forktest(int agm_num, char *agm[])
 	int delay;
 	int pid;
 	int index = 0;
-	int i, j;
+	int i;
+	int j;
+
 	index = 0;
 	delay = atoi(agm[index + 1]);
 	sleep(delay);
@@ -60,9 +62,7 @@ void forktest(int agm_num, char *agm[])
 					perror("Command not found");
 					exit(0);
 				}
-			} else
-				waitpid(pid, NULL, 0);
-		}
+			exit(0);
 	} else
 		printf("Not a valid command!\n");
 }
@@ -70,7 +70,8 @@ void forktest(int agm_num, char *agm[])
 int main(int argc, char *argv[])
 {
 	char *str[argc];
-	int i, j;
+	int i;
+	int j;
 
 	if (strcmp(argv[0], "./forktest") == 0) {
 		if (argc < 4) {
-- 
1.7.9.5


From a573c098e714a6c2fe0ab8371de2f35bd1de52b3 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 14:09:23 -0500
Subject: [PATCH 42/64] corrected makefile.

---
 kernel/color.c      |    3 +--
 user_tests/Makefile |   56 +++++++++++++++++++++++++--------------------------
 2 files changed, 28 insertions(+), 31 deletions(-)

diff --git a/kernel/color.c b/kernel/color.c
index 1f5fdf0..ce1267b 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -12,7 +12,6 @@
  */
 int set_tg_color(pid_t tgid, u_int16_t color)
 {
-	/* TODO - look at locks*/
 	struct task_struct *p;
 	write_lock(&tasklist_lock);
 	for_each_process(p) {
@@ -162,7 +161,7 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 	ret_value = 0;
 	for (i = 0; i < nr_pids; i++) {
 		tgid = set_color(k_pids[i], k_colors[i]);
-		if (tgid < 0) {
+		if (tgid == -EINVAL) {
 			ret_value = -EINVAL;
 			k_retval[i] = -EINVAL;
 		} else {
diff --git a/user_tests/Makefile b/user_tests/Makefile
index 9cf5f60..2b4317f 100644
--- a/user_tests/Makefile
+++ b/user_tests/Makefile
@@ -1,8 +1,7 @@
-SET  := setcolors
-GET  := getcolors
-FORK := forktest
-
 APP := test
+FORK := forktest
+SET := setcolors
+GET := getcolors
 ROOT:=$(HOME)
 NDK_PLATFORM_VER := 14
 INSTALL_DIR := /data/tmp
@@ -22,46 +21,45 @@ BIN := $(BINDIR)/bin
 CPP := $(BIN)/$(ANDROID_TARGET)-g++
 CC := $(BIN)/$(ANDROID_TARGET)-gcc
 CFLAGS := -I$(INCDIR)
-LDFLAGS := -Wall -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
+LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
 LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
  
-progs: $(FORK) $(SET) $(GET)
  
-all: progs
-
-$(SET): setcolors.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-$(GET): getcolors.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-$(FORK): forktest.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-
+all: app
+ 
  
-OBJS += $(APP).o
+app: object
+	$(CC) $(LDFLAGS) -o $(FORK) $(FORK).o
+	$(CC) $(LDFLAGS) -o $(SET) $(SET).o
+	$(CC) $(LDFLAGS) -o $(GET) $(GET).o
 
+ 
+object: forktest.c getcolors.c setcolors.c
+	$(CC) -c $(INCLUDE) $(CFLAGS) $(GET).c -o $(GET).o
+	$(CC) -c $(INCLUDE) $(CFLAGS) $(FORK).c -o $(FORK).o
+	$(CC) -c $(INCLUDE) $(CFLAGS) $(SET).c -o $(SET).o
+	
 
-# @ =  left side of ":"
-# ^ = right side of ":"
-# < = first item in dep list
-%.o: %.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
 
-install: progs
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(GET)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(SET)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+install: app
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(FORK) $(INSTALL_DIR)/$(FORK) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(SET) $(INSTALL_DIR)/$(SET) 
+	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(GET) $(INSTALL_DIR)/$(GET) 
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(FORK)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(SET)
+	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(GET)
  
 shell:
 	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
  
+#run:
+#	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
+ 
 #r: $(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
+#	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
 #	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
 #	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
  
 clean:
-	@rm -f $(APP).o $(APP) $(GET) $(SET) $(FORK)
+	@rm -f *.o $(FORK) $(SET) $(GET)
 
-- 
1.7.9.5


From 1c84b3f7d9a146b3478de27803c54defbe19a33a Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Sat, 2 Mar 2013 14:22:07 -0500
Subject: [PATCH 43/64] fix the conflicts in forktest.c

---
 user_tests/forktest.c |    4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 4166c77..449a1a3 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -20,8 +20,6 @@ void forktest(int agm_num, char *agm[])
 	int index = 0;
 	int i;
 	int j;
-	int index;
-	int i, j;
 	int flags;
 	void *stack;
 
@@ -57,7 +55,7 @@ void forktest(int agm_num, char *agm[])
 		else {
 			if (pid == 0) {
 				if (strcmp(agm[index + 3], "forktest") == 0) {
-					for (i =a 0; i < agm_num - 3; i++)
+					for (i =0; i < agm_num - 3; i++)
 						agm[i] = agm[i + 3];
 					agm_num = agm_num - 3;
 					forktest(agm_num, agm);
-- 
1.7.9.5


From 33886332f5c04b87c1dc23e041d137de341ff778 Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Sat, 2 Mar 2013 14:26:47 -0500
Subject: [PATCH 44/64] modified README FILE

---
 README_HW2.md |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/README_HW2.md b/README_HW2.md
index a101d0d..00811e0 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -24,6 +24,9 @@ README for OS Homework Assignment 2
     * containts the setcolors program that will set the colors of the given processes.
     * to build >> make
 * user_tests/Makefile
+* user_test/forktest.c
+    *contains the forktest program that will execute fork(),vfork(),clone() syscall.
+    * to build >>make
 
 # System Call Numbers
 * x86_32:
-- 
1.7.9.5


From b1aa642c756c7fbbbd257d92c3a4f1a0b32e2cdb Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 14:44:56 -0500
Subject: [PATCH 45/64] -removed clone call that is not supported under
 android x86.

---
 user_tests/forktest.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index e78cb6c..07cb4c9 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -89,7 +89,7 @@ void forktest(int agm_num, char *agm[])
 		flags = CLONE_FILES | CLONE_FS | CLONE_PARENT | CLONE_THREAD |
 			CLONE_VM;
 		/* TODO - need to add function. */
-		pid = clone(stack + STACK_SIZE, flags, 0);
+		/* pid = clone(stack + STACK_SIZE, flags, 0); */
 		if (pid < 0) {
 			perror("Failed to clone.\n");
 			free(stack);
-- 
1.7.9.5


From 3c76563a37b867e34d4232a4c2df161ace6b045b Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 15:35:53 -0500
Subject: [PATCH 46/64] -added struct to pass to pthread_create. -added
 function to execute in the pthread.

---
 user_tests/forktest.c |   54 +++++++++++++++++++++++++++----------------------
 1 file changed, 30 insertions(+), 24 deletions(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 07cb4c9..fcea40a 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -1,17 +1,33 @@
+#include <pthread.h>
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <dirent.h>
 #include <sys/types.h>
 #include <sys/syscall.h>
-#include <unistd.h>
 #include <sys/wait.h>
 #include <sched.h>
 #include <signal.h>
+#include <unistd.h>
 
 /* 64kb stack. 1024 * 64 = 65536 */
 #define STACK_SIZE 65536
 
+struct execparam {
+	char *file;
+	char **argv;
+};
+
+void *execclone(void *input)
+{
+	struct execparam *toexec;
+	toexec = (struct execparam *)input;
+	if (execvp(toexec->file, toexec->argv) == -1) {
+		perror("Failed to exec in cloned pthread.\n");
+		exit(1);
+	}
+}
+
 void forktest(int agm_num, char *agm[])
 {
 	char *tmp[10];
@@ -69,42 +85,32 @@ void forktest(int agm_num, char *agm[])
 			} else
 				waitpid(pid, NULL, 0);
 		}
-	} else if (strcmp(agm[index + 2], "clone") == 0){
+	} else if (strcmp(agm[index + 2], "clone") == 0) {
 		stack = malloc(STACK_SIZE);
 		if (stack == NULL) {
 			perror("Failed to allocate memory for stack.\n");
 			exit(1);
 		}
-		/*
-		 * FILES - shared file descriptor table
-		 * FS - shared file system info i.e. cwd, root.
-		 * IO - share IO context so they are treated as the same by
-		 * the scheduler. Need to add bc not compiling with it. TODO
-		 * PARENT - share the same parent pid.
-		 * THREAD - share the same thread group.
-		 * VM - share the same memory space.
-		 *
-		 * look at sys_clone
-		 */
-		flags = CLONE_FILES | CLONE_FS | CLONE_PARENT | CLONE_THREAD |
-			CLONE_VM;
-		/* TODO - need to add function. */
-		/* pid = clone(stack + STACK_SIZE, flags, 0); */
+
+		for (j = 0; j < agm_num - 3; j++)
+			tmp[j] = agm[3 + j];
+		tmp[j] = NULL;
+
+		pthread_t thread;
+		struct execparam params;
+		params.file = tmp[0];
+		params.argv = tmp;
+		pid = pthread_create(&thread, NULL, execclone, &params);
 		if (pid < 0) {
 			perror("Failed to clone.\n");
 			free(stack);
 			exit(1);
-		} else if (pid == 0) {
+		} else if (pid) {
 			/* TODO - handle exec */
 			printf("Handling exec.\n");
 			exit(0);
 		} else {
-			if (waitpid(pid, NULL, 0) == -1) {
-				fprintf(stderr, "Error waiting for pid: %d\n",
-						pid);
-				free(stack);
-				exit(1);
-			}
+			pthread_exit(NULL);
 			free(stack);
 		}
 	} else
-- 
1.7.9.5


From 02ac3c093d34109b935aa82f3865188ee051c36d Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sat, 2 Mar 2013 15:58:26 -0500
Subject: [PATCH 47/64] -removed the references to the stack from when we were
 manually allocating stack during cloning.

---
 user_tests/forktest.c |   12 ------------
 1 file changed, 12 deletions(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index cb323b7..bdff7df 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -10,9 +10,6 @@
 #include <signal.h>
 #include <unistd.h>
 
-/* 64kb stack. 1024 * 64 = 65536 */
-#define STACK_SIZE 65536
-
 struct execparam {
 	char *file;
 	char **argv;
@@ -37,7 +34,6 @@ void forktest(int agm_num, char *agm[])
 	int i;
 	int j;
 	int flags;
-	void *stack;
 
 	index = 0;
 	delay = atoi(agm[index + 1]);
@@ -88,12 +84,6 @@ void forktest(int agm_num, char *agm[])
 				waitpid(pid, NULL, 0);
 		}
 	} else if (strcmp(agm[index + 2], "clone") == 0) {
-		stack = malloc(STACK_SIZE);
-		if (stack == NULL) {
-			perror("Failed to allocate memory for stack.\n");
-			exit(1);
-		}
-
 		for (j = 0; j < agm_num - 3; j++)
 			tmp[j] = agm[3 + j];
 		tmp[j] = NULL;
@@ -105,7 +95,6 @@ void forktest(int agm_num, char *agm[])
 		pid = pthread_create(&thread, NULL, execclone, &params);
 		if (pid < 0) {
 			perror("Failed to clone.\n");
-			free(stack);
 			exit(1);
 		} else if (pid) {
 			/* TODO - handle exec */
@@ -113,7 +102,6 @@ void forktest(int agm_num, char *agm[])
 			exit(0);
 		} else {
 			pthread_exit(NULL);
-			free(stack);
 		}
 	} else
 		printf("Not a valid command!\n");
-- 
1.7.9.5


From bd0872b9fb6263280db215ae86dabb3a6809e9f6 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 2 Mar 2013 16:06:35 -0500
Subject: [PATCH 48/64] -updated README with notes about forktest. -added
 contributions to the coversheet.

---
 COVER_SHEET_HW2.txt |   13 ++++++++++---
 README_HW2.md       |    7 +++++--
 2 files changed, 15 insertions(+), 5 deletions(-)

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
index fc3359f..cea9a10 100644
--- a/COVER_SHEET_HW2.txt
+++ b/COVER_SHEET_HW2.txt
@@ -36,9 +36,16 @@ We certify that:
        writing the code for each assignment.
        
 Member Contributions:
-
-Riley Spahn(rbs2152): 
-
+* We all worked together at the same computer when modifying the system call tables for each architecture.
+
+# Riley Spahn(rbs2152): 
+* Wrote initial version of the get_colors system call.
+* Wrote initial version of the set_colors system call.
+* Wrote the get_color helper.
+* Wrote the set_color helper.
+* Wrote the set_tg_color helper.
+* Researched and noted where we should modify the binder source code.
+* Wrote the clone section of forktest.
 
 
 
diff --git a/README_HW2.md b/README_HW2.md
index 00811e0..20d1468 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -11,7 +11,7 @@ README for OS Homework Assignment 2
     * Added to the copy_process function that will propogate the parent processes color to the child.
     * Added to the do_fork function that will ensure that the color does not propogate if vfork is called instead of clone or fork.
 * drivers/stagin/android/binder.c
-    *added conditional to binder_transaction that will test if the src and dest process have the same color or 0 color and if not will return execute the err_dead_binder error condition.
+    * added conditional to binder_transaction that will test if the src and dest process have the same color or 0 color and if not will return execute the err_dead_binder error condition.
 * include/linux/sched.h
     * added the u_int16_t color field to the task_struct.
 * user_tests/forktest.c
@@ -25,8 +25,10 @@ README for OS Homework Assignment 2
     * to build >> make
 * user_tests/Makefile
 * user_test/forktest.c
-    *contains the forktest program that will execute fork(),vfork(),clone() syscall.
+    * contains the forktest program that will execute fork(),vfork(),clone() syscall.
     * to build >>make
+    * Note: Since the clone sytem call is not available on x86 we are using threads as a substitute.  Threads are implemented using clone so in this way we are indirectly testing clone.
+    * When executing forktest you must use the ./ notation unless the program is in your path.  As an example you will need to do: ./forktest 10 fork ./forktest 10 fork ls
 
 # System Call Numbers
 * x86_32:
@@ -41,5 +43,6 @@ README for OS Homework Assignment 2
 * arm:
     * set_colors - 361
     * get_colors - 362
+
 # Part 1
 2.6.29, riley@algiers #32 Thu Feb 28 09:11:03 EST 2013
-- 
1.7.9.5


From 09c7d0b61697febc049ff80d2165a3a04f17187b Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Sat, 2 Mar 2013 16:16:40 -0500
Subject: [PATCH 49/64] deleted some unuseful conditions in forktest.c

---
 user_tests/forktest.c |   41 +++++++++++++----------------------------
 1 file changed, 13 insertions(+), 28 deletions(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 449a1a3..e520409 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -32,19 +32,12 @@ void forktest(int agm_num, char *agm[])
 			perror("failed to fork");
 		else {
 			if (pid == 0) {
-				if (strcmp(agm[index + 3], "forktest") == 0) {
-					for (i = 0; i < agm_num - 3; i++)
-						agm[i] = agm[i + 3];
-					agm_num = agm_num - 3;
-					forktest(agm_num, agm);
-				} else {
-					for (j = 0; j < agm_num - 3; j++)
-						tmp[j] = agm[3 + j];
-					tmp[j] = NULL;
-					execvp(tmp[0], tmp);
-					perror("Command not found");
-					exit(1);
-				 }
+				for (j = 0; j < agm_num - 3; j++)
+					tmp[j] = agm[3 + j];
+				tmp[j] = NULL;
+				execvp(tmp[0], tmp);
+				perror("Command not found");
+				exit(1);
 			} else
 				waitpid(pid, NULL, 0);
 		}
@@ -54,21 +47,13 @@ void forktest(int agm_num, char *agm[])
 			perror("failed to vfork");
 		else {
 			if (pid == 0) {
-				if (strcmp(agm[index + 3], "forktest") == 0) {
-					for (i =0; i < agm_num - 3; i++)
-						agm[i] = agm[i + 3];
-					agm_num = agm_num - 3;
-					forktest(agm_num, agm);
-				} else {
-					for (j = 0; j < agm_num - 3; j++)
-						tmp[j] = agm[3 + j];
-					tmp[j] = NULL;
-					execvp(tmp[0], tmp);
-					perror("Command not found");
-					exit(1);
-				}
-			exit(0);
-			} else
+				for (j =0; j < agm_num - 3; j++)
+					tmp[j] = agm[3 + j];
+				tmp[j] = NULL;
+				execvp(tmp[0], tmp);
+				perror("Command not found");
+				exit(1);
+			}else
 				waitpid(pid, NULL, 0);
 		}
 	} else if (strcmp(agm[index + 2], "clone") == 0){
-- 
1.7.9.5


From dcca10b922c97a4649b951fc03764a0b86f9586d Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 2 Mar 2013 16:24:30 -0500
Subject: [PATCH 50/64] -added documentation to color functions.

---
 COVER_SHEET_HW2.txt   |    2 +-
 kernel/color.c        |   18 +++++++++++++-----
 user_tests/forktest.c |   12 ++++++++++++
 3 files changed, 26 insertions(+), 6 deletions(-)

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
index cea9a10..ca55729 100644
--- a/COVER_SHEET_HW2.txt
+++ b/COVER_SHEET_HW2.txt
@@ -45,7 +45,7 @@ Member Contributions:
 * Wrote the set_color helper.
 * Wrote the set_tg_color helper.
 * Researched and noted where we should modify the binder source code.
-* Wrote the clone section of forktest.
+* Wrote the clone section of forktest which included the execparam struct and the execclone function.
 
 
 
diff --git a/kernel/color.c b/kernel/color.c
index ce1267b..b2bc820 100644
--- a/kernel/color.c
+++ b/kernel/color.c
@@ -7,8 +7,7 @@
 #include <linux/types.h>
 
 /**
- * TODO: Look into locking and thread traversal.
- * optimize this!!!
+ * Sets all of the tasks with the tgid to color.
  */
 int set_tg_color(pid_t tgid, u_int16_t color)
 {
@@ -79,8 +78,14 @@ int get_color(pid_t pid)
 }
 
 
+
 /*
- * TODO
+ * nr_pids contains the number of entries in
+ * the pids, colors, and the retval arrays. The colors array contains the
+ * color to assign to each pid from the corresponding position of
+ * the pids array. Returns 0 if all set color requests
+ * succeed. Otherwise, The array retval contains per-request
+ * error codes -EINVAL for an invalid pid, or 0 on success.
  */
 SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 		int, *retval)
@@ -194,9 +199,12 @@ SYSCALL_DEFINE4(set_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 
 
 /*
- * TODO
+ * Gets the colors of the processes
+ * contained in the pids array. Returns 0 if all set color requests
+ * succeed. Otherwise, an error code is returned. The array
+ * retval contains per-request error codes: -EINVAL for an
+ * invalid pid, or 0 on success.
  */
-
 SYSCALL_DEFINE4(get_colors, int, nr_pids, pid_t *, pids, u_int16_t *, colors,
 		int, *retval)
 {
diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index bdff7df..e03d8bd 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -10,11 +10,23 @@
 #include <signal.h>
 #include <unistd.h>
 
+/*
+ * Stucture that is used as a parameter for the execclone function.
+ * file - the file parameter of the execvp call.
+ * argv - the argv parameter of the execvp call.
+ */
 struct execparam {
 	char *file;
 	char **argv;
 };
 
+/*
+ * Function meant to executed as a pthread_create start routine.  It takes
+ * a struct execparam as an argument and uses the fields of the struct as
+ * parameters to the execvp call.  We implemented forktest clone ... as a 
+ * thread because android does not implement clone() for the x86 emulator
+ * and thread creation is implemented through clone.
+ */
 void *execclone(void *input)
 {
 	struct execparam *toexec;
-- 
1.7.9.5


From 42fbb3363df1e2792531e222a9842d7f7763878a Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sat, 2 Mar 2013 16:38:08 -0500
Subject: [PATCH 51/64] deleted unused variables

---
 user_tests/forktest.c |    1 -
 1 file changed, 1 deletion(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 37ae61b..a7cd3ed 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -45,7 +45,6 @@ void forktest(int agm_num, char *agm[])
 	int index = 0;
 	int i;
 	int j;
-	int flags;
 
 	index = 0;
 	delay = atoi(agm[index + 1]);
-- 
1.7.9.5


From 94577b350b2de11d3ecee9df2265bb632a97f366 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sat, 2 Mar 2013 16:49:23 -0500
Subject: [PATCH 52/64] added documentation to color test programs

---
 README_HW2.md |    1 +
 1 file changed, 1 insertion(+)

diff --git a/README_HW2.md b/README_HW2.md
index 20d1468..81a5acf 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -29,6 +29,7 @@ README for OS Homework Assignment 2
     * to build >>make
     * Note: Since the clone sytem call is not available on x86 we are using threads as a substitute.  Threads are implemented using clone so in this way we are indirectly testing clone.
     * When executing forktest you must use the ./ notation unless the program is in your path.  As an example you will need to do: ./forktest 10 fork ./forktest 10 fork ls
+    * When executing setcolors and getcolors test programs, you must use ./ notation and no _ between set or get and colors. Besides, the number of processes should not exceed 20. If you do type something else instead of a color after the process name, the color will be considered as 0. For example, if you type ./setcolors com.android.email com.android.phone, the program will set color 0 to com.android.email 
 
 # System Call Numbers
 * x86_32:
-- 
1.7.9.5


From 624fa77b42fc32e977865b5e656b85b4eea193b3 Mon Sep 17 00:00:00 2001
From: Riley Spahn <riley@cs.columbia.edu>
Date: Sat, 2 Mar 2013 16:53:12 -0500
Subject: [PATCH 53/64] -correct thread creation handling. -corrected style
 errors from checkpatch.

---
 user_tests/forktest.c |   23 +++++++++++------------
 1 file changed, 11 insertions(+), 12 deletions(-)

diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index a7cd3ed..7c9afd8 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -23,7 +23,7 @@ struct execparam {
 /*
  * Function meant to executed as a pthread_create start routine.  It takes
  * a struct execparam as an argument and uses the fields of the struct as
- * parameters to the execvp call.  We implemented forktest clone ... as a 
+ * parameters to the execvp call.  We implemented forktest clone ... as a
  * thread because android does not implement clone() for the x86 emulator
  * and thread creation is implemented through clone.
  */
@@ -39,6 +39,8 @@ void *execclone(void *input)
 
 void forktest(int agm_num, char *agm[])
 {
+	pthread_t thread;
+	struct execparam params;
 	char *tmp[10];
 	int delay;
 	int pid;
@@ -70,13 +72,13 @@ void forktest(int agm_num, char *agm[])
 			perror("failed to vfork");
 		else {
 			if (pid == 0) {
-				for (j =0; j < agm_num - 3; j++)
+				for (j = 0; j < agm_num - 3; j++)
 					tmp[j] = agm[3 + j];
 				tmp[j] = NULL;
 				execvp(tmp[0], tmp);
 				perror("Command not found");
 				exit(1);
-			}else
+			} else
 				waitpid(pid, NULL, 0);
 		}
 	} else if (strcmp(agm[index + 2], "clone") == 0) {
@@ -84,27 +86,23 @@ void forktest(int agm_num, char *agm[])
 			tmp[j] = agm[3 + j];
 		tmp[j] = NULL;
 
-		pthread_t thread;
-		struct execparam params;
 		params.file = tmp[0];
 		params.argv = tmp;
 		pid = pthread_create(&thread, NULL, execclone, &params);
-		if (pid < 0) {
-			perror("Failed to clone.\n");
+		if (pid != 0) {
+			fprintf(stderr, "Error: executing forktest.\n");
 			exit(1);
-		} else if (pid) {
-			/* TODO - handle exec */
-			printf("Handling exec.\n");
-			exit(0);
 		} else {
 			pthread_exit(NULL);
 		}
 	} else
-		printf("Not a valid command!\n");
+		printf(stderr, "Not a valid command!\n");
 }
 
 int main(int argc, char *argv[])
 {
+	char errormsg[] =
+		"Error: forktest <delay> <clone|fork|vfork> <command>";
 	char *str[argc];
 	int i;
 	int j;
@@ -112,6 +110,7 @@ int main(int argc, char *argv[])
 	if (strcmp(argv[0], "./forktest") == 0) {
 		if (argc < 4) {
 			printf("Please provide a complete command.\n");
+			fprintf(stderr, errormsg);
 			return -1;
 		}
 		for (i = 0; i < argc; i++)
-- 
1.7.9.5


From fcfc25e46db254621e0cb3b07fba80a5894abd40 Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Sat, 2 Mar 2013 17:16:30 -0500
Subject: [PATCH 54/64] use checkpatch on forktest.c

---
 COVER_SHEET_HW2.txt   |    8 ++++----
 user_tests/forktest.c |    8 ++++----
 2 files changed, 8 insertions(+), 8 deletions(-)

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
index ca55729..4d6780c 100644
--- a/COVER_SHEET_HW2.txt
+++ b/COVER_SHEET_HW2.txt
@@ -56,10 +56,10 @@ Pei Qin(pq2117):
 
 
 
-Meng Yao(my2372):
-
-
-
+#Meng Yao(my2372):
+*Wrote the permissions check in the binder.c and tested it.
+*Wrote the find_pid_by_name function in setcolors.c with Pei Qin.
+*Wrote the initial version of forktest.c
 
 
 
diff --git a/user_tests/forktest.c b/user_tests/forktest.c
index 37ae61b..4048c83 100644
--- a/user_tests/forktest.c
+++ b/user_tests/forktest.c
@@ -23,7 +23,7 @@ struct execparam {
 /*
  * Function meant to executed as a pthread_create start routine.  It takes
  * a struct execparam as an argument and uses the fields of the struct as
- * parameters to the execvp call.  We implemented forktest clone ... as a 
+ * parameters to the execvp call. We implemented forktest clone ... as a
  * thread because android does not implement clone() for the x86 emulator
  * and thread creation is implemented through clone.
  */
@@ -71,13 +71,13 @@ void forktest(int agm_num, char *agm[])
 			perror("failed to vfork");
 		else {
 			if (pid == 0) {
-				for (j =0; j < agm_num - 3; j++)
+				for (j = 0; j < agm_num - 3; j++)
 					tmp[j] = agm[3 + j];
 				tmp[j] = NULL;
 				execvp(tmp[0], tmp);
 				perror("Command not found");
 				exit(1);
-			}else
+			} else
 				waitpid(pid, NULL, 0);
 		}
 	} else if (strcmp(agm[index + 2], "clone") == 0) {
@@ -110,7 +110,7 @@ int main(int argc, char *argv[])
 	int i;
 	int j;
 
-	if (strcmp(argv[0], "./forktest") == 0) {
+	if (strcmp(argv[0], "./forktest" == 0) {
 		if (argc < 4) {
 			printf("Please provide a complete command.\n");
 			return -1;
-- 
1.7.9.5


From df7fde4df839ab25ba95b1e5b2369b9b3e39859e Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sat, 2 Mar 2013 17:16:59 -0500
Subject: [PATCH 55/64] deleted the printf function in setcolors so that when
 setting colors the process information will not be
 displayed

---
 user_tests/getcolors.c |   20 ++++++++++++++++----
 user_tests/setcolors.c |   38 ++++++++++++--------------------------
 2 files changed, 28 insertions(+), 30 deletions(-)

diff --git a/user_tests/getcolors.c b/user_tests/getcolors.c
index 6342b53..a4cf3a7 100644
--- a/user_tests/getcolors.c
+++ b/user_tests/getcolors.c
@@ -11,7 +11,15 @@
 
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
-#define __NR_get_colors 251
+#define __NR_get_colors 251 /* X86_32, arm */
+
+/*
+ * X86_64:
+ * #define __NR_get_colors 296
+ * 
+ * arm:
+ * #define __NR_get_colors 362
+ */
 
 int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 {
@@ -50,7 +58,7 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 {
 	int index;
 	printf("\n*********************************************************");
-	printf("*****************\n");
+	printf("***************\n");
 	for (index = 0; index < nr_pids; index++) {
 		if (pids[index] == 0) {		
 			printf("[%d]", index);
@@ -72,6 +80,7 @@ int main(int argc, char *argv[])
 	int nr_pids;
 	int retval[MAX_PROC_NUM];
 	int i;
+	int flag;
 	char *procName[MAX_PROC_NUM];
 	pid_t pids[MAX_PROC_NUM];
 	u_int16_t colors[MAX_PROC_NUM];
@@ -94,8 +103,11 @@ int main(int argc, char *argv[])
 		colors[i] = 0;
 	}
 	find_pid_by_name(nr_pids, procName, pids);
-	syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-	print_cmd_info(nr_pids, pids, colors, retval, procName);
+	flag = syscall(__NR_get_colors, nr_pids, pids, colors, retval);
+	if (flag != 0)
+		printf("Failed to get colors.\n");
+	else
+		print_cmd_info(nr_pids, pids, colors, retval, procName);
 	return 0;
 }
 
diff --git a/user_tests/setcolors.c b/user_tests/setcolors.c
index bbd8dac..524c9f7 100644
--- a/user_tests/setcolors.c
+++ b/user_tests/setcolors.c
@@ -11,9 +11,15 @@
 
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
-#define __NR_set_colors 223
-
+#define __NR_set_colors 223  /* X86_32 , i386 */
 
+/*
+ * X86_84:
+ * define __NR_set_colors 295 
+ *
+ * arm:
+ * define __NR_set_colors 361
+ */
 
 int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 {
@@ -46,28 +52,6 @@ int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 	return 0;
 }
 
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
-			int *retval, char *procName[])
-{
-	int index;
-	printf("\n***********************************************************");
-	printf("************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0) {	
-			printf("[%d]", index);
-			printf("Process %s does not exist\n", procName[index]);
-		} else {
-			printf("[%d]", index);
-			printf("process name:%s      ", procName[index]);
-			printf("pid:%d      ", pids[index]);
-			printf("color:%d     ", colors[index]);
-			printf("set status:%d\n", retval[index]);
-		}
-	}
-	printf("***********************************************************");
-	printf("************\n\n");
-}
-
 int main(int argc, char *argv[])
 {
 	int nr_pids;
@@ -75,6 +59,7 @@ int main(int argc, char *argv[])
 	int i;
 	int j = 0;
 	int k = 0;
+	int flag;
 	char *procName[MAX_PROC_NUM];
 	pid_t pids[MAX_PROC_NUM];
 	u_int16_t colors[MAX_PROC_NUM];
@@ -108,7 +93,8 @@ int main(int argc, char *argv[])
 		}
 	}
 	find_pid_by_name(nr_pids, procName, pids);
-	print_cmd_info(nr_pids, pids, colors, retval, procName);
-	syscall(__NR_set_colors, nr_pids, pids, colors, retval);
+	flag = syscall(__NR_set_colors, nr_pids, pids, colors, retval);
+	if (flag != 0)
+		printf("Failed to set colors.\n");
 	return 0;
 }
-- 
1.7.9.5


From a03b46e70e43e9dc70d7c388a4393fbba8f3c265 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rbs2152@columbia.edu>
Date: Sat, 2 Mar 2013 17:30:38 -0500
Subject: [PATCH 56/64] -added preprocessor conditions to handle other
 architectures.

---
 user_tests/getcolors.c |   17 +++++++++--------
 user_tests/setcolors.c |   11 ++++++++++-
 2 files changed, 19 insertions(+), 9 deletions(-)

diff --git a/user_tests/getcolors.c b/user_tests/getcolors.c
index a4cf3a7..127ac31 100644
--- a/user_tests/getcolors.c
+++ b/user_tests/getcolors.c
@@ -11,15 +11,16 @@
 
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
-#define __NR_get_colors 251 /* X86_32, arm */
 
-/*
- * X86_64:
- * #define __NR_get_colors 296
- * 
- * arm:
- * #define __NR_get_colors 362
- */
+#ifdef __X86_64__
+# define __NR_get_colors 296
+#else 
+# ifdef __arm__
+#  define __NR_get_colors 362
+# else
+#  define __NR_get_colors 251
+# endif
+#endif
 
 int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 {
diff --git a/user_tests/setcolors.c b/user_tests/setcolors.c
index 524c9f7..f3daf01 100644
--- a/user_tests/setcolors.c
+++ b/user_tests/setcolors.c
@@ -9,9 +9,18 @@
 #include <sys/syscall.h>
 #include <unistd.h>
 
+#ifdef __X86_64__
+# define __NR_set_colors 295 
+#else 
+# ifdef __arm__
+#  define __NR_set_colors 361
+# else
+#  define __NR_set_colors 223
+# endif
+#endif
+
 #define MAX_PROC_NUM 20
 #define FILE_LEN 50
-#define __NR_set_colors 223  /* X86_32 , i386 */
 
 /*
  * X86_84:
-- 
1.7.9.5


From 555ace0411d840519f188ad2072d10096259f055 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sat, 2 Mar 2013 17:53:02 -0500
Subject: [PATCH 57/64] added contributions to coversheet

---
 COVER_SHEET_HW2.txt |    8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
index ca55729..4d9e783 100644
--- a/COVER_SHEET_HW2.txt
+++ b/COVER_SHEET_HW2.txt
@@ -12,7 +12,7 @@ Name and UNI of Group Member 3: ___my2372_________________
    
 
 We certify that:
-   	   _ Our code compiles and works for all reasonable inputs
+	 -->> Our code compiles and works for all reasonable inputs
 	   _ Our code compiles, but does not work for all inputs
 	   _ Our code does not compile
 
@@ -51,7 +51,11 @@ Member Contributions:
 
 
 Pei Qin(pq2117):
-
+*Wrote the setcolors test programs.
+*Wrote the getcolors test programs.
+*Modified the macros in system calls.
+*Researched the binder source code and participated in modifying the code.
+*Researched the clone system call.
 
 
 
-- 
1.7.9.5


From bb681995f1ad5bac0e73ef970e638adde67a2f40 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sun, 3 Mar 2013 00:38:52 -0500
Subject: [PATCH 58/64] modified the error handling

---
 user_tests/getcolors.c |   10 +++++-----
 user_tests/setcolors.c |   19 ++++++++++++++++++-
 2 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/user_tests/getcolors.c b/user_tests/getcolors.c
index 127ac31..f7fc85c 100644
--- a/user_tests/getcolors.c
+++ b/user_tests/getcolors.c
@@ -59,9 +59,9 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 {
 	int index;
 	printf("\n*********************************************************");
-	printf("***************\n");
+	printf("**************\n");
 	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] == 0) {		
+		if (pids[index] <= 0) {		
 			printf("[%d]", index);
 			printf("Process %s does not exist\n", procName[index]);
 		} else {
@@ -69,7 +69,7 @@ void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
 			printf("process name:%s      ", procName[index]);
 			printf("pid:%d      ", pids[index]);
 			printf("color:%d     ", colors[index]);
-			printf("set status:%d\n", retval[index]);
+			printf("retval:%d\n", retval[index]);
 			}
 	}
 	printf("***********************************************************");
@@ -105,8 +105,8 @@ int main(int argc, char *argv[])
 	}
 	find_pid_by_name(nr_pids, procName, pids);
 	flag = syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-	if (flag != 0)
-		printf("Failed to get colors.\n");
+	if (flag != 0) 
+		printf("Errors occurred.\n");
 	else
 		print_cmd_info(nr_pids, pids, colors, retval, procName);
 	return 0;
diff --git a/user_tests/setcolors.c b/user_tests/setcolors.c
index f3daf01..c9f9e76 100644
--- a/user_tests/setcolors.c
+++ b/user_tests/setcolors.c
@@ -61,6 +61,23 @@ int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
 	return 0;
 }
 
+void error_print(int nr_pids, int *retval, char *procName[])
+{
+	int index;
+	printf("\n****************Errors occurred***************************");
+	printf("**************\n");
+	for (index = 0; index < nr_pids; index++) {
+		if (retval[index] != 0) {
+			printf("[%d]", index);
+			printf("Failed to set colors to %s", procName[index]);
+			printf("      ");
+			printf("retval:%d\n", retval[index]);
+		}
+	}
+	printf("***********************************************************");
+	printf("**************\n\n");
+}
+
 int main(int argc, char *argv[])
 {
 	int nr_pids;
@@ -104,6 +121,6 @@ int main(int argc, char *argv[])
 	find_pid_by_name(nr_pids, procName, pids);
 	flag = syscall(__NR_set_colors, nr_pids, pids, colors, retval);
 	if (flag != 0)
-		printf("Failed to set colors.\n");
+		error_print(nr_pids, retval, procName);
 	return 0;
 }
-- 
1.7.9.5


From d3f14344401a9f9d6efcd50f837723c8b053cbcb Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sun, 3 Mar 2013 15:56:08 -0500
Subject: [PATCH 59/64] added Part I of group assignments in README_HW2

---
 README_HW2.md |    1 +
 1 file changed, 1 insertion(+)

diff --git a/README_HW2.md b/README_HW2.md
index 81a5acf..c0bfcc6 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -47,3 +47,4 @@ README for OS Homework Assignment 2
 
 # Part 1
 2.6.29, riley@algiers #32 Thu Feb 28 09:11:03 EST 2013
+2.6.29, pq2117@paris #18 Sun Mar 3 15:45:45 EST 2013
-- 
1.7.9.5


From c79be25c71823beae889daca542401c54d65134c Mon Sep 17 00:00:00 2001
From: MENG YAO <my2372@columbia.edu>
Date: Sun, 3 Mar 2013 16:46:55 -0500
Subject: [PATCH 60/64] added PART I of homework in readme file

---
 COVER_SHEET_HW2.txt |    3 +--
 README_HW2.md       |    1 +
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
index cb27aaf..61f3e16 100644
--- a/COVER_SHEET_HW2.txt
+++ b/COVER_SHEET_HW2.txt
@@ -63,8 +63,7 @@ Pei Qin(pq2117):
 #Meng Yao(my2372):
 *Wrote the permissions check in the binder.c and tested it.
 *Wrote the find_pid_by_name function in setcolors.c with Pei Qin.
-*Wrote the initial version of forktest.c
-
+*Wrote the forktest test
 
 
 
diff --git a/README_HW2.md b/README_HW2.md
index c0bfcc6..1ed4ce9 100644
--- a/README_HW2.md
+++ b/README_HW2.md
@@ -48,3 +48,4 @@ README for OS Homework Assignment 2
 # Part 1
 2.6.29, riley@algiers #32 Thu Feb 28 09:11:03 EST 2013
 2.6.29, pq2117@paris #18 Sun Mar 3 15:45:45 EST 2013
+2.6.29  my2372@islamabad #6 Thu Feb 28 21:52:11 EST 2013
-- 
1.7.9.5


From 705f7aee46619d39ebdb9a9517a0666b6646a440 Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sun, 3 Mar 2013 18:12:18 -0500
Subject: [PATCH 61/64] Removed the test programs, README, and COVER_SHEET

---
 COVER_SHEET_HW2.txt     |  119 --------------------------------------------
 README_HW2.md           |   51 -------------------
 user_tests/Makefile     |   65 ------------------------
 user_tests/Makefile.ndk |   51 -------------------
 user_tests/forktest.c   |  122 ---------------------------------------------
 user_tests/getcolors.c  |  114 ------------------------------------------
 user_tests/setcolors.c  |  126 -----------------------------------------------
 7 files changed, 648 deletions(-)
 delete mode 100644 COVER_SHEET_HW2.txt
 delete mode 100644 README_HW2.md
 delete mode 100644 user_tests/Makefile
 delete mode 100644 user_tests/Makefile.ndk
 delete mode 100644 user_tests/forktest.c
 delete mode 100644 user_tests/getcolors.c
 delete mode 100644 user_tests/setcolors.c

diff --git a/COVER_SHEET_HW2.txt b/COVER_SHEET_HW2.txt
deleted file mode 100644
index 61f3e16..0000000
--- a/COVER_SHEET_HW2.txt
+++ /dev/null
@@ -1,119 +0,0 @@
-Spring 2013 Programming Assignment
-
-Assignment Number: HW2
-   
-Group Number: Group11
-
-Name and UNI of Group Member 1: ___rbs2152_______________
-   
-Name and UNI of Group Member 2: ___pq2117________________
-
-Name and UNI of Group Member 3: ___my2372_________________
-   
-
-We certify that:
-	 -->> Our code compiles and works for all reasonable inputs
-	   _ Our code compiles, but does not work for all inputs
-	   _ Our code does not compile
-
-    * While we may have discussed the assignment with others, the code
-       submitted is entirely our own group's work and no other student 
-       has edited it.
-     * So far as we have been able to determine, the program properly
-       handles all reasonable inputs.
-
-   Further instructions to the student: 
-     * Check your code to make sure it is readable. You may wish to
-       add some comments, change a variable name, or even restructure the
-       code. This also often helps you find bugs in the code.
-     * Include this file with the files you submit for your
-       programming assignment.  The file should be named  "pg_cover.txt".
-
-     * Describe below how each member of your group contributed to the
-       assignment.  Include a list of C functions and files that you modified
-       or implemented and which group member was primarily responsible
-       for doing each.  All group members are expected to contribute in
-       writing the code for each assignment.
-       
-Member Contributions:
-* We all worked together at the same computer when modifying the system call tables for each architecture.
-
-# Riley Spahn(rbs2152): 
-* Wrote initial version of the get_colors system call.
-* Wrote initial version of the set_colors system call.
-* Wrote the get_color helper.
-* Wrote the set_color helper.
-* Wrote the set_tg_color helper.
-* Researched and noted where we should modify the binder source code.
-* Wrote the clone section of forktest which included the execparam struct and the execclone function.
-
-
-
-
-Pei Qin(pq2117):
-*Wrote the setcolors test programs.
-*Wrote the getcolors test programs.
-*Modified the macros in system calls.
-*Researched the binder source code and participated in modifying the code.
-*Researched the clone system call.
-
-
-
-
-#Meng Yao(my2372):
-*Wrote the permissions check in the binder.c and tested it.
-*Wrote the find_pid_by_name function in setcolors.c with Pei Qin.
-*Wrote the forktest test
-
-
-
-If your program does not work for all test inputs or does not compile,
-please complete the following section. You should describe below what 
-the bug is and how you tried to debug it. Document only the most
-significant bug. This is you chance to get partial credit for code
-that does not pass testing. If you do not make a good faith effort to fill this
-section in when you know your code doesn't compile/work, you may
-automatically be given a zero for those parts of the assignment
-
-     * Describe the conditions that cause the program to fail. For
-       example, you may know that it always fails for a particular input
-       or kind of input. Or you may know that it always fails when try it
-       for the second time, or when a certain procedure gets called with
-       a certain argument or when a particular global variable has a
-       particular value.
-       
-     
-
-
-
-     * When the program fails, what error message or other output does it
-       generate?
-       
-     
-     
-     
-     * What does the error message mean? 
-       
-     
-     
-     
-     * When the program fails, which of your procedures is it running?
-       
-     
-     
-     * In your source code, put comments /*** Buggy code here ***/
-       around the line that it is executing when it fails. Describe
-       below how you know that this is the right line.  If you can't 
-       determine which line then put BOLD comments around the 
-       different possible lines it could be executing. 
-       
-     
-     
-     * Do you believe the bug is in this procedure? If not, do you think
-       it's in a procedure that called it, or in some procedure that was
-       executed previously and that either returned a bad value, or that
-       placed a bad value in a variable someplace? Why? Note: we're not
-       asking you to get this right. We're just asking you to give a
-       plausible answer with a plausible justification, enough to show
-       that you're developing sound reasoning processes for diagnosis.
- 
diff --git a/README_HW2.md b/README_HW2.md
deleted file mode 100644
index 1ed4ce9..0000000
--- a/README_HW2.md
+++ /dev/null
@@ -1,51 +0,0 @@
-README for OS Homework Assignment 2
-
-# Files:
-* kernel/color.c
-    * get_colors - the system call that we added that will return the colors of the processes provided.
-    * set_colors - the system call that will will set all of the pids in the parameter list to a given color.  It will also call another function that will propgate that color to all other processes that have the same tgid as the given pid.  This makes sure that all of a processes threads have the same id.
-    * get_color - helper function that returns the color associated with a pid.
-    * set_color - helper function that will set the color of a process.  It locks before called the fin_task_by_pid function and there are unlocks in each of the conditional branches to ensure that the task_list is locked for as short a time as possible.
-    * set_tg_color - sets all of the processes in a given thread group to the color parameter.
- * kernel/fork.c
-    * Added to the copy_process function that will propogate the parent processes color to the child.
-    * Added to the do_fork function that will ensure that the color does not propogate if vfork is called instead of clone or fork.
-* drivers/stagin/android/binder.c
-    * added conditional to binder_transaction that will test if the src and dest process have the same color or 0 color and if not will return execute the err_dead_binder error condition.
-* include/linux/sched.h
-    * added the u_int16_t color field to the task_struct.
-* user_tests/forktest.c
-    * contains the forktest program that is required for the assignment.
-    * to build: >> make
-* user_tests/getcolors.c
-    * contains the getcolors user program that will get the colors of the given processes.
-    * to build: >> make
-* user_tests/setcolors.c
-    * containts the setcolors program that will set the colors of the given processes.
-    * to build >> make
-* user_tests/Makefile
-* user_test/forktest.c
-    * contains the forktest program that will execute fork(),vfork(),clone() syscall.
-    * to build >>make
-    * Note: Since the clone sytem call is not available on x86 we are using threads as a substitute.  Threads are implemented using clone so in this way we are indirectly testing clone.
-    * When executing forktest you must use the ./ notation unless the program is in your path.  As an example you will need to do: ./forktest 10 fork ./forktest 10 fork ls
-    * When executing setcolors and getcolors test programs, you must use ./ notation and no _ between set or get and colors. Besides, the number of processes should not exceed 20. If you do type something else instead of a color after the process name, the color will be considered as 0. For example, if you type ./setcolors com.android.email com.android.phone, the program will set color 0 to com.android.email 
-
-# System Call Numbers
-* x86_32:
-    * set_colors - 223
-    * get_colors - 251
-* x86_64:
-    * set_colors - 295
-    * get_colors - 296
-* i386 (same as x86 32 bit):
-    * set_colors - 223
-    * get_colors - 251
-* arm:
-    * set_colors - 361
-    * get_colors - 362
-
-# Part 1
-2.6.29, riley@algiers #32 Thu Feb 28 09:11:03 EST 2013
-2.6.29, pq2117@paris #18 Sun Mar 3 15:45:45 EST 2013
-2.6.29  my2372@islamabad #6 Thu Feb 28 21:52:11 EST 2013
diff --git a/user_tests/Makefile b/user_tests/Makefile
deleted file mode 100644
index 2b4317f..0000000
--- a/user_tests/Makefile
+++ /dev/null
@@ -1,65 +0,0 @@
-APP := test
-FORK := forktest
-SET := setcolors
-GET := getcolors
-ROOT:=$(HOME)
-NDK_PLATFORM_VER := 14
-INSTALL_DIR := /data/tmp
-
-ANDROID_SDK_ROOT:=$(ROOT)/android-sdk-linux
-ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8d
-ANDROID_NDK_HOST:=linux-x86
-ANDROID_TARGET:=i686-linux-android
-ANDROID_TARGET_ARCH:=x86
-ANDROID_TOOLCHAIN:=x86-4.4.3
-
-BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
-LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
-INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
-BIN := $(BINDIR)/bin
- 
-CPP := $(BIN)/$(ANDROID_TARGET)-g++
-CC := $(BIN)/$(ANDROID_TARGET)-gcc
-CFLAGS := -I$(INCDIR)
-LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
-LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
- 
- 
-all: app
- 
- 
-app: object
-	$(CC) $(LDFLAGS) -o $(FORK) $(FORK).o
-	$(CC) $(LDFLAGS) -o $(SET) $(SET).o
-	$(CC) $(LDFLAGS) -o $(GET) $(GET).o
-
- 
-object: forktest.c getcolors.c setcolors.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $(GET).c -o $(GET).o
-	$(CC) -c $(INCLUDE) $(CFLAGS) $(FORK).c -o $(FORK).o
-	$(CC) -c $(INCLUDE) $(CFLAGS) $(SET).c -o $(SET).o
-	
-
-
-install: app
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(FORK) $(INSTALL_DIR)/$(FORK) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(SET) $(INSTALL_DIR)/$(SET) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(GET) $(INSTALL_DIR)/$(GET) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(FORK)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(SET)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(GET)
- 
-shell:
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
- 
-#run:
-#	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-#r: $(APP)
-#	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-#	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
-#	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-clean:
-	@rm -f *.o $(FORK) $(SET) $(GET)
-
diff --git a/user_tests/Makefile.ndk b/user_tests/Makefile.ndk
deleted file mode 100644
index fea6101..0000000
--- a/user_tests/Makefile.ndk
+++ /dev/null
@@ -1,51 +0,0 @@
-APP := test
-ROOT:=$(HOME)
-NDK_PLATFORM_VER := 14
-INSTALL_DIR := /data/tmp
-
-ANDROID_SDK_ROOT:=$(ROOT)/android-sdk-linux
-ANDROID_NDK_ROOT:=$(ROOT)/android-ndk-r8d
-ANDROID_NDK_HOST:=linux-x86
-ANDROID_TARGET:=i686-linux-android
-ANDROID_TARGET_ARCH:=x86
-ANDROID_TOOLCHAIN:=x86-4.4.3
-
-BINDIR:=$(ANDROID_NDK_ROOT)/toolchains/$(ANDROID_TOOLCHAIN)/prebuilt/$(ANDROID_NDK_HOST)
-LIBDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/lib
-INCDIR:=$(ANDROID_NDK_ROOT)/platforms/android-$(NDK_PLATFORM_VER)/arch-$(ANDROID_TARGET_ARCH)/usr/include
-BIN := $(BINDIR)/bin
- 
-CPP := $(BIN)/$(ANDROID_TARGET)-g++
-CC := $(BIN)/$(ANDROID_TARGET)-gcc
-CFLAGS := -I$(INCDIR)
-LDFLAGS := -Wl,-rpath-link=$(LIBDIR),-dynamic-linker=/system/bin/linker -L$(LIBDIR) 
-LDFLAGS += $(LIBDIR)/crtbegin_dynamic.o $(LIBDIR)/crtend_android.o -nostdlib -lc -disable-multilib -lm
- 
- 
-all: $(APP)
- 
-OBJS += $(APP).o
- 
-$(APP): $(OBJS)
-	$(CC) $(LDFLAGS) -o $@ $^
- 
-%.o: %.c
-	$(CC) -c $(INCLUDE) $(CFLAGS) $< -o $@ 
-install: $(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
- 
-shell:
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell
- 
-run:
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-r: $(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb push $(APP) $(INSTALL_DIR)/$(APP) 
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell chmod 777 $(INSTALL_DIR)/$(APP)
-	$(ANDROID_SDK_ROOT)/platform-tools/adb shell $(INSTALL_DIR)/$(APP)
- 
-clean:
-	@rm -f $(APP).o $(APP)
-
diff --git a/user_tests/forktest.c b/user_tests/forktest.c
deleted file mode 100644
index 7c9afd8..0000000
--- a/user_tests/forktest.c
+++ /dev/null
@@ -1,122 +0,0 @@
-#include <pthread.h>
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <sys/wait.h>
-#include <sched.h>
-#include <signal.h>
-#include <unistd.h>
-
-/*
- * Stucture that is used as a parameter for the execclone function.
- * file - the file parameter of the execvp call.
- * argv - the argv parameter of the execvp call.
- */
-struct execparam {
-	char *file;
-	char **argv;
-};
-
-/*
- * Function meant to executed as a pthread_create start routine.  It takes
- * a struct execparam as an argument and uses the fields of the struct as
- * parameters to the execvp call.  We implemented forktest clone ... as a
- * thread because android does not implement clone() for the x86 emulator
- * and thread creation is implemented through clone.
- */
-void *execclone(void *input)
-{
-	struct execparam *toexec;
-	toexec = (struct execparam *)input;
-	if (execvp(toexec->file, toexec->argv) == -1) {
-		perror("Failed to exec in cloned pthread.\n");
-		exit(1);
-	}
-}
-
-void forktest(int agm_num, char *agm[])
-{
-	pthread_t thread;
-	struct execparam params;
-	char *tmp[10];
-	int delay;
-	int pid;
-	int index = 0;
-	int i;
-	int j;
-
-	index = 0;
-	delay = atoi(agm[index + 1]);
-	sleep(delay);
-	if (strcmp(agm[index + 2], "fork") == 0) {
-		pid = fork();
-		if (pid < 0)
-			perror("failed to fork");
-		else {
-			if (pid == 0) {
-				for (j = 0; j < agm_num - 3; j++)
-					tmp[j] = agm[3 + j];
-				tmp[j] = NULL;
-				execvp(tmp[0], tmp);
-				perror("Command not found");
-				exit(1);
-			} else
-				waitpid(pid, NULL, 0);
-		}
-	} else if (strcmp(agm[index + 2], "vfork") == 0) {
-		pid = vfork();
-		if (pid < 0)
-			perror("failed to vfork");
-		else {
-			if (pid == 0) {
-				for (j = 0; j < agm_num - 3; j++)
-					tmp[j] = agm[3 + j];
-				tmp[j] = NULL;
-				execvp(tmp[0], tmp);
-				perror("Command not found");
-				exit(1);
-			} else
-				waitpid(pid, NULL, 0);
-		}
-	} else if (strcmp(agm[index + 2], "clone") == 0) {
-		for (j = 0; j < agm_num - 3; j++)
-			tmp[j] = agm[3 + j];
-		tmp[j] = NULL;
-
-		params.file = tmp[0];
-		params.argv = tmp;
-		pid = pthread_create(&thread, NULL, execclone, &params);
-		if (pid != 0) {
-			fprintf(stderr, "Error: executing forktest.\n");
-			exit(1);
-		} else {
-			pthread_exit(NULL);
-		}
-	} else
-		printf(stderr, "Not a valid command!\n");
-}
-
-int main(int argc, char *argv[])
-{
-	char errormsg[] =
-		"Error: forktest <delay> <clone|fork|vfork> <command>";
-	char *str[argc];
-	int i;
-	int j;
-
-	if (strcmp(argv[0], "./forktest") == 0) {
-		if (argc < 4) {
-			printf("Please provide a complete command.\n");
-			fprintf(stderr, errormsg);
-			return -1;
-		}
-		for (i = 0; i < argc; i++)
-			str[i] = argv[i];
-		j = argc;
-		forktest(j, str);
-		return 0;
-	}
-}
diff --git a/user_tests/getcolors.c b/user_tests/getcolors.c
deleted file mode 100644
index f7fc85c..0000000
--- a/user_tests/getcolors.c
+++ /dev/null
@@ -1,114 +0,0 @@
-/******************************************************
- *This is a test program that is used to test getcolors
- ******************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-
-#ifdef __X86_64__
-# define __NR_get_colors 296
-#else 
-# ifdef __arm__
-#  define __NR_get_colors 362
-# else
-#  define __NR_get_colors 251
-# endif
-#endif
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-	struct dirent *d;
-	FILE *fp;
-	DIR *dir;
-	char path[FILE_LEN];
-	char cmdline[FILE_LEN];
-	int index;
-	dir = opendir("/proc");
-	if (!dir) {
-		perror("Open proc directory failed!");
-		exit(EXIT_FAILURE);
-	}
-	while ((d = readdir(dir)) != NULL) {
-		sprintf(path, "/proc/%s/cmdline", d->d_name);
-		fp = fopen(path, "r");
-		if (fp != NULL) {
-			fread(cmdline, 1, FILE_LEN, fp);
-			cmdline[FILE_LEN - 1] = '\0';
-			for (index = 0; index < nr_pids; index++) {
-				if (cmdline == strstr(cmdline,
-					 procName[index]))
-					pids[index] = atoi(d->d_name);
-			}
-		fclose(fp);
-		}
-	}
-	closedir(dir);
-	return 0;
-}
-
-
-void print_cmd_info(int nr_pids, pid_t *pids, u_int16_t *colors,
-			int *retval, char *procName[])
-{
-	int index;
-	printf("\n*********************************************************");
-	printf("**************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (pids[index] <= 0) {		
-			printf("[%d]", index);
-			printf("Process %s does not exist\n", procName[index]);
-		} else {
-			printf("[%d]", index);
-			printf("process name:%s      ", procName[index]);
-			printf("pid:%d      ", pids[index]);
-			printf("color:%d     ", colors[index]);
-			printf("retval:%d\n", retval[index]);
-			}
-	}
-	printf("***********************************************************");
-	printf("************\n\n");
-}
-
-int main(int argc, char *argv[])
-{
-	int nr_pids;
-	int retval[MAX_PROC_NUM];
-	int i;
-	int flag;
-	char *procName[MAX_PROC_NUM];
-	pid_t pids[MAX_PROC_NUM];
-	u_int16_t colors[MAX_PROC_NUM];
-	if (strcmp(argv[0], "./getcolors") != 0) {
-		printf("Invalid command!\n");
-		return -1;
-	}
-	if (argc == 1) {
-		printf("Please provide a name of a process.\n");
-		return -1;
-	}
-	if (argc > (MAX_PROC_NUM + 1)) {
-		printf("Too many processes!\n");
-		return -1;
-	}
-	nr_pids = argc - 1;
-	for (i = 0; i < nr_pids; i++) {
-		procName[i] = argv[i + 1];
-		retval[i] = 0;
-		colors[i] = 0;
-	}
-	find_pid_by_name(nr_pids, procName, pids);
-	flag = syscall(__NR_get_colors, nr_pids, pids, colors, retval);
-	if (flag != 0) 
-		printf("Errors occurred.\n");
-	else
-		print_cmd_info(nr_pids, pids, colors, retval, procName);
-	return 0;
-}
-
diff --git a/user_tests/setcolors.c b/user_tests/setcolors.c
deleted file mode 100644
index c9f9e76..0000000
--- a/user_tests/setcolors.c
+++ /dev/null
@@ -1,126 +0,0 @@
-/******************************************************
- *This is a test program that is used to test setcolors
- ******************************************************/
-#include <stdio.h>
-#include <string.h>
-#include <stdlib.h>
-#include <dirent.h>
-#include <sys/types.h>
-#include <sys/syscall.h>
-#include <unistd.h>
-
-#ifdef __X86_64__
-# define __NR_set_colors 295 
-#else 
-# ifdef __arm__
-#  define __NR_set_colors 361
-# else
-#  define __NR_set_colors 223
-# endif
-#endif
-
-#define MAX_PROC_NUM 20
-#define FILE_LEN 50
-
-/*
- * X86_84:
- * define __NR_set_colors 295 
- *
- * arm:
- * define __NR_set_colors 361
- */
-
-int find_pid_by_name(int nr_pids, char *procName[], pid_t *pids)
-{
-	struct dirent *d;
-	FILE *fp;
-	DIR *dir;
-	char path[FILE_LEN];
-	char cmdline[FILE_LEN];
-	int index;
-	dir = opendir("/proc");
-	if (!dir) {
-		perror("Open proc directory failed!");
-		exit(EXIT_FAILURE);
-	}
-	while ((d = readdir(dir)) != NULL) {
-		sprintf(path, "/proc/%s/cmdline", d->d_name);
-		fp = fopen(path, "r");
-		if (fp != NULL) {
-			fread(cmdline, 1, FILE_LEN, fp);
-			cmdline[FILE_LEN - 1] = '\0';
-			for (index = 0; index < nr_pids; index++) {
-				if (cmdline == strstr(cmdline,
-					 procName[index]))
-					pids[index] = atoi(d->d_name);
-			}
-		fclose(fp);
-		}
-	}
-	closedir(dir);
-	return 0;
-}
-
-void error_print(int nr_pids, int *retval, char *procName[])
-{
-	int index;
-	printf("\n****************Errors occurred***************************");
-	printf("**************\n");
-	for (index = 0; index < nr_pids; index++) {
-		if (retval[index] != 0) {
-			printf("[%d]", index);
-			printf("Failed to set colors to %s", procName[index]);
-			printf("      ");
-			printf("retval:%d\n", retval[index]);
-		}
-	}
-	printf("***********************************************************");
-	printf("**************\n\n");
-}
-
-int main(int argc, char *argv[])
-{
-	int nr_pids;
-	int retval[MAX_PROC_NUM];
-	int i;
-	int j = 0;
-	int k = 0;
-	int flag;
-	char *procName[MAX_PROC_NUM];
-	pid_t pids[MAX_PROC_NUM];
-	u_int16_t colors[MAX_PROC_NUM];
-	if (strcmp(argv[0], "./setcolors") != 0) {
-		printf("Invalid command!\n");
-		return -1;
-	}
-	if (argc == 1) {
-		printf("Please provide a name of a process.\n");
-		return -1;
-	}
-	if (argc % 2 == 0) {
-		printf("The number of processes and colors should be ");
-		printf("identical.\n");
-		return -1;
-	}
-	if (argc > (2 * MAX_PROC_NUM + 1)) {
-		printf("Too many processes!\n");
-		return -1;
-	}
-	nr_pids = argc / 2;
-	for (i = 0; i < nr_pids; i++)
-		retval[i] = 0;
-	for (i = 1; i <= argc; i++) {
-		if (i % 2 == 1) {
-			procName[j] = argv[i];
-			j++;
-		} else {
-			colors[k] = atoi(argv[i]);
-			k++;
-		}
-	}
-	find_pid_by_name(nr_pids, procName, pids);
-	flag = syscall(__NR_set_colors, nr_pids, pids, colors, retval);
-	if (flag != 0)
-		error_print(nr_pids, retval, procName);
-	return 0;
-}
-- 
1.7.9.5


From 12ae27f7301d2b26526fc1e1aeda603f4d0a90ca Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sun, 3 Mar 2013 18:23:19 -0500
Subject: [PATCH 62/64] -removed trailing whitespace in
 arch/arm/include/asm/unistd.h

---
 arch/arm/include/asm/unistd.h |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/arch/arm/include/asm/unistd.h b/arch/arm/include/asm/unistd.h
index 3baf394..83408f8 100644
--- a/arch/arm/include/asm/unistd.h
+++ b/arch/arm/include/asm/unistd.h
@@ -389,7 +389,7 @@
 #define __NR_inotify_init1		(__NR_SYSCALL_BASE+360)
 
 /* Added 2/19/13 */
-#define __NR_set_colors4		(__NR_SYSCALL_BASE+361) 
+#define __NR_set_colors4		(__NR_SYSCALL_BASE+361)
 #define __NR_get_colors4		(__NR_SYSCALL_BASE+362)
 
 /*
-- 
1.7.9.5


From 5a8f2ac144811ac8243e3da4f982082c3d57a988 Mon Sep 17 00:00:00 2001
From: Riley Spahn <rileyspahn@gmail.com>
Date: Sun, 3 Mar 2013 18:27:26 -0500
Subject: [PATCH 63/64] -corrected errors style errors caught by checkpatch.

---
 drivers/staging/android/binder.c |   13 +++++++------
 include/linux/sched.h            |    4 ++--
 kernel/fork.c                    |    2 +-
 3 files changed, 10 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index 089fd2e..a53473a 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -1265,16 +1265,17 @@ binder_transaction_buffer_release(struct binder_proc *proc,
  * proc - binder_proc calling process
  *
  * To modify binder:
- * - Get the origin PID from thread parameter, maybe proc parameter. 2nd parameter
- *   When the binder_transaction is built we can get the pid of the calling process
- *   and the pid of the receiving process.  When this is built we can then do the
+ * - Get the origin PID from thread parameter, maybe proc parameter. 2nd
+ *   parameter When the binder_transaction is built we can get the pid of 
+ *   the calling process and the pid of the receiving process.  When this
+ *   is built we can then do the
  *   checks to determine if the processes are the same color.
  *
  * - We can add an error at the bottom of the function and use a goto to clear
  *   throw the error if the processes are not colored correctly.
  *
- * - It lookds like target_proc is assigned around 1370.  Should be able to test
- *   after this.
+ * - It lookds like target_proc is assigned around 1370.  Should be able to
+ *   test after this.
  */
 
 static void
@@ -1370,7 +1371,7 @@ binder_transaction(struct binder_proc *proc, struct binder_thread *thread,
 			goto err_dead_binder;
 		}
 
-		/** 
+		/**
 		 * Added by: Riley Spahn and Meng Yao
 		 * We should be able to test for the same pids here and throw
 		 * and errof if needed.
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 9d112d8..64c1b1f 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -1418,8 +1418,8 @@ struct task_struct {
 	unsigned long trace;
 #endif
 
-        /* added color for some sort of security. Added 2/18/13 */
-        u_int16_t color;
+	/* added color for some sort of security. Added 2/18/13 */
+	u_int16_t color;
 };
 
 /* Future-safe accessor for struct task_struct's cpus_allowed. */
diff --git a/kernel/fork.c b/kernel/fork.c
index b491fa0..2bdc4c5 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1017,7 +1017,7 @@ static struct task_struct *copy_process(unsigned long clone_flags,
 		goto bad_fork_cleanup_put_domain;
 
 	/**
-	 * Added by: Riley Spahn, Date: 2/26/13 
+	 * Added by: Riley Spahn, Date: 2/26/13
 	 */
 	rcu_read_lock();
 	p->color = current->color;
-- 
1.7.9.5


From 45c9f733d4732353310509c9d7192c3ef7a52dba Mon Sep 17 00:00:00 2001
From: Pei Qin <pq2117@columbia.edu>
Date: Sun, 3 Mar 2013 18:31:05 -0500
Subject: [PATCH 64/64] Removed trailing whitespace

---
 drivers/staging/android/binder.c |    6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/drivers/staging/android/binder.c b/drivers/staging/android/binder.c
index a53473a..0f2df18 100644
--- a/drivers/staging/android/binder.c
+++ b/drivers/staging/android/binder.c
@@ -1266,7 +1266,7 @@ binder_transaction_buffer_release(struct binder_proc *proc,
  *
  * To modify binder:
  * - Get the origin PID from thread parameter, maybe proc parameter. 2nd
- *   parameter When the binder_transaction is built we can get the pid of 
+ *   parameter When the binder_transaction is built we can get the pid of
  *   the calling process and the pid of the receiving process.  When this
  *   is built we can then do the
  *   checks to determine if the processes are the same color.
@@ -1376,10 +1376,10 @@ binder_transaction(struct binder_proc *proc, struct binder_thread *thread,
 		 * We should be able to test for the same pids here and throw
 		 * and errof if needed.
 		 */
-		if ((target_proc->tsk->color != 0) && (proc->tsk->color != 0) 
+		if ((target_proc->tsk->color != 0) && (proc->tsk->color != 0)
 		&& (target_proc->tsk->color != proc->tsk->color)) {
 				return_error = BR_FAILED_REPLY;
-				goto err_dead_binder;		
+				goto err_dead_binder;
 		}
 
 		if (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {
-- 
1.7.9.5

